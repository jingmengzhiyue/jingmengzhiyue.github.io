

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jingmengzhiyue">
  <meta name="keywords" content="">
  
    <meta name="description" content="数据挖掘中pandas的使用，Pandas索引">
<meta property="og:type" content="article">
<meta property="og:title" content="Pandas索引">
<meta property="og:url" content="http://jingmengzhiyue.top/2023/10/01/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name" content="热爱可抵万难">
<meta property="og:description" content="数据挖掘中pandas的使用，Pandas索引">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jingmengzhiyue.top/2023/10/01/source/_static/multi_index.png">
<meta property="article:published_time" content="2023-10-01T13:13:43.000Z">
<meta property="article:modified_time" content="2024-03-14T12:19:11.996Z">
<meta property="article:author" content="Jingmengzhiyue">
<meta property="article:tag" content="Pandas">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://jingmengzhiyue.top/2023/10/01/source/_static/multi_index.png">
  
  
  
  <title>Pandas索引 - 热爱可抵万难</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jingmengzhiyue.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"eZ6fNr2wGbxSreDqCc24Ik6y-gzGzoHsz","app_key":"I1HMoNZO5iKmmCSzqE0wTpGr","server_url":"https://ez6fnr2w.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
  
    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>
   


<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>热爱可抵万难</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://t.mwm.moe/fj/') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Pandas索引"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-01 21:13" pubdate>
          2023年10月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          40k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          333 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Pandas索引</h1>
            
            
              <div class="markdown-body">
                
                <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure>
<h1 id="pandas索引">Pandas索引</h1>
<h2 id="一索引器">一、索引器</h2>
<h3 id="表的列索引">1. 表的列索引</h3>
<p>列索引是最常见的索引形式，一般通过<code>[]</code>来实现。通过<code>[列名]</code>可以从<code>DataFrame</code>中取出相应的列，返回值为<code>Series</code>，例如从表中取出姓名一列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>, usecols = [<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>, <span class="hljs-string">&#x27;Transfer&#x27;</span>])<br>df[<span class="hljs-string">&#x27;Name&#x27;</span>].head()<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">0      Gaopeng Yang
1    Changqiang You
2           Mei Sun
3      Xiaojuan Sun
4       Gaojuan You
Name: Name, dtype: object</code></pre>
<p>如果要取出多个列，则可以通过<code>[列名组成的列表]</code>，其返回值为一个<code>DataFrame</code>，例如从表中取出性别和姓名两列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[[<span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>]].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Gender
</th>
<th>
Name
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
Female
</td>
<td>
Gaopeng Yang
</td>
</tr>
<tr>
<th>
1
</th>
<td>
Male
</td>
<td>
Changqiang You
</td>
</tr>
<tr>
<th>
2
</th>
<td>
Male
</td>
<td>
Mei Sun
</td>
</tr>
<tr>
<th>
3
</th>
<td>
Female
</td>
<td>
Xiaojuan Sun
</td>
</tr>
<tr>
<th>
4
</th>
<td>
Male
</td>
<td>
Gaojuan You
</td>
</tr>
</tbody>
</table>
</div>
<p>此外，若要取出单列，且列名中不包含空格，则可以用<code>.列名</code>取出，这和<code>[列名]</code>是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.Name.head()<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">0      Gaopeng Yang
1    Changqiang You
2           Mei Sun
3      Xiaojuan Sun
4       Gaojuan You
Name: Name, dtype: object</code></pre>
<h3 id="序列的行索引">2. 序列的行索引</h3>
<p>【a】以字符串为索引的<code>Series</code></p>
<p>如果取出单个索引的对应元素，则可以使用<code>[item]</code>，若<code>Series</code>只有单个值对应，则返回这个标量值，如果有多个值对应，则返回一个<code>Series</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], index=[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>])<br>s[<span class="hljs-string">&#x27;a&#x27;</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">a    1
a    3
a    4
a    5
dtype: int64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;b&#x27;</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">2</code></pre>
<p>如果取出多个索引的对应元素，则可以使用<code>[items的列表]</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[[<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">c    6
b    2
dtype: int64</code></pre>
<p>如果想要取出某两个索引之间的元素，并且这两个索引是在整个索引中唯一出现，则可以使用切片,，同时需要注意这里的切片会包含两个端点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>: -<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">c    6
a    4
b    2
dtype: int64</code></pre>
<p>如果前后端点的值重复出现，那么需要经过排序才能使用切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    s[<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>]<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">KeyError(&quot;Cannot get left slice bound for non-unique label: &#39;a&#39;&quot;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.sort_index()[<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">a    1
a    3
a    4
a    5
b    2
dtype: int64</code></pre>
<p>【b】以整数为索引的<code>Series</code></p>
<p>在使用数据的读入函数时，如果不特别指定所对应的列作为索引，那么会生成从0开始的整数索引作为默认索引。当然，任意一组符合长度要求的整数都可以作为索引。</p>
<p>和字符串一样，如果使用<code>[int]</code>或<code>[int_list]</code>，则可以取出对应索引<strong>元素</strong>的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>], index=[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>])<br>s[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">1    a
1    c
dtype: object</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">2    d
3    b
dtype: object</code></pre>
<p>如果使用整数切片，则会取出对应索引<strong>位置</strong>的值，注意这里的整数切片同<code>Python</code>中的切片一样不包含右端点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">3    b
2    d
dtype: object</code></pre>
<h4 id="warning关于索引类型的说明">【WARNING】关于索引类型的说明</h4>
<p>如果不想陷入麻烦，那么请不要把纯浮点以及任何混合类型（字符串、整数、浮点类型等的混合）作为索引，否则可能会在具体的操作时报错或者返回非预期的结果，并且在实际的数据分析中也不存在这样做的动机。</p>
<h4 id="end">【END】</h4>
<h3 id="loc索引器">3. loc索引器</h3>
<p>前面讲到了对<code>DataFrame</code>的列进行选取，下面要讨论其行的选取。对于表而言，有两种索引器，一种是基于<strong>元素</strong>的<code>loc</code>索引器，另一种是基于<strong>位置</strong>的<code>iloc</code>索引器。</p>
<p><code>loc</code>索引器的一般形式是<code>loc[*, *]</code>，其中第一个<code>*</code>代表行的选择，第二个<code>*</code>代表列的选择，如果省略第二个位置写作<code>loc[*]</code>，这个<code>*</code>是指行的筛选。其中，<code>*</code>的位置一共有五类合法对象，分别是：单个元素、元素列表、元素切片、布尔列表以及函数，下面将依次说明。</p>
<p>为了演示相应操作，先利用<code>set_index</code>方法把<code>Name</code>列设为索引，关于该函数的其他用法将在多级索引一章介绍。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo = df.set_index(<span class="hljs-string">&#x27;Name&#x27;</span>)<br>df_demo.head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Gaopeng Yang
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
<td>
Female
</td>
<td>
46.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Changqiang You
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Mei Sun
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Xiaojuan Sun
</th>
<td>
Fudan University
</td>
<td>
Sophomore
</td>
<td>
Female
</td>
<td>
41.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Gaojuan You
</th>
<td>
Fudan University
</td>
<td>
Sophomore
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>【a】<code>*</code>为单个元素</p>
<p>此时，直接取出相应的行或列，如果该元素在索引中重复则结果为<code>DataFrame</code>，否则为<code>Series</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Qiang Sun&#x27;</span>] <span class="hljs-comment"># 多个人叫此名字</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Qiang Sun
</th>
<td>
Tsinghua University
</td>
<td>
Junior
</td>
<td>
Female
</td>
<td>
53.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Qiang Sun
</th>
<td>
Tsinghua University
</td>
<td>
Sophomore
</td>
<td>
Female
</td>
<td>
40.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Qiang Sun
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Junior
</td>
<td>
Female
</td>
<td>
NaN
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Quan Zhao&#x27;</span>] <span class="hljs-comment"># 名字唯一</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs">School      Shanghai Jiao Tong University
Grade                              Junior
Gender                             Female
Weight                               53.0
Transfer                                N
Name: Quan Zhao, dtype: object</code></pre>
<p>也可以同时选择行和列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Qiang Sun&#x27;</span>, <span class="hljs-string">&#x27;School&#x27;</span>] <span class="hljs-comment"># 返回Series</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs">Name
Qiang Sun              Tsinghua University
Qiang Sun              Tsinghua University
Qiang Sun    Shanghai Jiao Tong University
Name: School, dtype: object</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Quan Zhao&#x27;</span>, <span class="hljs-string">&#x27;School&#x27;</span>] <span class="hljs-comment"># 返回单个元素</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs">&#39;Shanghai Jiao Tong University&#39;</code></pre>
<p>【b】<code>*</code>为元素列表</p>
<p>此时，取出列表中所有元素值对应的行或列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[[<span class="hljs-string">&#x27;Qiang Sun&#x27;</span>,<span class="hljs-string">&#x27;Quan Zhao&#x27;</span>], [<span class="hljs-string">&#x27;School&#x27;</span>,<span class="hljs-string">&#x27;Gender&#x27;</span>]]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Gender
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Qiang Sun
</th>
<td>
Tsinghua University
</td>
<td>
Female
</td>
</tr>
<tr>
<th>
Qiang Sun
</th>
<td>
Tsinghua University
</td>
<td>
Female
</td>
</tr>
<tr>
<th>
Qiang Sun
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Female
</td>
</tr>
<tr>
<th>
Quan Zhao
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Female
</td>
</tr>
</tbody>
</table>
</div>
<p>【c】<code>*</code>为切片</p>
<p>之前的<code>Series</code>使用字符串索引时提到，如果是唯一值的起点和终点字符，那么就可以使用切片，并且包含两个端点，如果不唯一则报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Gaojuan You&#x27;</span>:<span class="hljs-string">&#x27;Gaoqiang Qian&#x27;</span>, <span class="hljs-string">&#x27;School&#x27;</span>:<span class="hljs-string">&#x27;Gender&#x27;</span>]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Gaojuan You
</th>
<td>
Fudan University
</td>
<td>
Sophomore
</td>
<td>
Male
</td>
</tr>
<tr>
<th>
Xiaoli Qian
</th>
<td>
Tsinghua University
</td>
<td>
Freshman
</td>
<td>
Female
</td>
</tr>
<tr>
<th>
Qiang Chu
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
<td>
Female
</td>
</tr>
<tr>
<th>
Gaoqiang Qian
</th>
<td>
Tsinghua University
</td>
<td>
Junior
</td>
<td>
Female
</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，如果<code>DataFrame</code>使用整数索引，其使用整数切片的时候和上面字符串索引的要求一致，都是<strong>元素</strong>切片，包含端点且起点、终点不允许有重复值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df_loc_slice_demo = df_demo.copy()<br>df_loc_slice_demo.index = <span class="hljs-built_in">range</span>(df_demo.shape[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>df_loc_slice_demo.loc[<span class="hljs-number">5</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
5
</th>
<td>
Fudan University
</td>
<td>
Junior
</td>
<td>
Female
</td>
<td>
46.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
4
</th>
<td>
Tsinghua University
</td>
<td>
Senior
</td>
<td>
Female
</td>
<td>
50.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
3
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Female
</td>
<td>
45.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_loc_slice_demo.loc[<span class="hljs-number">3</span>:<span class="hljs-number">5</span>] <span class="hljs-comment"># 没有返回，说明不是整数位置切片</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
</div>
<p>【d】<code>*</code>为布尔列表</p>
<p>在实际的数据处理中，根据条件来筛选行是极其常见的，此处传入<code>loc</code>的布尔列表与<code>DataFrame</code>长度相同，且列表为<code>True</code>的位置所对应的行会被选中，<code>False</code>则会被剔除。</p>
<p>例如，选出体重超过70kg的学生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[df_demo.Weight&gt;<span class="hljs-number">70</span>].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Mei Sun
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Gaojuan You
</th>
<td>
Fudan University
</td>
<td>
Sophomore
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Xiaopeng Zhou
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Xiaofeng Sun
</th>
<td>
Tsinghua University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
71.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Qiang Zheng
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
87.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>前面所提到的传入元素列表，也可以通过<code>isin</code>方法返回的布尔列表等价写出，例如选出所有大一和大四的同学信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[df_demo.Grade.isin([<span class="hljs-string">&#x27;Freshman&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>])].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Gaopeng Yang
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
<td>
Female
</td>
<td>
46.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Changqiang You
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Mei Sun
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Xiaoli Qian
</th>
<td>
Tsinghua University
</td>
<td>
Freshman
</td>
<td>
Female
</td>
<td>
51.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Qiang Chu
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
<td>
Female
</td>
<td>
52.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>对于复合条件而言，可以用<code>|（或）, &amp;（且）, ~（取反）</code>的组合来实现，例如选出复旦大学中体重超过70kg的大四学生，或者北大男生中体重超过80kg的非大四的学生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">condition_1_1 = df_demo.School == <span class="hljs-string">&#x27;Fudan University&#x27;</span><br>condition_1_2 = df_demo.Grade == <span class="hljs-string">&#x27;Senior&#x27;</span><br>condition_1_3 = df_demo.Weight &gt; <span class="hljs-number">70</span><br>condition_1 = condition_1_1 &amp; condition_1_2 &amp; condition_1_3<br>condition_2_1 = df_demo.School == <span class="hljs-string">&#x27;Peking University&#x27;</span><br>condition_2_2 = df_demo.Grade == <span class="hljs-string">&#x27;Senior&#x27;</span><br>condition_2_3 = df_demo.Weight &gt; <span class="hljs-number">80</span><br>condition_2 = condition_2_1 &amp; (~condition_2_2) &amp; condition_2_3<br>df_demo.loc[condition_1 | condition_2]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Qiang Han
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
87.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Chengpeng Zhou
</th>
<td>
Fudan University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
81.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Changpeng Zhao
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
83.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Chengpeng Qian
</th>
<td>
Fudan University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
73.0
</td>
<td>
Y
</td>
</tr>
</tbody>
</table>
</div>
<h4 id="练一练">【练一练】</h4>
<p><code>select_dtypes</code>是一个实用函数，它能够从表中选出相应类型的列，若要选出所有数值型的列，只需使用<code>.select_dtypes('number')</code>，请利用布尔列表选择的方法结合<code>DataFrame</code>的<code>dtypes</code>属性在<code>learn_pandas</code>数据集上实现这个功能。</p>
<h4 id="end-1">【END】</h4>
<p>【e】<code>*</code>为函数</p>
<p>这里的函数，必须以前面的四种合法形式之一为返回值，并且函数的输入值为<code>DataFrame</code>本身。假设仍然是上述复合条件筛选的例子，可以把逻辑写入一个函数中再返回，需要注意的是函数的形式参数<code>x</code>本质上即为<code>df_demo</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">condition</span>(<span class="hljs-params">x</span>):<br>    condition_1_1 = x.School == <span class="hljs-string">&#x27;Fudan University&#x27;</span><br>    condition_1_2 = x.Grade == <span class="hljs-string">&#x27;Senior&#x27;</span><br>    condition_1_3 = x.Weight &gt; <span class="hljs-number">70</span><br>    condition_1 = condition_1_1 &amp; condition_1_2 &amp; condition_1_3<br>    condition_2_1 = x.School == <span class="hljs-string">&#x27;Peking University&#x27;</span><br>    condition_2_2 = x.Grade == <span class="hljs-string">&#x27;Senior&#x27;</span><br>    condition_2_3 = x.Weight &gt; <span class="hljs-number">80</span><br>    condition_2 = condition_2_1 &amp; (~condition_2_2) &amp; condition_2_3<br>    result = condition_1 | condition_2<br>    <span class="hljs-keyword">return</span> result<br>df_demo.loc[condition]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Qiang Han
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
87.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Chengpeng Zhou
</th>
<td>
Fudan University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
81.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Changpeng Zhao
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
83.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Chengpeng Qian
</th>
<td>
Fudan University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
73.0
</td>
<td>
Y
</td>
</tr>
</tbody>
</table>
</div>
<p>此外，还支持使用<code>lambda</code>表达式，其返回值也同样必须是先前提到的四种形式之一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-keyword">lambda</span> x:<span class="hljs-string">&#x27;Quan Zhao&#x27;</span>, <span class="hljs-keyword">lambda</span> x:<span class="hljs-string">&#x27;Gender&#x27;</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">&#39;Female&#39;</code></pre>
<p>由于函数无法返回如<code>start: end: step</code>的切片形式，故返回切片时要用<code>slice</code>对象进行包装：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">slice</span>(<span class="hljs-string">&#x27;Gaojuan You&#x27;</span>, <span class="hljs-string">&#x27;Gaoqiang Qian&#x27;</span>)]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Gaojuan You
</th>
<td>
Fudan University
</td>
<td>
Sophomore
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Xiaoli Qian
</th>
<td>
Tsinghua University
</td>
<td>
Freshman
</td>
<td>
Female
</td>
<td>
51.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Qiang Chu
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
<td>
Female
</td>
<td>
52.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Gaoqiang Qian
</th>
<td>
Tsinghua University
</td>
<td>
Junior
</td>
<td>
Female
</td>
<td>
50.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>最后需要指出的是，对于<code>Series</code>也可以使用<code>loc</code>索引，其遵循的原则与<code>DataFrame</code>中用于行筛选的<code>loc[*]</code>完全一致，此处不再赘述。</p>
<h4 id="warning不要使用链式赋值">【WARNING】不要使用链式赋值</h4>
<p>在对表或者序列赋值时，应当在使用一层索引器后直接进行赋值操作，这样做是由于进行多次索引后赋值是赋在临时返回的<code>copy</code>副本上的，而没有真正修改元素从而报出<code>SettingWithCopyWarning</code>警告。例如，下面给出的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">df_chain = pd.DataFrame([[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]], columns=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;AB&#x27;</span>))<br>df_chain<br><span class="hljs-keyword">import</span> warnings<br><span class="hljs-keyword">with</span> warnings.catch_warnings():<br>    warnings.filterwarnings(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        df_chain[df_chain.A!=<span class="hljs-number">0</span>].B = <span class="hljs-number">1</span> <span class="hljs-comment"># 使用方括号列索引后，再使用点的列索引</span><br>    <span class="hljs-keyword">except</span> Warning <span class="hljs-keyword">as</span> w:<br>        Warning_Msg = w<br><span class="hljs-built_in">print</span>(Warning_Msg)<br>df_chain<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
A
</th>
<th>
B
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
0
</td>
</tr>
<tr>
<th>
1
</th>
<td>
1
</td>
<td>
0
</td>
</tr>
<tr>
<th>
2
</th>
<td>
-1
</td>
<td>
0
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_chain.loc[df_chain.A!=<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;B&#x27;</span>] = <span class="hljs-number">1</span><br>df_chain<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
A
</th>
<th>
B
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
0
</td>
<td>
0
</td>
</tr>
<tr>
<th>
1
</th>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<th>
2
</th>
<td>
-1
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
<h4 id="end-2">【END】</h4>
<h3 id="iloc索引器">4. iloc索引器</h3>
<p><code>iloc</code>的使用与<code>loc</code>完全类似，只不过是针对位置进行筛选，在相应的<code>*</code>位置处一共也有五类合法对象，分别是：整数、整数列表、整数切片、布尔列表以及函数，函数的返回值必须是前面的四类合法对象中的一个，其输入同样也为<code>DataFrame</code>本身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] <span class="hljs-comment"># 第二行第二列</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs">&#39;Freshman&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]] <span class="hljs-comment"># 前两行前两列</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Gaopeng Yang
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
</tr>
<tr>
<th>
Changqiang You
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[<span class="hljs-number">1</span>: <span class="hljs-number">4</span>, <span class="hljs-number">2</span>:<span class="hljs-number">4</span>] <span class="hljs-comment"># 切片不包含结束端点</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Gender
</th>
<th>
Weight
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Changqiang You
</th>
<td>
Male
</td>
<td>
70.0
</td>
</tr>
<tr>
<th>
Mei Sun
</th>
<td>
Male
</td>
<td>
89.0
</td>
</tr>
<tr>
<th>
Xiaojuan Sun
</th>
<td>
Female
</td>
<td>
41.0
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)] <span class="hljs-comment"># 传入切片为返回值的函数</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Changqiang You
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Mei Sun
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Xiaojuan Sun
</th>
<td>
Fudan University
</td>
<td>
Sophomore
</td>
<td>
Female
</td>
<td>
41.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>在使用布尔列表的时候要特别注意，不能传入<code>Series</code>而必须传入序列的<code>values</code>，否则会报错。因此，在使用布尔筛选的时候还是应当优先考虑<code>loc</code>的方式。</p>
<p>例如，选出体重超过80kg的学生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[(df_demo.Weight&gt;<span class="hljs-number">80</span>).values].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
Name
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Mei Sun
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Qiang Zheng
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
87.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Qiang Han
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Male
</td>
<td>
87.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Chengpeng Zhou
</th>
<td>
Fudan University
</td>
<td>
Senior
</td>
<td>
Male
</td>
<td>
81.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Feng Han
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Sophomore
</td>
<td>
Male
</td>
<td>
82.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>对<code>Series</code>而言同样也可以通过<code>iloc</code>返回相应位置的值或子序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.School.iloc[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">&#39;Peking University&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.School.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">Name
Changqiang You    Peking University
Xiaojuan Sun       Fudan University
Name: School, dtype: object</code></pre>
<h3 id="query方法">5. query方法</h3>
<p>在<code>pandas</code>中，支持把字符串形式的查询表达式传入<code>query</code>方法来查询数据，其表达式的执行结果必须返回布尔列表。在进行复杂索引时，由于这种检索方式无需像普通方法一样重复使用<code>DataFrame</code>的名字来引用列名，一般而言会使代码长度在不降低可读性的前提下有所减少。</p>
<p>例如，将<code>loc</code>一节中的复合条件查询例子可以如下改写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&#x27;((School == &quot;Fudan University&quot;)&amp;&#x27;</span><br>         <span class="hljs-string">&#x27; (Grade == &quot;Senior&quot;)&amp;&#x27;</span><br>         <span class="hljs-string">&#x27; (Weight &gt; 70))|&#x27;</span><br>         <span class="hljs-string">&#x27;((School == &quot;Peking University&quot;)&amp;&#x27;</span><br>         <span class="hljs-string">&#x27; (Grade != &quot;Senior&quot;)&amp;&#x27;</span><br>         <span class="hljs-string">&#x27; (Weight &gt; 80))&#x27;</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
38
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Qiang Han
</td>
<td>
Male
</td>
<td>
87.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
66
</th>
<td>
Fudan University
</td>
<td>
Senior
</td>
<td>
Chengpeng Zhou
</td>
<td>
Male
</td>
<td>
81.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
99
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Changpeng Zhao
</td>
<td>
Male
</td>
<td>
83.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
131
</th>
<td>
Fudan University
</td>
<td>
Senior
</td>
<td>
Chengpeng Qian
</td>
<td>
Male
</td>
<td>
73.0
</td>
<td>
Y
</td>
</tr>
</tbody>
</table>
</div>
<p>在<code>query</code>表达式中，帮用户注册了所有来自<code>DataFrame</code>的列名，所有属于该<code>Series</code>的方法都可以被调用，和正常的函数调用并没有区别，例如查询体重超过均值的学生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&#x27;Weight &gt; Weight.mean()&#x27;</span>).head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
1
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Changqiang You
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
2
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Mei Sun
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
4
</th>
<td>
Fudan University
</td>
<td>
Sophomore
</td>
<td>
Gaojuan You
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
10
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
<td>
Xiaopeng Zhou
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
14
</th>
<td>
Tsinghua University
</td>
<td>
Senior
</td>
<td>
Xiaomei Zhou
</td>
<td>
Female
</td>
<td>
57.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<h4
id="notequery中引用带空格的列名">【NOTE】query中引用带空格的列名</h4>
<p>对于含有空格的列名，需要使用<code>`col name`</code>的方式进行引用。</p>
<h4 id="end-3">【END】</h4>
<p>同时，在<code>query</code>中还注册了若干英语的字面用法，帮助提高可读性，例如：<code>or, and, or, in, not in</code>。例如，筛选出男生中不是大一大二的学生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&#x27;(Grade not in [&quot;Freshman&quot;, &quot;Sophomore&quot;]) and (Gender == &quot;Male&quot;)&#x27;</span>).head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
2
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Mei Sun
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
16
</th>
<td>
Tsinghua University
</td>
<td>
Junior
</td>
<td>
Xiaoqiang Qin
</td>
<td>
Male
</td>
<td>
68.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
17
</th>
<td>
Tsinghua University
</td>
<td>
Junior
</td>
<td>
Peng Wang
</td>
<td>
Male
</td>
<td>
65.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
18
</th>
<td>
Tsinghua University
</td>
<td>
Senior
</td>
<td>
Xiaofeng Sun
</td>
<td>
Male
</td>
<td>
71.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
21
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Xiaopeng Shen
</td>
<td>
Male
</td>
<td>
62.0
</td>
<td>
NaN
</td>
</tr>
</tbody>
</table>
</div>
<p>此外，在字符串中出现与列表的比较时，<code>==</code>和<code>!=</code>分别表示元素出现在列表和没有出现在列表，等价于<code>in</code>和<code>not in</code>，例如查询所有大三和大四的学生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&#x27;Grade == [&quot;Junior&quot;, &quot;Senior&quot;]&#x27;</span>).head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
2
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Mei Sun
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
7
</th>
<td>
Tsinghua University
</td>
<td>
Junior
</td>
<td>
Gaoqiang Qian
</td>
<td>
Female
</td>
<td>
50.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
9
</th>
<td>
Peking University
</td>
<td>
Junior
</td>
<td>
Juan Xu
</td>
<td>
Female
</td>
<td>
NaN
</td>
<td>
N
</td>
</tr>
<tr>
<th>
11
</th>
<td>
Tsinghua University
</td>
<td>
Junior
</td>
<td>
Xiaoquan Lv
</td>
<td>
Female
</td>
<td>
43.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
12
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Senior
</td>
<td>
Peng You
</td>
<td>
Female
</td>
<td>
48.0
</td>
<td>
NaN
</td>
</tr>
</tbody>
</table>
</div>
<p>对于<code>query</code>中的字符串，如果要引用外部变量，只需在变量名前加<code>@</code>符号。例如，取出体重位于70kg到80kg之间的学生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">low, high =<span class="hljs-number">70</span>, <span class="hljs-number">80</span><br>df.query(<span class="hljs-string">&#x27;(Weight &gt;= @low) &amp; (Weight &lt;= @high)&#x27;</span>).head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
School
</th>
<th>
Grade
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
1
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Changqiang You
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
4
</th>
<td>
Fudan University
</td>
<td>
Sophomore
</td>
<td>
Gaojuan You
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
10
</th>
<td>
Shanghai Jiao Tong University
</td>
<td>
Freshman
</td>
<td>
Xiaopeng Zhou
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
18
</th>
<td>
Tsinghua University
</td>
<td>
Senior
</td>
<td>
Xiaofeng Sun
</td>
<td>
Male
</td>
<td>
71.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
35
</th>
<td>
Peking University
</td>
<td>
Freshman
</td>
<td>
Gaoli Zhao
</td>
<td>
Male
</td>
<td>
78.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<h3 id="随机抽样">6. 随机抽样</h3>
<p>如果把<code>DataFrame</code>的每一行看作一个样本，或把每一列看作一个特征，再把整个<code>DataFrame</code>看作总体，想要对样本或特征进行随机抽样就可以用<code>sample</code>函数。有时在拿到大型数据集后，想要对统计特征进行计算来了解数据的大致分布，但是这很费时间。同时，由于许多统计特征在等概率不放回的简单随机抽样条件下，是总体统计特征的无偏估计，比如样本均值和总体均值，那么就可以先从整张表中抽出一部分来做近似估计。</p>
<p><code>sample</code>函数中的主要参数为<code>n, axis, frac, replace, weights</code>，前三个分别是指抽样数量、抽样的方向（0为行、1为列）和抽样比例（0.3则为从总体中抽出30%的样本）。</p>
<p><code>replace</code>和<code>weights</code>分别是指是否放回和每个样本的抽样相对概率，当<code>replace = True</code>则表示有放回抽样。例如，对下面构造的<code>df_sample</code>以<code>value</code>值的相对大小为抽样概率进行有放回抽样，抽样数量为3。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sample = pd.DataFrame(&#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcde&#x27;</span>), <span class="hljs-string">&#x27;value&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">90</span>]&#125;)<br>df_sample<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
id
</th>
<th>
value
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
a
</td>
<td>
1
</td>
</tr>
<tr>
<th>
1
</th>
<td>
b
</td>
<td>
2
</td>
</tr>
<tr>
<th>
2
</th>
<td>
c
</td>
<td>
3
</td>
</tr>
<tr>
<th>
3
</th>
<td>
d
</td>
<td>
4
</td>
</tr>
<tr>
<th>
4
</th>
<td>
e
</td>
<td>
90
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sample.sample(<span class="hljs-number">3</span>, replace = <span class="hljs-literal">True</span>, weights = df_sample.value)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
id
</th>
<th>
value
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
4
</th>
<td>
e
</td>
<td>
90
</td>
</tr>
<tr>
<th>
4
</th>
<td>
e
</td>
<td>
90
</td>
</tr>
<tr>
<th>
4
</th>
<td>
e
</td>
<td>
90
</td>
</tr>
</tbody>
</table>
</div>
<h2 id="二多级索引">二、多级索引</h2>
<h3 id="多级索引及其表的结构">1. 多级索引及其表的结构</h3>
<p>为了更加清晰地说明具有多级索引的<code>DataFrame</code>结构，下面新构造一张表，读者可以忽略这里的构造方法，它们将会在第4小节被更详细地讲解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>multi_index = pd.MultiIndex.from_product([<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;ABCD&#x27;</span>), df.Gender.unique()], names=(<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>))<br>multi_column = pd.MultiIndex.from_product([[<span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>], df.Grade.unique()], names=(<span class="hljs-string">&#x27;Indicator&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>))<br>df_multi = pd.DataFrame(np.c_[(np.random.randn(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)*<span class="hljs-number">5</span> + <span class="hljs-number">163</span>).tolist(), (np.random.randn(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)*<span class="hljs-number">5</span> + <span class="hljs-number">65</span>).tolist()],<br>                        index = multi_index, columns = multi_column).<span class="hljs-built_in">round</span>(<span class="hljs-number">1</span>)<br>df_multi<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
Indicator
</th>
<th colspan="4" halign="left">
Height
</th>
<th colspan="4" halign="left">
Weight
</th>
</tr>
<tr>
<th>
</th>
<th>
Grade
</th>
<th>
Freshman
</th>
<th>
Senior
</th>
<th>
Sophomore
</th>
<th>
Junior
</th>
<th>
Freshman
</th>
<th>
Senior
</th>
<th>
Sophomore
</th>
<th>
Junior
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Gender
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="2" valign="top">
A
</th>
<th>
Female
</th>
<td>
171.8
</td>
<td>
165.0
</td>
<td>
167.9
</td>
<td>
174.2
</td>
<td>
60.6
</td>
<td>
55.1
</td>
<td>
63.3
</td>
<td>
65.8
</td>
</tr>
<tr>
<th>
Male
</th>
<td>
172.3
</td>
<td>
158.1
</td>
<td>
167.8
</td>
<td>
162.2
</td>
<td>
71.2
</td>
<td>
71.0
</td>
<td>
63.1
</td>
<td>
63.5
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
B
</th>
<th>
Female
</th>
<td>
162.5
</td>
<td>
165.1
</td>
<td>
163.7
</td>
<td>
170.3
</td>
<td>
59.8
</td>
<td>
57.9
</td>
<td>
56.5
</td>
<td>
74.8
</td>
</tr>
<tr>
<th>
Male
</th>
<td>
166.8
</td>
<td>
163.6
</td>
<td>
165.2
</td>
<td>
164.7
</td>
<td>
62.5
</td>
<td>
62.8
</td>
<td>
58.7
</td>
<td>
68.9
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
C
</th>
<th>
Female
</th>
<td>
170.5
</td>
<td>
162.0
</td>
<td>
164.6
</td>
<td>
158.7
</td>
<td>
56.9
</td>
<td>
63.9
</td>
<td>
60.5
</td>
<td>
66.9
</td>
</tr>
<tr>
<th>
Male
</th>
<td>
150.2
</td>
<td>
166.3
</td>
<td>
167.3
</td>
<td>
159.3
</td>
<td>
62.4
</td>
<td>
59.1
</td>
<td>
64.9
</td>
<td>
67.1
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
D
</th>
<th>
Female
</th>
<td>
174.3
</td>
<td>
155.7
</td>
<td>
163.2
</td>
<td>
162.1
</td>
<td>
65.3
</td>
<td>
66.5
</td>
<td>
61.8
</td>
<td>
63.2
</td>
</tr>
<tr>
<th>
Male
</th>
<td>
170.7
</td>
<td>
170.3
</td>
<td>
163.8
</td>
<td>
164.9
</td>
<td>
61.6
</td>
<td>
63.2
</td>
<td>
60.9
</td>
<td>
56.4
</td>
</tr>
</tbody>
</table>
</div>
<p>下图通过颜色区分，标记了<code>DataFrame</code>的结构。与单层索引的表一样，具备元素值、行索引和列索引三个部分。其中，这里的行索引和列索引都是<code>MultiIndex</code>类型，只不过<strong>索引中的一个元素是元组</strong>而不是单层索引中的标量。例如，行索引的第四个元素为<code>("B", "Male")</code>，列索引的第二个元素为<code>("Height", "Senior")</code>，这里需要注意，外层连续出现相同的值时，第一次之后出现的会被隐藏显示，使结果的可读性增强。</p>
<p><img src="../source/_static/multi_index.png" srcset="/img/loading.gif" lazyload width="50%"></p>
<p>与单层索引类似，<code>MultiIndex</code>也具有名字属性，图中的<code>School</code>和<code>Gender</code>分别对应了表的第一层和第二层行索引的名字，<code>Indicator</code>和<code>Grade</code>分别对应了第一层和第二层列索引的名字。</p>
<p>索引的名字和值属性分别可以通过<code>names</code>和<code>values</code>获得：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.index.names<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">FrozenList([&#39;School&#39;, &#39;Gender&#39;])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.columns.names<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">FrozenList([&#39;Indicator&#39;, &#39;Grade&#39;])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.index.values<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">array([(&#39;A&#39;, &#39;Female&#39;), (&#39;A&#39;, &#39;Male&#39;), (&#39;B&#39;, &#39;Female&#39;), (&#39;B&#39;, &#39;Male&#39;),
       (&#39;C&#39;, &#39;Female&#39;), (&#39;C&#39;, &#39;Male&#39;), (&#39;D&#39;, &#39;Female&#39;), (&#39;D&#39;, &#39;Male&#39;)],
      dtype=object)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.columns.values<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">array([(&#39;Height&#39;, &#39;Freshman&#39;), (&#39;Height&#39;, &#39;Senior&#39;),
       (&#39;Height&#39;, &#39;Sophomore&#39;), (&#39;Height&#39;, &#39;Junior&#39;),
       (&#39;Weight&#39;, &#39;Freshman&#39;), (&#39;Weight&#39;, &#39;Senior&#39;),
       (&#39;Weight&#39;, &#39;Sophomore&#39;), (&#39;Weight&#39;, &#39;Junior&#39;)], dtype=object)</code></pre>
<p>如果想要得到某一层的索引，则需要通过<code>get_level_values</code>获得：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.index.get_level_values(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">Index([&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;, &#39;D&#39;, &#39;D&#39;], dtype=&#39;object&#39;, name=&#39;School&#39;)</code></pre>
<p>但对于索引而言，无论是单层还是多层，用户都无法通过<code>index_obj[0] = item</code>的方式来修改元素，也不能通过<code>index_name[0] = new_name</code>的方式来修改名字，关于如何修改这些属性的话题将在第三节被讨论。</p>
<h3 id="多级索引中的loc索引器">2. 多级索引中的loc索引器</h3>
<p>熟悉了结构后，现在回到原表，将学校和年级设为索引，此时的行为多级索引，列为单级索引，由于默认状态的列索引不含名字，因此对应于刚刚图中<code>Indicator</code>和<code>Grade</code>的索引名位置是空缺的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi = df.set_index([<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>])<br>df_multi.head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Shanghai Jiao Tong University
</th>
<th>
Freshman
</th>
<td>
Gaopeng Yang
</td>
<td>
Female
</td>
<td>
46.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Peking University
</th>
<th>
Freshman
</th>
<td>
Changqiang You
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Shanghai Jiao Tong University
</th>
<th>
Senior
</th>
<td>
Mei Sun
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
Fudan University
</th>
<th>
Sophomore
</th>
<td>
Xiaojuan Sun
</td>
<td>
Female
</td>
<td>
41.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Sophomore
</th>
<td>
Gaojuan You
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>由于多级索引中的单个元素以元组为单位，因此之前在第一节介绍的
<code>loc</code> 和 <code>iloc</code>
方法完全可以照搬，只需把标量的位置替换成对应的元组。</p>
<p>当传入元组列表或单个元组或返回前二者的函数时，需要先进行索引排序以避免性能警告：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> warnings.catch_warnings():<br>    warnings.filterwarnings(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        df_multi.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>)].head()<br>    <span class="hljs-keyword">except</span> Warning <span class="hljs-keyword">as</span> w:<br>        Warning_Msg = w<br>Warning_Msg<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">pandas.errors.PerformanceWarning(&#39;indexing past lexsort depth may impact performance.&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted = df_multi.sort_index()<br>df_sorted.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>)].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Fudan University
</th>
<th>
Junior
</th>
<td>
Yanli You
</td>
<td>
Female
</td>
<td>
48.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Chunqiang Chu
</td>
<td>
Male
</td>
<td>
72.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Changfeng Lv
</td>
<td>
Male
</td>
<td>
76.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Yanjuan Lv
</td>
<td>
Female
</td>
<td>
49.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Gaoqiang Zhou
</td>
<td>
Female
</td>
<td>
43.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted.loc[[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>), (<span class="hljs-string">&#x27;Shanghai Jiao Tong University&#x27;</span>, <span class="hljs-string">&#x27;Freshman&#x27;</span>)]].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Fudan University
</th>
<th>
Senior
</th>
<td>
Chengpeng Zheng
</td>
<td>
Female
</td>
<td>
38.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Feng Zhou
</td>
<td>
Female
</td>
<td>
47.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Gaomei Lv
</td>
<td>
Female
</td>
<td>
34.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Chunli Lv
</td>
<td>
Female
</td>
<td>
56.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Chengpeng Zhou
</td>
<td>
Male
</td>
<td>
81.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted.loc[df_sorted.Weight &gt; <span class="hljs-number">70</span>].head() <span class="hljs-comment"># 布尔列表也是可用的</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Fudan University
</th>
<th>
Freshman
</th>
<td>
Feng Wang
</td>
<td>
Male
</td>
<td>
74.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Chunqiang Chu
</td>
<td>
Male
</td>
<td>
72.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Changfeng Lv
</td>
<td>
Male
</td>
<td>
76.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Chengpeng Zhou
</td>
<td>
Male
</td>
<td>
81.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Chengpeng Qian
</td>
<td>
Male
</td>
<td>
73.0
</td>
<td>
Y
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted.loc[<span class="hljs-keyword">lambda</span> x:(<span class="hljs-string">&#x27;Fudan University&#x27;</span>,<span class="hljs-string">&#x27;Junior&#x27;</span>)].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Fudan University
</th>
<th>
Junior
</th>
<td>
Yanli You
</td>
<td>
Female
</td>
<td>
48.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Chunqiang Chu
</td>
<td>
Male
</td>
<td>
72.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Changfeng Lv
</td>
<td>
Male
</td>
<td>
76.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Yanjuan Lv
</td>
<td>
Female
</td>
<td>
49.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Gaoqiang Zhou
</td>
<td>
Female
</td>
<td>
43.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>当使用切片时需要注意，在单级索引中只要切片端点元素是唯一的，那么就可以进行切片，但在多级索引中，无论元组在索引中是否重复出现，都必须经过排序才能使用切片，否则报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    df_multi.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>):].head()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">pandas.errors.UnsortedIndexError(&#39;Key length (2) was greater than MultiIndex lexsort depth (0)&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>):].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Fudan University
</th>
<th>
Senior
</th>
<td>
Chengpeng Zheng
</td>
<td>
Female
</td>
<td>
38.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Feng Zhou
</td>
<td>
Female
</td>
<td>
47.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Gaomei Lv
</td>
<td>
Female
</td>
<td>
34.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Chunli Lv
</td>
<td>
Female
</td>
<td>
56.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Chengpeng Zhou
</td>
<td>
Male
</td>
<td>
81.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_unique = df.drop_duplicates(subset=[<span class="hljs-string">&#x27;School&#x27;</span>,<span class="hljs-string">&#x27;Grade&#x27;</span>]).set_index([<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>])<br>df_unique.head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Shanghai Jiao Tong University
</th>
<th>
Freshman
</th>
<td>
Gaopeng Yang
</td>
<td>
Female
</td>
<td>
46.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Peking University
</th>
<th>
Freshman
</th>
<td>
Changqiang You
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Shanghai Jiao Tong University
</th>
<th>
Senior
</th>
<td>
Mei Sun
</td>
<td>
Male
</td>
<td>
89.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Fudan University
</th>
<th>
Sophomore
</th>
<td>
Xiaojuan Sun
</td>
<td>
Female
</td>
<td>
41.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Tsinghua University
</th>
<th>
Freshman
</th>
<td>
Xiaoli Qian
</td>
<td>
Female
</td>
<td>
51.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    df_unique.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>):].head()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">pandas.errors.UnsortedIndexError(&#39;Key length (2) was greater than MultiIndex lexsort depth (0)&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_unique.sort_index().loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>):].head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="2" valign="top">
Fudan University
</th>
<th>
Senior
</th>
<td>
Chengpeng Zheng
</td>
<td>
Female
</td>
<td>
38.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Sophomore
</th>
<td>
Xiaojuan Sun
</td>
<td>
Female
</td>
<td>
41.0
</td>
<td>
N
</td>
</tr>
<tr>
<th rowspan="3" valign="top">
Peking University
</th>
<th>
Freshman
</th>
<td>
Changqiang You
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Juan Xu
</td>
<td>
Female
</td>
<td>
NaN
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Senior
</th>
<td>
Changli Lv
</td>
<td>
Female
</td>
<td>
41.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<p>此外，在多级索引中的元组有一种特殊的用法，可以对多层的元素进行交叉组合后索引，但同时需要指定<code>loc</code>的列，全选则用<code>:</code>表示。其中，每一层需要选中的元素用列表存放，传入<code>loc</code>的形式为<code>[(level_0_list, level_1_list), cols]</code>。例如，想要得到所有北大和复旦的大二大三学生，可以如下写出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = df_multi.loc[([<span class="hljs-string">&#x27;Peking University&#x27;</span>, <span class="hljs-string">&#x27;Fudan University&#x27;</span>], [<span class="hljs-string">&#x27;Sophomore&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>]), :]<br>res.head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Peking University
</th>
<th>
Sophomore
</th>
<td>
Changmei Xu
</td>
<td>
Female
</td>
<td>
43.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Sophomore
</th>
<td>
Xiaopeng Qin
</td>
<td>
Male
</td>
<td>
NaN
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Sophomore
</th>
<td>
Mei Xu
</td>
<td>
Female
</td>
<td>
39.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Sophomore
</th>
<td>
Xiaoli Zhou
</td>
<td>
Female
</td>
<td>
55.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Sophomore
</th>
<td>
Peng Han
</td>
<td>
Female
</td>
<td>
34.0
</td>
<td>
NaN
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">res.shape<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">(33, 4)</code></pre>
<p>下面的语句和上面类似，但仍然传入的是元素（这里为元组）的列表，它们的意义是不同的，表示的是选出北大的大三学生和复旦的大二学生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = df_multi.loc[[(<span class="hljs-string">&#x27;Peking University&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>), (<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Sophomore&#x27;</span>)]]<br>res.head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
Name
</th>
<th>
Gender
</th>
<th>
Weight
</th>
<th>
Transfer
</th>
</tr>
<tr>
<th>
School
</th>
<th>
Grade
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="5" valign="top">
Peking University
</th>
<th>
Junior
</th>
<td>
Juan Xu
</td>
<td>
Female
</td>
<td>
NaN
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Changjuan You
</td>
<td>
Female
</td>
<td>
47.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Gaoli Xu
</td>
<td>
Female
</td>
<td>
48.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Gaoquan Zhou
</td>
<td>
Male
</td>
<td>
70.0
</td>
<td>
N
</td>
</tr>
<tr>
<th>
Junior
</th>
<td>
Qiang You
</td>
<td>
Female
</td>
<td>
56.0
</td>
<td>
N
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">res.shape<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">(16, 4)</code></pre>
<h3 id="indexslice对象">3. IndexSlice对象</h3>
<p>前面介绍的方法，即使在索引不重复的时候，也只能对元组整体进行切片，而不能对每层进行切片，也不允许将切片和布尔列表混合使用，引入<code>IndexSlice</code>对象就能解决这个问题。<code>Slice</code>对象一共有两种形式，第一种为<code>loc[idx[*,*]]</code>型，第二种为<code>loc[idx[*,*],idx[*,*]]</code>型，下面将进行介绍。为了方便演示，下面构造一个<strong>索引不重复的</strong><code>DataFrame</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>L1,L2 = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>],[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br>mul_index1 = pd.MultiIndex.from_product([L1,L2],names=(<span class="hljs-string">&#x27;Upper&#x27;</span>, <span class="hljs-string">&#x27;Lower&#x27;</span>))<br>L3,L4 = [<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>],[<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>]<br>mul_index2 = pd.MultiIndex.from_product([L3,L4],names=(<span class="hljs-string">&#x27;Big&#x27;</span>, <span class="hljs-string">&#x27;Small&#x27;</span>))<br>df_ex = pd.DataFrame(np.random.randint(-<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,(<span class="hljs-number">9</span>,<span class="hljs-number">9</span>)), index=mul_index1, columns=mul_index2)<br>df_ex<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
Big
</th>
<th colspan="3" halign="left">
D
</th>
<th colspan="3" halign="left">
E
</th>
<th colspan="3" halign="left">
F
</th>
</tr>
<tr>
<th>
</th>
<th>
Small
</th>
<th>
d
</th>
<th>
e
</th>
<th>
f
</th>
<th>
d
</th>
<th>
e
</th>
<th>
f
</th>
<th>
d
</th>
<th>
e
</th>
<th>
f
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="3" valign="top">
A
</th>
<th>
a
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
<td>
-5
</td>
</tr>
<tr>
<th>
b
</th>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
<td>
-4
</td>
<td>
4
</td>
</tr>
<tr>
<th>
c
</th>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
</tr>
<tr>
<th rowspan="3" valign="top">
B
</th>
<th>
a
</th>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
</tr>
<tr>
<th>
b
</th>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
<td>
-9
</td>
<td>
-5
</td>
<td>
-4
</td>
<td>
-3
</td>
<td>
-1
</td>
</tr>
<tr>
<th>
c
</th>
<td>
8
</td>
<td>
6
</td>
<td>
-5
</td>
<td>
0
</td>
<td>
1
</td>
<td>
-8
</td>
<td>
-8
</td>
<td>
-2
</td>
<td>
0
</td>
</tr>
<tr>
<th rowspan="3" valign="top">
C
</th>
<th>
a
</th>
<td>
-6
</td>
<td>
-3
</td>
<td>
2
</td>
<td>
5
</td>
<td>
9
</td>
<td>
-9
</td>
<td>
5
</td>
<td>
-6
</td>
<td>
3
</td>
</tr>
<tr>
<th>
b
</th>
<td>
1
</td>
<td>
2
</td>
<td>
-5
</td>
<td>
-3
</td>
<td>
-5
</td>
<td>
6
</td>
<td>
-6
</td>
<td>
3
</td>
<td>
-5
</td>
</tr>
<tr>
<th>
c
</th>
<td>
-1
</td>
<td>
5
</td>
<td>
6
</td>
<td>
-6
</td>
<td>
6
</td>
<td>
4
</td>
<td>
7
</td>
<td>
8
</td>
<td>
-4
</td>
</tr>
</tbody>
</table>
</div>
<p>为了使用<code>silce</code>对象，先要进行定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idx = pd.IndexSlice<br></code></pre></td></tr></table></figure>
<p>【a】<code>loc[idx[*,*]]</code>型</p>
<p>这种情况并不能进行多层分别切片，前一个<code>*</code>表示行的选择，后一个<code>*</code>表示列的选择，与单纯的<code>loc</code>是类似的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.loc[idx[<span class="hljs-string">&#x27;C&#x27;</span>:, (<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>):]]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
Big
</th>
<th>
D
</th>
<th colspan="3" halign="left">
E
</th>
<th colspan="3" halign="left">
F
</th>
</tr>
<tr>
<th>
</th>
<th>
Small
</th>
<th>
f
</th>
<th>
d
</th>
<th>
e
</th>
<th>
f
</th>
<th>
d
</th>
<th>
e
</th>
<th>
f
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="3" valign="top">
C
</th>
<th>
a
</th>
<td>
2
</td>
<td>
5
</td>
<td>
9
</td>
<td>
-9
</td>
<td>
5
</td>
<td>
-6
</td>
<td>
3
</td>
</tr>
<tr>
<th>
b
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
-5
</td>
<td>
6
</td>
<td>
-6
</td>
<td>
3
</td>
<td>
-5
</td>
</tr>
<tr>
<th>
c
</th>
<td>
6
</td>
<td>
-6
</td>
<td>
6
</td>
<td>
4
</td>
<td>
7
</td>
<td>
8
</td>
<td>
-4
</td>
</tr>
</tbody>
</table>
</div>
<p>另外，也支持布尔序列的索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.loc[idx[:<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">lambda</span> x:x.<span class="hljs-built_in">sum</span>()&gt;<span class="hljs-number">0</span>]] <span class="hljs-comment"># 列和大于0</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
Big
</th>
<th colspan="2" halign="left">
D
</th>
<th>
F
</th>
</tr>
<tr>
<th>
</th>
<th>
Small
</th>
<th>
d
</th>
<th>
e
</th>
<th>
e
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="3" valign="top">
A
</th>
<th>
a
</th>
<td>
3
</td>
<td>
6
</td>
<td>
9
</td>
</tr>
<tr>
<th>
b
</th>
<td>
-3
</td>
<td>
3
</td>
<td>
-4
</td>
</tr>
<tr>
<th>
c
</th>
<td>
-1
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
</tbody>
</table>
</div>
<p>【b】<code>loc[idx[*,*],idx[*,*]]</code>型</p>
<p>这种情况能够分层进行切片，前一个<code>idx</code>指代的是行索引，后一个是列索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.loc[idx[:<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>:], idx[<span class="hljs-string">&#x27;E&#x27;</span>:, <span class="hljs-string">&#x27;e&#x27;</span>:]]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
Big
</th>
<th colspan="2" halign="left">
E
</th>
<th colspan="2" halign="left">
F
</th>
</tr>
<tr>
<th>
</th>
<th>
Small
</th>
<th>
e
</th>
<th>
f
</th>
<th>
e
</th>
<th>
f
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="2" valign="top">
A
</th>
<th>
b
</th>
<td>
-2
</td>
<td>
5
</td>
<td>
-4
</td>
<td>
4
</td>
</tr>
<tr>
<th>
c
</th>
<td>
6
</td>
<td>
6
</td>
<td>
9
</td>
<td>
-6
</td>
</tr>
</tbody>
</table>
</div>
<p>但需要注意的是，此时不支持使用函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    df_ex.loc[idx[:<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">lambda</span> x: <span class="hljs-string">&#x27;b&#x27;</span>], idx[<span class="hljs-string">&#x27;E&#x27;</span>:, <span class="hljs-string">&#x27;e&#x27;</span>:]]<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">KeyError(&lt;function __main__.&lt;lambda&gt;(x)&gt;)</code></pre>
<h3 id="多级索引的构造">4. 多级索引的构造</h3>
<p>前面提到了多级索引表的结构和切片，那么除了使用<code>set_index</code>之外，如何自己构造多级索引呢？常用的有<code>from_tuples, from_arrays, from_product</code>三种方法，它们都是<code>pd.MultiIndex</code>对象下的函数。</p>
<p><code>from_tuples</code>指根据传入由元组组成的列表进行构造：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = [(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;cat&#x27;</span>),(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>),(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;cat&#x27;</span>),(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>)]<br>pd.MultiIndex.from_tuples(my_tuple, names=[<span class="hljs-string">&#x27;First&#x27;</span>,<span class="hljs-string">&#x27;Second&#x27;</span>])<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">MultiIndex([(&#39;a&#39;, &#39;cat&#39;),
            (&#39;a&#39;, &#39;dog&#39;),
            (&#39;b&#39;, &#39;cat&#39;),
            (&#39;b&#39;, &#39;dog&#39;)],
           names=[&#39;First&#39;, &#39;Second&#39;])</code></pre>
<p><code>from_arrays</code>指根据传入列表中，对应层的列表进行构造：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_array = [<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;aabb&#x27;</span>), [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>]*<span class="hljs-number">2</span>]<br>pd.MultiIndex.from_arrays(my_array, names=[<span class="hljs-string">&#x27;First&#x27;</span>,<span class="hljs-string">&#x27;Second&#x27;</span>])<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">MultiIndex([(&#39;a&#39;, &#39;cat&#39;),
            (&#39;a&#39;, &#39;dog&#39;),
            (&#39;b&#39;, &#39;cat&#39;),
            (&#39;b&#39;, &#39;dog&#39;)],
           names=[&#39;First&#39;, &#39;Second&#39;])</code></pre>
<p><code>from_product</code>指根据给定多个列表的笛卡尔积进行构造：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list1 = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>]<br>my_list2 = [<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>]<br>pd.MultiIndex.from_product([my_list1, my_list2], names=[<span class="hljs-string">&#x27;First&#x27;</span>,<span class="hljs-string">&#x27;Second&#x27;</span>])<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">MultiIndex([(&#39;a&#39;, &#39;cat&#39;),
            (&#39;a&#39;, &#39;dog&#39;),
            (&#39;b&#39;, &#39;cat&#39;),
            (&#39;b&#39;, &#39;dog&#39;)],
           names=[&#39;First&#39;, &#39;Second&#39;])</code></pre>
<h2 id="三索引的常用方法">三、索引的常用方法</h2>
<h3 id="索引层的交换和删除">1. 索引层的交换和删除</h3>
<p>为了方便理解交换的过程，这里构造一个三级索引的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>L1,L2,L3 = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>],[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>],[<span class="hljs-string">&#x27;alpha&#x27;</span>,<span class="hljs-string">&#x27;beta&#x27;</span>]<br>mul_index1 = pd.MultiIndex.from_product([L1,L2,L3], names=(<span class="hljs-string">&#x27;Upper&#x27;</span>, <span class="hljs-string">&#x27;Lower&#x27;</span>,<span class="hljs-string">&#x27;Extra&#x27;</span>))<br>L4,L5,L6 = [<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>],[<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>],[<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>]<br>mul_index2 = pd.MultiIndex.from_product([L4,L5,L6], names=(<span class="hljs-string">&#x27;Big&#x27;</span>, <span class="hljs-string">&#x27;Small&#x27;</span>, <span class="hljs-string">&#x27;Other&#x27;</span>))<br>df_ex = pd.DataFrame(np.random.randint(-<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>)), index=mul_index1,  columns=mul_index2)<br>df_ex<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
alpha
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
alpha
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th rowspan="4" valign="top">
B
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
alpha
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
-5
</td>
<td>
-4
</td>
<td>
-3
</td>
<td>
-1
</td>
<td>
8
</td>
<td>
6
</td>
<td>
-5
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
alpha
</th>
<td>
0
</td>
<td>
1
</td>
<td>
-8
</td>
<td>
-8
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
-6
</td>
<td>
-3
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
2
</td>
<td>
5
</td>
<td>
9
</td>
<td>
-9
</td>
<td>
5
</td>
<td>
-6
</td>
<td>
3
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
<p>索引层的交换由<code>swaplevel</code>和<code>reorder_levels</code>完成，前者只能交换两个层，而后者可以交换任意层，两者都可以指定交换的是轴是哪一个，即行索引或列索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.swaplevel(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,axis=<span class="hljs-number">1</span>).head() <span class="hljs-comment"># 列索引的第一层和第三层交换</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th>
c
</th>
<th>
c
</th>
<th>
d
</th>
<th>
d
</th>
<th>
c
</th>
<th>
c
</th>
<th>
d
</th>
<th>
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th>
C
</th>
<th>
C
</th>
<th>
C
</th>
<th>
C
</th>
<th>
D
</th>
<th>
D
</th>
<th>
D
</th>
<th>
D
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
alpha
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
alpha
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
B
</th>
<th>
a
</th>
<th>
alpha
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.reorder_levels([<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],axis=<span class="hljs-number">0</span>).head() <span class="hljs-comment"># 列表数字指代原来索引中的层</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Extra
</th>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
alpha
</th>
<th>
A
</th>
<th>
a
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
beta
</th>
<th>
A
</th>
<th>
a
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th>
alpha
</th>
<th>
A
</th>
<th>
b
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
beta
</th>
<th>
A
</th>
<th>
b
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
alpha
</th>
<th>
B
</th>
<th>
a
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
</tbody>
</table>
</div>
<h4 id="note轴之间的索引交换">【NOTE】轴之间的索引交换</h4>
<p>这里只涉及行或列索引内部的交换，不同方向索引之间的交换将在第五章中被讨论。
#### 【END】
若想要删除某一层的索引，可以使用<code>droplevel</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.droplevel(<span class="hljs-number">1</span>,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
alpha
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
alpha
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th rowspan="4" valign="top">
B
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
alpha
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
-5
</td>
<td>
-4
</td>
<td>
-3
</td>
<td>
-1
</td>
<td>
8
</td>
<td>
6
</td>
<td>
-5
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
alpha
</th>
<td>
0
</td>
<td>
1
</td>
<td>
-8
</td>
<td>
-8
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
-6
</td>
<td>
-3
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
2
</td>
<td>
5
</td>
<td>
9
</td>
<td>
-9
</td>
<td>
5
</td>
<td>
-6
</td>
<td>
3
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.droplevel([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
alpha
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th>
alpha
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
alpha
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
-5
</td>
<td>
-4
</td>
<td>
-3
</td>
<td>
-1
</td>
<td>
8
</td>
<td>
6
</td>
<td>
-5
</td>
</tr>
<tr>
<th>
alpha
</th>
<td>
0
</td>
<td>
1
</td>
<td>
-8
</td>
<td>
-8
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
-6
</td>
<td>
-3
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
2
</td>
<td>
5
</td>
<td>
9
</td>
<td>
-9
</td>
<td>
5
</td>
<td>
-6
</td>
<td>
3
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
<h3 id="索引属性的修改">2. 索引属性的修改</h3>
<p>通过<code>rename_axis</code>可以对索引层的名字进行修改，常用的修改方式是传入字典的映射：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.rename_axis(index=&#123;<span class="hljs-string">&#x27;Upper&#x27;</span>:<span class="hljs-string">&#x27;Changed_row&#x27;</span>&#125;, columns=&#123;<span class="hljs-string">&#x27;Other&#x27;</span>:<span class="hljs-string">&#x27;Changed_Col&#x27;</span>&#125;).head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Changed_Col
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Changed_row
</th>
<th>
Lower
</th>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
alpha
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
alpha
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
B
</th>
<th>
a
</th>
<th>
alpha
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
</tbody>
</table>
</div>
<p>通过<code>rename</code>可以对索引的值进行修改，如果是多级索引需要指定修改的层号<code>level</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.rename(columns=&#123;<span class="hljs-string">&#x27;cat&#x27;</span>:<span class="hljs-string">&#x27;not_cat&#x27;</span>&#125;, level=<span class="hljs-number">2</span>).head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
not_cat
</th>
<th>
dog
</th>
<th>
not_cat
</th>
<th>
dog
</th>
<th>
not_cat
</th>
<th>
dog
</th>
<th>
not_cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
alpha
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
alpha
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
B
</th>
<th>
a
</th>
<th>
alpha
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
</tbody>
</table>
</div>
<p>传入参数也可以是函数，其输入值就是索引元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.rename(index=<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">str</span>.upper(x), level=<span class="hljs-number">2</span>).head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
ALPHA
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
BETA
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
ALPHA
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
BETA
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
B
</th>
<th>
a
</th>
<th>
ALPHA
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
</tbody>
</table>
</div>
<h4 id="练一练-1">【练一练】</h4>
<p>尝试在<code>rename_axis</code>中使用函数完成与例子中一样的功能，即把<code>Upper</code>和<code>Other</code>分别替换为<code>Changed_row</code>和<code>Changed_col</code>。
#### 【END】 对于整个索引的元素替换，可以利用迭代器实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">new_values = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcdefgh&#x27;</span>))<br>df_ex.rename(index=<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">next</span>(new_values), level=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
a
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
b
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
c
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
d
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th rowspan="4" valign="top">
B
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
e
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
<tr>
<th>
f
</th>
<td>
-9
</td>
<td>
-5
</td>
<td>
-4
</td>
<td>
-3
</td>
<td>
-1
</td>
<td>
8
</td>
<td>
6
</td>
<td>
-5
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
g
</th>
<td>
0
</td>
<td>
1
</td>
<td>
-8
</td>
<td>
-8
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
-6
</td>
<td>
-3
</td>
</tr>
<tr>
<th>
h
</th>
<td>
2
</td>
<td>
5
</td>
<td>
9
</td>
<td>
-9
</td>
<td>
5
</td>
<td>
-6
</td>
<td>
3
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
<p>若想要对某个位置的元素进行修改，在单层索引时容易实现，即先取出索引的<code>values</code>属性，再给对得到的列表进行修改，最后再对<code>index</code>对象重新赋值。但是如果是多级索引的话就有些麻烦，一个解决的方案是先把某一层索引临时转为表的元素，然后再进行修改，最后重新设定为索引，下面一节将介绍这些操作。</p>
<p>另外一个需要介绍的函数是<code>map</code>，它是定义在<code>Index</code>上的方法，与前面<code>rename</code>方法中层的函数式用法是类似的，只不过它传入的不是层的标量值，而是直接传入索引的元组，这为用户进行跨层的修改提供了遍历。例如，可以等价地写出上面的字符串转大写的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df_temp = df_ex.copy()<br>new_idx = df_temp.index.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>], <span class="hljs-built_in">str</span>.upper(x[<span class="hljs-number">2</span>])))<br>df_temp.index = new_idx<br>df_temp.head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
<tr>
<th>
Upper
</th>
<th>
Lower
</th>
<th>
Extra
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
ALPHA
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
BETA
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
ALPHA
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
BETA
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
B
</th>
<th>
a
</th>
<th>
ALPHA
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
</tbody>
</table>
</div>
<p>关于<code>map</code>的另一个使用方法是对多级索引的压缩，这在第四章和第五章的一些操作中是有用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df_temp = df_ex.copy()<br>new_idx = df_temp.index.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>]+<span class="hljs-string">&#x27;-&#x27;</span>+x[<span class="hljs-number">1</span>]+<span class="hljs-string">&#x27;-&#x27;</span>+x[<span class="hljs-number">2</span>]))<br>df_temp.index = new_idx<br>df_temp.head() <span class="hljs-comment"># 单层索引</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
A-a-alpha
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
A-a-beta
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th>
A-b-alpha
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
A-b-beta
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
B-a-alpha
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
</tbody>
</table>
</div>
<p>同时，也可以反向地展开：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">new_idx = df_temp.index.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">tuple</span>(x.split(<span class="hljs-string">&#x27;-&#x27;</span>)))<br>df_temp.index = new_idx<br>df_temp.head() <span class="hljs-comment"># 三层索引</span><br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr>
<th>
</th>
<th>
</th>
<th>
Big
</th>
<th colspan="4" halign="left">
C
</th>
<th colspan="4" halign="left">
D
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Small
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
<th colspan="2" halign="left">
c
</th>
<th colspan="2" halign="left">
d
</th>
</tr>
<tr>
<th>
</th>
<th>
</th>
<th>
Other
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
<th>
cat
</th>
<th>
dog
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="4" valign="top">
A
</th>
<th rowspan="2" valign="top">
a
</th>
<th>
alpha
</th>
<td>
3
</td>
<td>
6
</td>
<td>
-9
</td>
<td>
-6
</td>
<td>
-6
</td>
<td>
-2
</td>
<td>
0
</td>
<td>
9
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-5
</td>
<td>
-3
</td>
<td>
3
</td>
<td>
-8
</td>
<td>
-3
</td>
<td>
-2
</td>
<td>
5
</td>
<td>
8
</td>
</tr>
<tr>
<th rowspan="2" valign="top">
b
</th>
<th>
alpha
</th>
<td>
-4
</td>
<td>
4
</td>
<td>
-1
</td>
<td>
0
</td>
<td>
7
</td>
<td>
-4
</td>
<td>
6
</td>
<td>
6
</td>
</tr>
<tr>
<th>
beta
</th>
<td>
-9
</td>
<td>
9
</td>
<td>
-6
</td>
<td>
8
</td>
<td>
5
</td>
<td>
-2
</td>
<td>
-9
</td>
<td>
-8
</td>
</tr>
<tr>
<th>
B
</th>
<th>
a
</th>
<th>
alpha
</th>
<td>
0
</td>
<td>
-9
</td>
<td>
1
</td>
<td>
-6
</td>
<td>
2
</td>
<td>
9
</td>
<td>
-7
</td>
<td>
-9
</td>
</tr>
</tbody>
</table>
</div>
<h3 id="索引的设置与重置">3. 索引的设置与重置</h3>
<p>为了说明本节的函数，下面构造一个新表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new = pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;aacd&#x27;</span>), <span class="hljs-string">&#x27;B&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;PQRT&#x27;</span>), <span class="hljs-string">&#x27;C&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]&#125;)<br>df_new<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
A
</th>
<th>
B
</th>
<th>
C
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
a
</td>
<td>
P
</td>
<td>
1
</td>
</tr>
<tr>
<th>
1
</th>
<td>
a
</td>
<td>
Q
</td>
<td>
2
</td>
</tr>
<tr>
<th>
2
</th>
<td>
c
</td>
<td>
R
</td>
<td>
3
</td>
</tr>
<tr>
<th>
3
</th>
<td>
d
</td>
<td>
T
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<p>索引的设置可以使用<code>set_index</code>完成，这里的主要参数是<code>append</code>，表示是否来保留原来的索引，直接把新设定的添加到原索引的内层：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.set_index(<span class="hljs-string">&#x27;A&#x27;</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
B
</th>
<th>
C
</th>
</tr>
<tr>
<th>
A
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
a
</th>
<td>
P
</td>
<td>
1
</td>
</tr>
<tr>
<th>
a
</th>
<td>
Q
</td>
<td>
2
</td>
</tr>
<tr>
<th>
c
</th>
<td>
R
</td>
<td>
3
</td>
</tr>
<tr>
<th>
d
</th>
<td>
T
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.set_index(<span class="hljs-string">&#x27;A&#x27;</span>, append=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
B
</th>
<th>
C
</th>
</tr>
<tr>
<th>
</th>
<th>
A
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<th>
a
</th>
<td>
P
</td>
<td>
1
</td>
</tr>
<tr>
<th>
1
</th>
<th>
a
</th>
<td>
Q
</td>
<td>
2
</td>
</tr>
<tr>
<th>
2
</th>
<th>
c
</th>
<td>
R
</td>
<td>
3
</td>
</tr>
<tr>
<th>
3
</th>
<th>
d
</th>
<td>
T
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<p>可以同时指定多个列作为索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.set_index([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>])<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
C
</th>
</tr>
<tr>
<th>
A
</th>
<th>
B
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="2" valign="top">
a
</th>
<th>
P
</th>
<td>
1
</td>
</tr>
<tr>
<th>
Q
</th>
<td>
2
</td>
</tr>
<tr>
<th>
c
</th>
<th>
R
</th>
<td>
3
</td>
</tr>
<tr>
<th>
d
</th>
<th>
T
</th>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<p>如果想要添加索引的列没有出现在其中，那么可以直接在参数中传入相应的<code>Series</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_index = pd.Series(<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;WXYZ&#x27;</span>), name=<span class="hljs-string">&#x27;D&#x27;</span>)<br>df_new = df_new.set_index([<span class="hljs-string">&#x27;A&#x27;</span>, my_index])<br>df_new<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
</th>
<th>
B
</th>
<th>
C
</th>
</tr>
<tr>
<th>
A
</th>
<th>
D
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th rowspan="2" valign="top">
a
</th>
<th>
W
</th>
<td>
P
</td>
<td>
1
</td>
</tr>
<tr>
<th>
X
</th>
<td>
Q
</td>
<td>
2
</td>
</tr>
<tr>
<th>
c
</th>
<th>
Y
</th>
<td>
R
</td>
<td>
3
</td>
</tr>
<tr>
<th>
d
</th>
<th>
Z
</th>
<td>
T
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<p><code>reset_index</code>是<code>set_index</code>的逆函数，其主要参数是<code>drop</code>，表示是否要把去掉的索引层丢弃，而不是添加到列中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.reset_index([<span class="hljs-string">&#x27;D&#x27;</span>])<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
D
</th>
<th>
B
</th>
<th>
C
</th>
</tr>
<tr>
<th>
A
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
a
</th>
<td>
W
</td>
<td>
P
</td>
<td>
1
</td>
</tr>
<tr>
<th>
a
</th>
<td>
X
</td>
<td>
Q
</td>
<td>
2
</td>
</tr>
<tr>
<th>
c
</th>
<td>
Y
</td>
<td>
R
</td>
<td>
3
</td>
</tr>
<tr>
<th>
d
</th>
<td>
Z
</td>
<td>
T
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.reset_index([<span class="hljs-string">&#x27;D&#x27;</span>], drop=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
B
</th>
<th>
C
</th>
</tr>
<tr>
<th>
A
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
a
</th>
<td>
P
</td>
<td>
1
</td>
</tr>
<tr>
<th>
a
</th>
<td>
Q
</td>
<td>
2
</td>
</tr>
<tr>
<th>
c
</th>
<td>
R
</td>
<td>
3
</td>
</tr>
<tr>
<th>
d
</th>
<td>
T
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<p>如果重置了所有的索引，那么<code>pandas</code>会直接重新生成一个默认索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.reset_index()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
A
</th>
<th>
D
</th>
<th>
B
</th>
<th>
C
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
a
</td>
<td>
W
</td>
<td>
P
</td>
<td>
1
</td>
</tr>
<tr>
<th>
1
</th>
<td>
a
</td>
<td>
X
</td>
<td>
Q
</td>
<td>
2
</td>
</tr>
<tr>
<th>
2
</th>
<td>
c
</td>
<td>
Y
</td>
<td>
R
</td>
<td>
3
</td>
</tr>
<tr>
<th>
3
</th>
<td>
d
</td>
<td>
Z
</td>
<td>
T
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<h3 id="索引的变形">4. 索引的变形</h3>
<p>在某些场合下，需要对索引做一些扩充或者剔除，更具体地要求是给定一个新的索引，把原表中相应的索引对应元素填充到新索引构成的表中。例如，下面的表中给出了员工信息，需要重新制作一张新的表，要求增加一名员工的同时去掉身高列并增加性别列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_reindex = pd.DataFrame(&#123;<span class="hljs-string">&quot;Weight&quot;</span>:[<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>], <span class="hljs-string">&quot;Height&quot;</span>:[<span class="hljs-number">176</span>,<span class="hljs-number">180</span>,<span class="hljs-number">179</span>]&#125;, index=[<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;1003&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>])<br>df_reindex<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Weight
</th>
<th>
Height
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
1001
</th>
<td>
60
</td>
<td>
176
</td>
</tr>
<tr>
<th>
1003
</th>
<td>
70
</td>
<td>
180
</td>
</tr>
<tr>
<th>
1002
</th>
<td>
80
</td>
<td>
179
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_reindex.reindex(index=[<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>,<span class="hljs-string">&#x27;1003&#x27;</span>,<span class="hljs-string">&#x27;1004&#x27;</span>], columns=[<span class="hljs-string">&#x27;Weight&#x27;</span>,<span class="hljs-string">&#x27;Gender&#x27;</span>])<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Weight
</th>
<th>
Gender
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
1001
</th>
<td>
60.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1002
</th>
<td>
80.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1003
</th>
<td>
70.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1004
</th>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
</tbody>
</table>
</div>
<p>这种需求常出现在时间序列索引的时间点填充以及<code>ID</code>编号的扩充。另外，需要注意的是原来表中的数据和新表中会根据索引自动对齐，例如原先的1002号位置在1003号之后，而新表中相反，那么<code>reindex</code>中会根据元素对齐，与位置无关。</p>
<p>还有一个与<code>reindex</code>功能类似的函数是<code>reindex_like</code>，其功能是仿照传入的表索引来进行被调用表索引的变形。例如，现在已经存在一张表具备了目标索引的条件，那么上述功能可采用下述代码得到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_existed = pd.DataFrame(index=[<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>,<span class="hljs-string">&#x27;1003&#x27;</span>,<span class="hljs-string">&#x27;1004&#x27;</span>], columns=[<span class="hljs-string">&#x27;Weight&#x27;</span>,<span class="hljs-string">&#x27;Gender&#x27;</span>])<br>df_reindex.reindex_like(df_existed)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Weight
</th>
<th>
Gender
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
1001
</th>
<td>
60.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1002
</th>
<td>
80.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1003
</th>
<td>
70.0
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1004
</th>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
</tbody>
</table>
</div>
<h2 id="四索引运算">四、索引运算</h2>
<h3 id="集合的运算法则">1. 集合的运算法则</h3>
<p>经常会有一种利用集合运算来取出符合条件行的需求，例如有两张表<code>A</code>和<code>B</code>，它们的索引都是员工编号，现在需要筛选出两表索引交集的所有员工信息，此时通过<code>Index</code>上的运算操作就很容易实现。</p>
<p>不过在此之前，不妨先复习一下常见的四种集合运算：</p>
<p><span class="math display">\[\rm S_A.intersection(S_B) = \rm S_A \cap
S_B \Leftrightarrow \rm \{x|x\in S_A\, and\, x\in S_B\}\]</span> <span
class="math display">\[\rm S_A.union(S_B) = \rm S_A \cup S_B
\Leftrightarrow \rm \{x|x\in S_A\, or\, x\in S_B\}\]</span> <span
class="math display">\[\rm S_A.difference(S_B) = \rm S_A - S_B
\Leftrightarrow \rm \{x|x\in S_A\, and\, x\notin S_B\}\]</span> <span
class="math display">\[\rm S_A.symmetric\_difference(S_B) = \rm
S_A\triangle S_B\Leftrightarrow \rm \{x|x\in S_A\cup S_B - S_A\cap
S_B\}\]</span></p>
<h3 id="一般的索引运算">2. 一般的索引运算</h3>
<p>由于集合的元素是互异的，但是索引中可能有相同的元素，先用<code>unique</code>去重后再进行运算。下面构造两张最为简单的示例表进行演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df_set_1 = pd.DataFrame([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]], index = pd.Index([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>],name=<span class="hljs-string">&#x27;id1&#x27;</span>))<br>df_set_2 = pd.DataFrame([[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">1</span>]], index = pd.Index([<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>],name=<span class="hljs-string">&#x27;id2&#x27;</span>))<br>id1, id2 = df_set_1.index.unique(), df_set_2.index.unique()<br>id1.intersection(id2)<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">Index([&#39;b&#39;], dtype=&#39;object&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id1.union(id2)<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id1.difference(id2)<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">Index([&#39;a&#39;], dtype=&#39;object&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id1.symmetric_difference(id2)<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">Index([&#39;a&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</code></pre>
<p>若两张表需要做集合运算的列并没有被设置索引，一种办法是先转成索引，运算后再恢复，另一种方法是利用<code>isin</code>函数，例如在重置索引的第一张表中选出id列交集的所在行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df_set_in_col_1 = df_set_1.reset_index()<br>df_set_in_col_2 = df_set_2.reset_index()<br>df_set_in_col_1<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
id1
</th>
<th>
0
</th>
<th>
1
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
a
</td>
<td>
0
</td>
<td>
1
</td>
</tr>
<tr>
<th>
1
</th>
<td>
b
</td>
<td>
1
</td>
<td>
2
</td>
</tr>
<tr>
<th>
2
</th>
<td>
a
</td>
<td>
3
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_set_in_col_2<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
id2
</th>
<th>
0
</th>
<th>
1
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
b
</td>
<td>
4
</td>
<td>
5
</td>
</tr>
<tr>
<th>
1
</th>
<td>
b
</td>
<td>
2
</td>
<td>
6
</td>
</tr>
<tr>
<th>
2
</th>
<td>
c
</td>
<td>
7
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_set_in_col_1[df_set_in_col_1.id1.isin(df_set_in_col_2.id2)]<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
id1
</th>
<th>
0
</th>
<th>
1
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
1
</th>
<td>
b
</td>
<td>
1
</td>
<td>
2
</td>
</tr>
</tbody>
</table>
</div>
<h2 id="五练习">五、练习</h2>
<h3 id="ex1公司员工数据集">Ex1：公司员工数据集</h3>
<p>现有一份公司员工数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/company.csv&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
EmployeeID
</th>
<th>
birthdate_key
</th>
<th>
age
</th>
<th>
city_name
</th>
<th>
department
</th>
<th>
job_title
</th>
<th>
gender
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
1318
</td>
<td>
1/3/1954
</td>
<td>
61
</td>
<td>
Vancouver
</td>
<td>
Executive
</td>
<td>
CEO
</td>
<td>
M
</td>
</tr>
<tr>
<th>
1
</th>
<td>
1319
</td>
<td>
1/3/1957
</td>
<td>
58
</td>
<td>
Vancouver
</td>
<td>
Executive
</td>
<td>
VP Stores
</td>
<td>
F
</td>
</tr>
<tr>
<th>
2
</th>
<td>
1320
</td>
<td>
1/2/1955
</td>
<td>
60
</td>
<td>
Vancouver
</td>
<td>
Executive
</td>
<td>
Legal Counsel
</td>
<td>
F
</td>
</tr>
</tbody>
</table>
</div>
<ol type="1">
<li>分别只使用<code>query</code>和<code>loc</code>选出年龄不超过四十岁且工作部门为<code>Dairy</code>或<code>Bakery</code>的男性。</li>
<li>选出员工<code>ID</code>号 为奇数所在行的第1、第3和倒数第2列。</li>
<li>按照以下步骤进行索引操作：</li>
</ol>
<ul>
<li>把后三列设为索引后交换内外两层</li>
<li>恢复中间层索引</li>
<li>修改外层索引名为<code>Gender</code></li>
<li>用下划线合并两层行索引</li>
<li>把行索引拆分为原状态</li>
<li>修改索引名为原表名称</li>
<li>恢复默认索引并将列保持为原表的相对位置</li>
</ul>
<h3 id="ex2巧克力数据集">Ex2：巧克力数据集</h3>
<p>现有一份关于巧克力评价的数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/chocolate.csv&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Company
</th>
<th>
Review
</th>
<th>
Cocoa
</th>
<th>
Company
</th>
<th>
Rating
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
A. Morin
</td>
<td>
2016
</td>
<td>
63%
</td>
<td>
France
</td>
<td>
3.75
</td>
</tr>
<tr>
<th>
1
</th>
<td>
A. Morin
</td>
<td>
2015
</td>
<td>
70%
</td>
<td>
France
</td>
<td>
2.75
</td>
</tr>
<tr>
<th>
2
</th>
<td>
A. Morin
</td>
<td>
2015
</td>
<td>
70%
</td>
<td>
France
</td>
<td>
3.00
</td>
</tr>
</tbody>
</table>
</div>
<ol type="1">
<li>把列索引名中的<code>\n</code>替换为空格。</li>
<li>巧克力<code>Rating</code>评分为1至5，每0.25分一档，请选出2.75分及以下且可可含量<code>Cocoa Percent</code>高于中位数的样本。</li>
<li>将<code>Review Date</code>和<code>Company Location</code>设为索引后，选出<code>Review Date</code>在2012年之后且<code>Company Location</code>不属于<code>France, Canada, Amsterdam, Belgium</code>的样本。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Machine-Learning/" class="category-chain-item">Machine Learning</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Pandas/" class="print-no-link">#Pandas</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Pandas索引</div>
      <div>http://jingmengzhiyue.top/2023/10/01/第三章 索引/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jingmengzhiyue</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/01/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE/" title="Pandas分类数据">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Pandas分类数据</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/01/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20pandas%E5%9F%BA%E7%A1%80/" title="Pandas基础">
                        <span class="hidden-mobile">Pandas基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"eZ6fNr2wGbxSreDqCc24Ik6y-gzGzoHsz","appKey":"I1HMoNZO5iKmmCSzqE0wTpGr","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 18954 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 9873 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
