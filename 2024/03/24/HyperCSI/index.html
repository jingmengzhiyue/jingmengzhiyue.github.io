

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jingmengzhiyue">
  <meta name="keywords" content="">
  
    <meta name="description" content="高光谱遥感技术是识别目标区域内端元成分及其比例的关键技术,在地物分类、环境监测等领域有广泛应用。高光谱图像解混(Hyperspectral Unmixing, HU)就是分析高光谱数据,识别图像中的端元(endmembers)及其对应的丰度(abundances)的信号处理过程。其中Craig的最小体积外接单纯形准则是一种经典有效的盲解混方法,即将包围数据点云的最小体积单纯形的顶点视为端元估计">
<meta property="og:type" content="article">
<meta property="og:title" content="基于最小体积单纯形的快速高光谱图像解混算法">
<meta property="og:url" content="http://jingmengzhiyue.top/2024/03/24/HyperCSI/index.html">
<meta property="og:site_name" content="热爱可抵万难">
<meta property="og:description" content="高光谱遥感技术是识别目标区域内端元成分及其比例的关键技术,在地物分类、环境监测等领域有广泛应用。高光谱图像解混(Hyperspectral Unmixing, HU)就是分析高光谱数据,识别图像中的端元(endmembers)及其对应的丰度(abundances)的信号处理过程。其中Craig的最小体积外接单纯形准则是一种经典有效的盲解混方法,即将包围数据点云的最小体积单纯形的顶点视为端元估计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jingmengzhiyue.top/img/image.png">
<meta property="og:image" content="http://jingmengzhiyue.top/img/image1.png">
<meta property="article:published_time" content="2024-03-24T03:37:14.000Z">
<meta property="article:modified_time" content="2024-03-24T04:14:07.059Z">
<meta property="article:author" content="Jingmengzhiyue">
<meta property="article:tag" content="HyperCSI">
<meta property="article:tag" content="Hyperspectral unmixing">
<meta property="article:tag" content="Remote Sensing">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://jingmengzhiyue.top/img/image.png">
  
  
  
  <title>基于最小体积单纯形的快速高光谱图像解混算法 - 热爱可抵万难</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jingmengzhiyue.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"eZ6fNr2wGbxSreDqCc24Ik6y-gzGzoHsz","app_key":"I1HMoNZO5iKmmCSzqE0wTpGr","server_url":"https://ez6fnr2w.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
  
    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>
   


<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>热爱可抵万难</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://t.mwm.moe/fj/') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="基于最小体积单纯形的快速高光谱图像解混算法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-24 11:37" pubdate>
          2024年3月24日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          130 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">基于最小体积单纯形的快速高光谱图像解混算法</h1>
            
            
              <div class="markdown-body">
                
                <p>高光谱遥感技术是识别目标区域内端元成分及其比例的关键技术,在地物分类、环境监测等领域有广泛应用。高光谱图像解混(Hyperspectral
Unmixing,
HU)就是分析高光谱数据,识别图像中的端元(endmembers)及其对应的丰度(abundances)的信号处理过程。其中Craig的最小体积外接单纯形准则是一种经典有效的盲解混方法,即将包围数据点云的最小体积单纯形的顶点视为端元估计。但相关算法由于涉及复杂的体积计算而计算效率低下。但是HyperCSI(Hyperplane-based
Craig-Simplex
Identification)算法不需要计算复杂的体积函数,而是利用一个几何定理:一个N维单纯形可以由N个超平面(N-2维)确定。HyperCSI算法通过构造N个与Craig最小外接单纯形相关的超平面,来重构该最小外接单纯形。这样做不仅避免了体积计算,而且在计算复杂度上也大大优于Craig准则算法。</p>
<h2 id="算法原理">算法原理</h2>
<h3 id="假设和符号定义">1. 假设和符号定义</h3>
<p>设观测数据为 <span class="math inline">\(\{x[1],\dots,x[L]\} \subset
\mathbb{R}^M\)</span>, 其中每个 <span class="math inline">\(x[n] \in
\mathbb{R}^M\)</span> 是图像中的一个像素向量,含有M个光谱波段的值。数据
<span class="math inline">\(x[n]\)</span> 被假设由 <span
class="math inline">\(N\)</span> 个端元 <span
class="math inline">\(\{a_1,\dots,a_N\}\subset \mathbb{R}^M\)</span>
线性组合而成,其丰度向量 <span class="math inline">\(s[n] =
[s_1[n],\dots,s_N[n]]^T \in \mathbb{R}^N\)</span>
满足非负性约束和相加为1。即:</p>
<p><span class="math display">\[x[n] = \sum_{i=1}^N s_i[n] a_i + w[n],
\quad \forall n \in \{1,\dots,L\}\]</span></p>
<p>其中 <span class="math inline">\(w[n]\)</span> 是加性噪声。令 <span
class="math inline">\(\alpha_i = C^\dagger (a_i-d) \in
\mathbb{R}^{N-1}\)</span> 是低维表示(dimension reduction,
DR)后的端元向量,其中 <span class="math inline">\(C\in\mathbb{R}^{M
\times (N-1)}\)</span>
是数据矩阵的前N-1个主成分对应的特征向量组成的矩阵, <span
class="math inline">\(d=\frac{1}{L}\sum_{n=1}^L x[n]\)</span>
是数据均值。则可以得到DR后的数据:</p>
<p><span class="math display">\[\tilde{x}[n] = C^\dagger (x[n] - d) =
\sum_{i=1}^N s_i[n]\alpha_i \in \mathbb{R}^{N-1}\]</span></p>
<h3 id="超平面表示craig最小外接单纯形">2.
超平面表示Craig最小外接单纯形</h3>
<p><img src="/img/image.png" srcset="/img/loading.gif" lazyload alt="alt text" /> 设 Craig
的最小外接单纯形为 <span class="math inline">\(\mathcal{T} =
\mathrm{conv}\{\alpha_1,\dots,\alpha_N\} \subset
\mathbb{R}^{N-1}\)</span>。根据以下命题,这个单纯形可以由 <span
class="math inline">\(N\)</span> 个与之相关的超平面 <span
class="math inline">\(H_1,\dots,H_N\)</span> 确定:</p>
<p><strong>命题1</strong> 如果 <span
class="math inline">\(\{\alpha_1,\dots,\alpha_N\}\subset\mathbb{R}^{N-1}\)</span>
是仿射独立的(即 <span class="math inline">\(\mathcal{T}\)</span>
是一个单纯形),那么 <span class="math inline">\(\mathcal{T}\)</span>
可以由 <span class="math inline">\(N\)</span> 个紧密包围 <span
class="math inline">\(\mathcal{T}\)</span> 的超平面 <span
class="math inline">\(\{H_1,\dots,H_N\}\)</span> 重构, 其中 <span
class="math inline">\(H_i =
\text{aff}(\{\alpha_1,\dots,\alpha_N\}\backslash\{\alpha_i\})\)</span>。</p>
<p>证明思路:只需证明 <span
class="math inline">\(\{\alpha_1,\dots,\alpha_N\}\)</span> 可以由 <span
class="math inline">\(\{H_1,\dots,H_N\}\)</span> 确定即可。证明略。</p>
<p>所以 HyperCSI 算法的关键是估计这 <span
class="math inline">\(N\)</span> 个超平面,从而得到 Craig
最小外接单纯形,进而得到端元估计。 <img src="/img/image1.png" srcset="/img/loading.gif" lazyload
alt="alt text" /> ### 3. 超平面法向量估计</p>
<p>现考虑如何估计第 i 个超平面 <span class="math inline">\(H_i(b_i,h_i)
= \{x\in\mathbb{R}^{N-1} \ \vert \ b_i^T x = h_i\}\)</span> 的法向量
<span class="math inline">\(b_i\)</span> 和常数 <span
class="math inline">\(h_i\)</span>。</p>
<p>根据以下命题,只要能找到 <span class="math inline">\(H_i\)</span> 上的
<span class="math inline">\(N-1\)</span> 个仿射独立点,即可确定 <span
class="math inline">\(b_i\)</span>。</p>
<p><strong>命题2</strong> 给定任意 <span
class="math inline">\(N-1\)</span> 个 <span
class="math inline">\(H_i\)</span> 上的仿射独立点集 <span
class="math inline">\(\{p_1^{(i)},\dots,p_{N-1}^{(i)}\}\subset
H_i\)</span>,则有(除去一个正比例因子):</p>
<p><span class="math display">\[b_i = v_i (p_1^{(i)}, \dots,
p_{N-1}^{(i)})\]</span></p>
<p>其中</p>
<p><span class="math display">\[v_i(p_1, \dots, p_{N-1}) = (I_{N-1} -
P(P^TP)^{-1}P^T)(p_j - p_i), \quad \forall j\neq i\]</span></p>
<p><span class="math inline">\(P = [\alpha_1 \cdots \alpha_i \cdots
\alpha_j \cdots \alpha_N] - \alpha_j \cdot 1_{N-2}^T\)</span>。</p>
<p>接下来我们将从原始数据 <span class="math inline">\(X =
\{\tilde{x}[1], \dots, \tilde{x}[L]\}\)</span> 中寻找 <span
class="math inline">\(H_i\)</span> 上的 <span
class="math inline">\(N-1\)</span> 个"最近"点集 <span
class="math inline">\(P_i\)</span>。具体做法是:</p>
<ol type="1">
<li><p>首先利用 SPA 算法从 <span class="math inline">\(X\)</span>
中提取出 <span class="math inline">\(N\)</span> 个最"纯净"的像素 <span
class="math inline">\(\{\tilde{\alpha}_1, \dots,
\tilde{\alpha}_N\}\)</span> (可视为离 <span
class="math inline">\(\alpha_1, \dots, \alpha_N\)</span>
最近的像素)</p></li>
<li><p>计算超平面 <span class="math inline">\(\tilde{H}_i =
\text{aff}(\{\tilde{\alpha}_1, \dots,
\tilde{\alpha}_N\}\backslash\{\tilde{\alpha}_i\})\)</span> 的法向量
<span class="math inline">\(\tilde{b}_i\)</span></p></li>
<li><p>将数据集 <span class="math inline">\(X\)</span> 划分为 <span
class="math inline">\(N-1\)</span> 个不相交区域 <span
class="math inline">\(R_1^{(i)},\dots,R_{N-1}^{(i)}\)</span>,每个区域以一个
<span class="math inline">\(\tilde{\alpha}_j\)</span> 为中心</p></li>
<li><p>在每个区域内寻找离 <span
class="math inline">\(\tilde{H}_i\)</span> 最近的一个点,即求解:</p></li>
</ol>
<p><span class="math display">\[p_k^{(i)} \in \arg\max\{\tilde{b}_i^T p
\mid p \in X \cap R_k^{(i)}\}, \quad \forall
k\in\{1,\dots,N-1\}\]</span></p>
<p>令所得点集为 <span class="math inline">\(P_i = \{p_1^{(i)}, \dots,
p_{N-1}^{(i)}\}\)</span>。</p>
<ol start="5" type="1">
<li>根据命题2,计算HyperCSI算法中第i个超平面的法向量估计:</li>
</ol>
<p><span class="math display">\[\hat{b}_i = v_i(p_1^{(i)}, \dots,
p_{N-1}^{(i)})\]</span></p>
<h3 id="超平面内积常数估计">4. 超平面内积常数估计</h3>
<p>上述方法可以得到Craig最小外接单纯形的 <span
class="math inline">\(N\)</span> 个超平面的法向量估计 <span
class="math inline">\(\{\hat{b}_1,\dots,\hat{b}_N\}\)</span>。为了完整确定这些超平面,我们还需要估计对应的内积常数
<span class="math inline">\(\hat{h}_i\)</span>。考虑以下引理:</p>
<p><strong>引理1</strong></p>
<ol type="i">
<li><p>对于所有的 <span class="math inline">\(p\in X\)</span>,有 <span
class="math inline">\(b_i^Tp \leq
h_i\)</span>(即所有数据点都在同一侧)。</p></li>
<li><p>点 <span class="math inline">\(p\in X\)</span> 到 <span
class="math inline">\(H_i\)</span> 的距离为 <span
class="math inline">\(\text{dist}(p,H_i) = |h_i - b_i^Tp| /
\|b_i\|\)</span>。</p></li>
<li><p>当且仅当 <span class="math inline">\(b_i\)</span>
由内向外指向Craig最小外接单纯形时,点到平面距离最大值对应的点 <span
class="math inline">\(\hat{p} = \arg\max\{b_i^Tp\mid p\in X\}\)</span>
为离 <span class="math inline">\(H_i\)</span> 最近的点。</p></li>
</ol>
<p>所以很自然可以取</p>
<p><span class="math display">\[\hat{h}_i = \max\{\hat{b}_i^T p \mid p
\in X\}\]</span></p>
<p>为对应的内积常数估计。</p>
<p>在存在噪声的情况下,由于噪声可能使数据中的端元种类膨胀,导致Craig最小外接单纯形体积增大,估计超平面被推离数据均值(DR空间中的原点)。为了缓解这种效果,我们对估计超平面进行适当内移,令</p>
<p><span class="math display">\[\hat{H}_i = \{\hat{b}_i^Tx =
\hat{h}_i/c\}, \quad c \geq 1\]</span></p>
<p>其中 <span class="math inline">\(c\)</span> 是一个内移因子,取值为</p>
<p><span class="math display">\[c = \max\{1, \max\{-v_{ij}/d_j \mid
i\in\{1,\dots,N\}, j\in\{1,\dots,M\}\}\} / \eta\]</span></p>
<p>这里 <span class="math inline">\(\eta \in (0,1]\)</span>
是一个预设参数(典型取0.9), <span class="math inline">\(v_{ij}\)</span>
是 <span class="math inline">\(C(\hat{B}_{-i}^{-1}\hat{h}_{-i})\)</span>
的第j个元素, <span class="math inline">\(d_j\)</span> 是数据均值 <span
class="math inline">\(d\)</span> 的第j个元素, <span
class="math inline">\(\hat{B}_{-i}\)</span> 和 <span
class="math inline">\(\hat{h}_{-i}\)</span> 分别由向量 <span
class="math inline">\(\{\hat{b}_j,\hat{h}_j\}_{j\neq i}\)</span>
确定。这样做可以确保估计端元特征为非负。</p>
<p>最终,经过内移后的端元估计为:</p>
<p><span class="math display">\[\hat{\alpha}_i =
\hat{B}_{-i}^{-1}\frac{\hat{h}_{-i}}{c}, \quad \hat{a}_i =
C\hat{\alpha}_i + d, \quad \forall i\in\{1,\dots,N\}\]</span></p>
<h3 id="丰度估计">5. 丰度估计</h3>
<p>尽管丰度通常通过求解完全受约束最小二乘(FCLS)问题估计,但由于Craig准则提供的一些几何量,实际可以利用如下解析形式表达式快速估计丰度:</p>
<p><span class="math display">\[\hat{s}_i[n] = \left(\frac{\hat{h}_i -
\hat{b}_i^T\tilde{x}[n]}{\hat{h}_i -
\hat{b}_i^T\hat{\alpha}_i}\right)_+, \quad \forall i\in\{1,\dots,N\}, \,
\forall n\in\{1,\dots,L\}\]</span></p>
<p>其中 <span class="math inline">\((y)_+ = \max\{y,0\}\)</span>
用于约束丰度非负。当像素 <span
class="math inline">\(\tilde{x}[n]\)</span>
位于估计端元外接单纯形内时,该估计就等价于求解FCLS问题所得结果。但当像素偏离估计单纯形较远时,可能会产生一定偏差。不过对于高信噪比的高光谱数据,大部分像素都会落在估计单纯形附近,利用上述快速丰度估计是合理的。</p>
<h2 id="算法特点总结">算法特点总结</h2>
<ul>
<li><p>HyperCSI算法通过构造Craig最小外接单纯形的关联超平面,避免了复杂的体积计算,从而实现了高效的Craig准则求解。</p></li>
<li><p>它只需找到 <span class="math inline">\(N(N-1)\)</span>
个像素(与数据长度无关)即可重构Craig最小外接单纯形的 <span
class="math inline">\(N\)</span> 个超平面。</p></li>
<li><p>理论证明了在无噪声和足够多像素的条件下,HyperCSI算法可以完全识别出真实端元和Craig最小外接单纯形。</p></li>
<li><p>丰度估计采用封闭形式快速计算。</p></li>
<li><p>整体计算复杂度为 <span
class="math inline">\(\mathcal{O}(N^2L)\)</span>,与一些基于纯像素的经典算法复杂度相当。</p></li>
</ul>
<p>总之,HyperCSI算法是一种新颖高效的Craig准则求解方法,在避免复杂体积计算的同时,保留了传统算法的优良性能。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="matlab实现">MATLAB实现</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 参考文献:</span><br><span class="hljs-comment">% C.-H. Lin, C.-Y. Chi, Y.-H. Wang, and T.-H. Chan,</span><br><span class="hljs-comment">% ``A fast hyperplane-based minimum-volume enclosing simplex algorithm for blind hyperspectral unmixing,&quot;</span><br><span class="hljs-comment">% arXiv preprint arXiv:1510.08917, 2015.</span><br><span class="hljs-comment">%======================================================================</span><br><span class="hljs-comment">% 超平面基于Craig-Simplex-识别算法的快速实现</span><br><span class="hljs-comment">% [A_est, S_est, time] = HyperCSI(X,N)</span><br><span class="hljs-comment">%======================================================================</span><br><span class="hljs-comment">%  输入</span><br><span class="hljs-comment">%  X是M-by-L数据矩阵,其中M是光谱波段数,L是像素数</span><br><span class="hljs-comment">%  N是端元数量</span><br><span class="hljs-comment">%----------------------------------------------------------------------</span><br><span class="hljs-comment">%  输出</span><br><span class="hljs-comment">%  A_est是M-by-N混合矩阵,其列是估计的端元签名</span><br><span class="hljs-comment">%  S_est是N-by-L源矩阵,其行是估计的丰度图</span><br><span class="hljs-comment">%  time是计算时间(以秒为单位)</span><br><span class="hljs-comment">%========================================================================</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[A_est, S_est, time]</span> = <span class="hljs-title">HyperCSI</span><span class="hljs-params">(X,N)</span></span><br>t0 = clock; <span class="hljs-comment">% 获取当前时间</span><br><br><span class="hljs-comment">%------------------------ 步骤1 ------------------------</span><br>[M L ] = <span class="hljs-built_in">size</span>(X); <span class="hljs-comment">% 获取X的尺寸</span><br>d = <span class="hljs-built_in">mean</span>(X,<span class="hljs-number">2</span>); <span class="hljs-comment">% 计算均值向量</span><br>U = X-d*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,L); <span class="hljs-comment">% 均值中心化</span><br>[eV D] = eig(U*U&#x27;); <span class="hljs-comment">% 计算特征值和特征向量</span><br>C = eV(:,M-N+<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>); <span class="hljs-comment">% 提取前N-1个主成分</span><br>Xd = C&#x27;*(X-d*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,L)); <span class="hljs-comment">% 维度缩减数据(Xd是(N-1)-by-L)</span><br><br><span class="hljs-comment">%------------------------ 步骤2 ------------------------</span><br>alpha_tilde = SPA(Xd,L,N); <span class="hljs-comment">% 确定最纯像素</span><br><br><span class="hljs-comment">%------------------------ 步骤3 ------------------------</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:N<br>    bi_tilde(:,<span class="hljs-built_in">i</span>) = compute_bi(alpha_tilde,<span class="hljs-built_in">i</span>,N); <span class="hljs-comment">% 获得bi_tilde</span><br><span class="hljs-keyword">end</span><br><br>r = (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)*norm(alpha_tilde(:,<span class="hljs-number">1</span>)-alpha_tilde(:,<span class="hljs-number">2</span>)); <span class="hljs-comment">% 初始化超球半径</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:N<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>:N<br>        dist_ai_aj(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>) = norm(alpha_tilde(:,<span class="hljs-built_in">i</span>)-alpha_tilde(:,<span class="hljs-built_in">j</span>));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)*dist_ai_aj(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>) &lt; r<br>            r = (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)*dist_ai_aj(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>); <span class="hljs-comment">% 计算超球半径</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>Xd_divided_idx = <span class="hljs-built_in">zeros</span>(L,<span class="hljs-number">1</span>); <span class="hljs-comment">% 初始化标记数组</span><br>radius_square = r^<span class="hljs-number">2</span>; <span class="hljs-comment">% 半径的平方</span><br><span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:N<br>    [IDX_alpha_i_tilde]= <span class="hljs-built_in">find</span>( sum(  (Xd- alpha_tilde(:,k)*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,L) ).^<span class="hljs-number">2</span>,<span class="hljs-number">1</span>  )  &lt; radius_square );<br>    Xd_divided_idx(IDX_alpha_i_tilde) = k ; <span class="hljs-comment">% 计算超球</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%------------------------ 步骤4 ------------------------</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:N<br>    Hi_idx = setdiff([<span class="hljs-number">1</span>:N],[<span class="hljs-built_in">i</span>]); <span class="hljs-comment">% 除去第i个端元</span><br>    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-number">1</span>*(N<span class="hljs-number">-1</span>)<br>        Ri_k = Xd(:,( Xd_divided_idx == Hi_idx(k) )); <span class="hljs-comment">% 选择属于第k个超球的数据</span><br>        [val idx] = <span class="hljs-built_in">max</span>(bi_tilde(:,<span class="hljs-built_in">i</span>)&#x27;*Ri_k); <span class="hljs-comment">% 找到与bi_tilde(:,i)投影最大的点</span><br>        pi_k(:,k) = Ri_k(:,idx); <span class="hljs-comment">% 记录这些点作为超平面上的N-1个仿射独立点</span><br>    <span class="hljs-keyword">end</span><br>    b_hat(:,<span class="hljs-built_in">i</span>) = compute_bi([pi_k alpha_tilde(:,<span class="hljs-built_in">i</span>)],N,N); <span class="hljs-comment">% 计算b_hat(:,i)</span><br>    h_hat(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>) = <span class="hljs-built_in">max</span>(b_hat(:,<span class="hljs-built_in">i</span>)&#x27;*Xd); <span class="hljs-comment">% 计算h_hat(i,1)</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%------------------------ 步骤5&amp;步骤6 ------------------------</span><br>comm_flag = <span class="hljs-number">1</span>; <span class="hljs-comment">% comm_flag = 1表示有噪声,需要将超平面向数据云中心移动</span><br><span class="hljs-comment">% comm_flag = 0表示无噪声,不需要执行步骤5(因此c = 1)</span><br><br>eta = <span class="hljs-number">0.9</span>; <span class="hljs-comment">% 0.9是经验上的良好选择,用于USGS库中的端元</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:N<br>    bbbb = b_hat;<br>    ccconst = h_hat;<br>    bbbb(:,<span class="hljs-built_in">i</span>) = []; <span class="hljs-comment">% 除去第i列</span><br>    ccconst(<span class="hljs-built_in">i</span>) = []; <span class="hljs-comment">% 除去第i个元素</span><br>    alpha_hat(:,<span class="hljs-built_in">i</span>) = pinv(bbbb&#x27;)*ccconst; <span class="hljs-comment">% 计算alpha_hat(:,i)</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> comm_flag == <span class="hljs-number">1</span><br>    VV = C*alpha_hat; <span class="hljs-comment">% 将alpha_hat投影到原始维度</span><br>    UU = d*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,N); <span class="hljs-comment">% 构造均值向量</span><br>    closed_form_optval = <span class="hljs-built_in">max</span>( <span class="hljs-number">1</span> , <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>( (-VV) ./ UU)) ); <span class="hljs-comment">% 计算c&#x27;</span><br>    c = closed_form_optval/eta; <span class="hljs-comment">% 计算c</span><br>    h_hat = h_hat/c; <span class="hljs-comment">% 更新h_hat</span><br>    alpha_hat = alpha_hat/c; <span class="hljs-comment">% 更新alpha_hat</span><br><span class="hljs-keyword">end</span><br>A_est = C * alpha_hat + d * <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,N); <span class="hljs-comment">% 端元估计</span><br><br><span class="hljs-comment">%------------------------ 步骤7 ------------------------</span><br><span class="hljs-comment">% 步骤7可以被删除,如果用户不需要丰度估计</span><br>S_est = ( h_hat*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,L)- b_hat&#x27;*Xd   ) ./ ( (  h_hat - sum( b_hat.*alpha_hat )&#x27; ) *<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,L) );<br>S_est(S_est&lt;<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>; <span class="hljs-comment">% 非负约束</span><br><span class="hljs-comment">% end</span><br><br>time = etime(clock,t0); <span class="hljs-comment">% 计算运行时间</span><br><br><br><span class="hljs-comment">%% 子程序1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[bi]</span> = <span class="hljs-title">compute_bi</span><span class="hljs-params">(a0,i,N)</span></span><br>Hindx = setdiff([<span class="hljs-number">1</span>:N],[<span class="hljs-built_in">i</span>]); <span class="hljs-comment">% 除去第i个端元</span><br>A_Hindx = a0(:,Hindx); <span class="hljs-comment">% 选择其他端元</span><br>A_tilde_i = A_Hindx(:,<span class="hljs-number">1</span>:N<span class="hljs-number">-2</span>)-A_Hindx(:,N<span class="hljs-number">-1</span>)*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,N<span class="hljs-number">-2</span>); <span class="hljs-comment">% 计算A_tilde_i</span><br>bi = A_Hindx(:,N<span class="hljs-number">-1</span>)-a0(:,<span class="hljs-built_in">i</span>); <span class="hljs-comment">% 计算bi</span><br>bi = (<span class="hljs-built_in">eye</span>(N<span class="hljs-number">-1</span>) - A_tilde_i*(pinv(A_tilde_i&#x27;*A_tilde_i))*A_tilde_i&#x27;)*bi; <span class="hljs-comment">% 投影bi到null(A_tilde_i)</span><br>bi = bi/norm(bi); <span class="hljs-comment">% 归一化</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">% end</span><br><br><br><span class="hljs-comment">%% 子程序2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[alpha_tilde]</span> = <span class="hljs-title">SPA</span><span class="hljs-params">(Xd,L,N)</span></span><br><br><span class="hljs-comment">% 参考文献:</span><br><span class="hljs-comment">% [1] W.-K. Ma, J. M. Bioucas-Dias, T.-H. Chan, N. Gillis, P. Gader, A. J. Plaza, A. Ambikapathi, and C.-Y. Chi, </span><br><span class="hljs-comment">% ``A signal processing perspective on hyperspectral unmixing,�� </span><br><span class="hljs-comment">% IEEE Signal Process. Mag., vol. 31, no. 1, pp. 67�V81, 2014.</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% [2] S. Arora, R. Ge, Y. Halpern, D. Mimno, A. Moitra, D. Sontag, Y. Wu, and M. Zhu, </span><br><span class="hljs-comment">% ``A practical algorithm for topic modeling with provable guarantees,�� </span><br><span class="hljs-comment">% arXiv preprint arXiv:1212.4777, 2012.</span><br><span class="hljs-comment">%======================================================================</span><br><span class="hljs-comment">% 连续投影算法(SPA)的实现</span><br><span class="hljs-comment">% [alpha_tilde] = SPA(Xd,L,N)</span><br><span class="hljs-comment">%======================================================================</span><br><span class="hljs-comment">%  输入</span><br><span class="hljs-comment">%  Xd是降维后的数据矩阵</span><br><span class="hljs-comment">%  L是像素数</span><br><span class="hljs-comment">%  N是端元数量</span><br><span class="hljs-comment">%----------------------------------------------------------------------</span><br><span class="hljs-comment">%  输出</span><br><span class="hljs-comment">%  alpha_tilde是(N-1)-by-N矩阵,其列是降维后的最纯像素</span><br><span class="hljs-comment">%======================================================================</span><br><span class="hljs-comment">%======================================================================</span><br><br><span class="hljs-comment">%----------- 定义默认参数------------------</span><br>con_tol = <span class="hljs-number">1e-8</span>; <span class="hljs-comment">% SPA收敛容差</span><br>num_SPA_itr = N; <span class="hljs-comment">% SPA后处理迭代次数</span><br>N_max = N; <span class="hljs-comment">% 最大迭代次数</span><br><br><span class="hljs-comment">%------------------------ SPA初始化 ------------------------</span><br>A_set=[]; Xd_t = [Xd; <span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,L)]; index = []; <span class="hljs-comment">% 初始化</span><br>[val ind] = <span class="hljs-built_in">max</span>(sum( Xd_t.^<span class="hljs-number">2</span> )); <span class="hljs-comment">% 找到最大投影和的点</span><br>A_set = [A_set Xd_t(:,ind)]; <span class="hljs-comment">% 将该点加入A_set</span><br>index = [index ind]; <span class="hljs-comment">% 记录索引</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">2</span>:N<br>    XX = (<span class="hljs-built_in">eye</span>(N_max) - A_set * pinv(A_set)) * Xd_t; <span class="hljs-comment">% 投影到A_set的补空间</span><br>    [val ind] = <span class="hljs-built_in">max</span>(sum( XX.^<span class="hljs-number">2</span> )); <span class="hljs-comment">% 找到最大投影和的点</span><br>    A_set = [A_set Xd_t(:,ind)]; <span class="hljs-comment">% 将该点加入A_set</span><br>    index = [index ind]; <span class="hljs-comment">% 记录索引</span><br><span class="hljs-keyword">end</span><br>alpha_tilde = Xd(:,index); <span class="hljs-comment">% 初始最纯像素估计</span><br><br><span class="hljs-comment">%------------------------ SPA后处理 ------------------------</span><br>current_vol = det( alpha_tilde(:,<span class="hljs-number">1</span>:N<span class="hljs-number">-1</span>) - alpha_tilde(:,N)*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,N<span class="hljs-number">-1</span>) ); <span class="hljs-comment">% 计算初始体积</span><br><span class="hljs-keyword">for</span> jjj = <span class="hljs-number">1</span>:num_SPA_itr<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:N<br>        b(:,<span class="hljs-built_in">i</span>) = compute_bi(alpha_tilde,<span class="hljs-built_in">i</span>,N); <span class="hljs-comment">% 计算bi</span><br>        b(:,<span class="hljs-built_in">i</span>) = -b(:,<span class="hljs-built_in">i</span>); <span class="hljs-comment">% 取负值</span><br>        [const idx] = <span class="hljs-built_in">max</span>(b(:,<span class="hljs-built_in">i</span>)&#x27;*Xd); <span class="hljs-comment">% 找到与bi投影最大的点</span><br>        alpha_tilde(:,<span class="hljs-built_in">i</span>) = Xd(:,idx); <span class="hljs-comment">% 更新alpha_tilde(:,i)</span><br>    <span class="hljs-keyword">end</span><br>    new_vol = det( alpha_tilde(:,<span class="hljs-number">1</span>:N<span class="hljs-number">-1</span>) - alpha_tilde(:,N)*<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,N<span class="hljs-number">-1</span>) ); <span class="hljs-comment">% 计算新体积</span><br>    <span class="hljs-keyword">if</span> (new_vol - current_vol)/current_vol  &lt; con_tol<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">% 收敛</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">% end</span><br></code></pre></td></tr></table></figure>
<h3 id="python实现">Python实现</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># Reference:</span><br><span class="hljs-comment"># C.-H. Lin, C.-Y. Chi, Y.-H. Wang, and T.-H. Chan,</span><br><span class="hljs-comment"># ``A fast hyperplane-based minimum-volume enclosing simplex algorithm for blind hyperspectral unmixing,&quot;</span><br><span class="hljs-comment"># arXiv preprint arXiv:1510.08917, 2015.</span><br><span class="hljs-comment">#======================================================================</span><br><span class="hljs-comment"># A fast implementation of Hyperplane-based Craig-Simplex-Identification algorithm</span><br><span class="hljs-comment"># [A_est, S_est, time] = HyperCSI(X,N)</span><br><span class="hljs-comment">#======================================================================</span><br><span class="hljs-comment">#  Input</span><br><span class="hljs-comment">#  X is M-by-L data matrix, where M is the number of spectral bands and L is the number of pixels.</span><br><span class="hljs-comment">#  N is the number of endmembers.</span><br><span class="hljs-comment">#----------------------------------------------------------------------</span><br><span class="hljs-comment">#  Output</span><br><span class="hljs-comment">#  A_est is M-by-N mixing matrix whose columns are estimated endmember signatures.</span><br><span class="hljs-comment">#  S_est is N-by-L source matrix whose rows are estimated abundance maps.</span><br><span class="hljs-comment">#  time is the computation time (in secs).</span><br><span class="hljs-comment">#========================================================================</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">HyperCSI</span>(<span class="hljs-params">X, N</span>):<br>    t0 = time()<br><br>    <span class="hljs-comment">#------------------------ Step 1 ------------------------</span><br>    M, L = X.shape<br>    d = np.mean(X, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)<br>    U = X - d<br>    D, eV = np.linalg.eigh(U @ U.T)<br>    C = eV[:, M-N:M]<br>    Xd = C.T @ (X - d) <span class="hljs-comment"># dimension reduced data (Xd is (N-1)-by-L)</span><br><br>    <span class="hljs-comment">#------------------------ Step 2 ------------------------</span><br>    alpha_tilde = SPA(Xd, L, N) <span class="hljs-comment"># the identified purest pixels</span><br><br>    <span class="hljs-comment">#------------------------ Step 3 ------------------------</span><br>    bi_tilde = np.zeros((N-<span class="hljs-number">1</span>, N))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        bi_tilde[:, i] = compute_bi(alpha_tilde, i, N) <span class="hljs-comment"># obtain bi_tilde</span><br><br>    r = <span class="hljs-number">0.5</span> * np.linalg.norm(alpha_tilde[:, <span class="hljs-number">0</span>] - alpha_tilde[:, <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, N):<br>            dist_ai_aj = np.linalg.norm(alpha_tilde[:, i] - alpha_tilde[:, j])<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">0.5</span> * dist_ai_aj &lt; r:<br>                r = <span class="hljs-number">0.5</span> * dist_ai_aj <span class="hljs-comment"># compute radius of hyperballs</span><br><br>    Xd_divided_idx = np.zeros(L, dtype=<span class="hljs-built_in">int</span>)<br>    radius_square = r**<span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        IDX_alpha_i_tilde = np.<span class="hljs-built_in">sum</span>((Xd - alpha_tilde[:, k].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))**<span class="hljs-number">2</span>, axis=<span class="hljs-number">0</span>) &lt; radius_square<br>        Xd_divided_idx[IDX_alpha_i_tilde] = k <span class="hljs-comment"># compute the hyperballs</span><br><br>    <span class="hljs-comment">#------------------------ Step 4 ------------------------</span><br>    b_hat = np.zeros((N-<span class="hljs-number">1</span>, N))<br>    h_hat = np.zeros(N)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        Hi_idx = [idx <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N) <span class="hljs-keyword">if</span> idx != i]<br>        pi_k = np.zeros((N-<span class="hljs-number">1</span>, N-<span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N-<span class="hljs-number">1</span>):<br>            Ri_k = Xd[:, Xd_divided_idx == Hi_idx[k]]<br>            idx = np.argmax(bi_tilde[:, i].T @ Ri_k)<br>            pi_k[:, k] = Ri_k[:, idx] <span class="hljs-comment"># find N-1 affinely independent points for each hyperplane</span><br>        b_hat[:, i] = compute_bi(np.hstack((pi_k, alpha_tilde[:, i].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))), N, N)<br>        h_hat[i] = np.<span class="hljs-built_in">max</span>(b_hat[:, i].T @ Xd)<br><br>    <span class="hljs-comment">#------------------------ Step 5 &amp; Step 6 ------------------------</span><br>    comm_flag = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># comm_flag = 1 in noisy case: bring hyperplanes closer to the center of data cloud</span><br>    <span class="hljs-comment"># comm_flag = 0 when no noise: Step 5 will not be performed (and hence c = 1)</span><br><br>    eta = <span class="hljs-number">0.9</span> <span class="hljs-comment"># 0.9 is empirically good choice for endmembers in USGS library</span><br>    alpha_hat = np.zeros((N-<span class="hljs-number">1</span>, N))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>        bbbb = np.delete(b_hat, i, axis=<span class="hljs-number">1</span>)<br>        ccconst = np.delete(h_hat, i)<br>        alpha_hat[:, i] = np.linalg.pinv(bbbb.T) @ ccconst<br><br>    <span class="hljs-keyword">if</span> comm_flag == <span class="hljs-number">1</span>:<br>        VV = C @ alpha_hat<br>        UU = d * np.ones((<span class="hljs-number">1</span>, N))<br>        closed_form_optval = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, np.<span class="hljs-built_in">max</span>((-VV) / UU)) <span class="hljs-comment"># c&#x27; in Step 5</span><br>        c = closed_form_optval / eta<br>        h_hat = h_hat / c<br>        alpha_hat = alpha_hat / c<br><br>    A_est = C @ alpha_hat + d <span class="hljs-comment"># endmemeber estimates</span><br><br>    <span class="hljs-comment">#------------------------ Step 7 ------------------------</span><br>    <span class="hljs-comment"># Step 7 can be removed if the user do not need abundance estimation</span><br>    S_est = (h_hat.reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) - b_hat.T @ Xd) / ((h_hat - np.<span class="hljs-built_in">sum</span>(b_hat * alpha_hat, axis=<span class="hljs-number">1</span>)).reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>))<br>    S_est = np.maximum(S_est, <span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># end</span><br><br>    time_elapsed = time() - t0<br><br>    <span class="hljs-keyword">return</span> A_est, S_est, time_elapsed<br><br><br><span class="hljs-comment">#% subprogram 1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_bi</span>(<span class="hljs-params">a0, i, N</span>):<br>    Hindx = [idx <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N) <span class="hljs-keyword">if</span> idx != i]<br>    A_Hindx = a0[:, Hindx]<br>    A_tilde_i = A_Hindx[:, :-<span class="hljs-number">1</span>] - A_Hindx[:, -<span class="hljs-number">1</span>].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    bi = A_Hindx[:, -<span class="hljs-number">1</span>] - a0[:, i]<br>    A_tilde_i_pinv = np.linalg.pinv(A_tilde_i.T @ A_tilde_i)<br>    bi = (np.eye(N-<span class="hljs-number">1</span>) - A_tilde_i @ A_tilde_i_pinv @ A_tilde_i.T) @ bi<br>    bi = bi / np.linalg.norm(bi)<br>    <span class="hljs-keyword">return</span> bi<br><br><br><span class="hljs-comment">#% subprogram 2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SPA</span>(<span class="hljs-params">Xd, L, N</span>):<br>    <span class="hljs-comment"># Reference:</span><br>    <span class="hljs-comment"># [1] W.-K. Ma, J. M. Bioucas-Dias, T.-H. Chan, N. Gillis, P. Gader, A. J. Plaza, A. Ambikapathi, and C.-Y. Chi,</span><br>    <span class="hljs-comment"># ``A signal processing perspective on hyperspectral unmixing,��</span><br>    <span class="hljs-comment"># IEEE Signal Process. Mag., vol. 31, no. 1, pp. 67�V81, 2014.</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># [2] S. Arora, R. Ge, Y. Halpern, D. Mimno, A. Moitra, D. Sontag, Y. Wu, and M. Zhu,</span><br>    <span class="hljs-comment"># ``A practical algorithm for topic modeling with provable guarantees,��</span><br>    <span class="hljs-comment"># arXiv preprint arXiv:1212.4777, 2012.</span><br>    <span class="hljs-comment">#======================================================================</span><br>    <span class="hljs-comment"># An implementation of successive projection algorithm (SPA)</span><br>    <span class="hljs-comment"># [alpha_tilde] = SPA(Xd,L,N)</span><br>    <span class="hljs-comment">#======================================================================</span><br>    <span class="hljs-comment">#  Input</span><br>    <span class="hljs-comment">#  Xd is dimension-reduced (DR) data matrix.</span><br>    <span class="hljs-comment">#  L is the number of pixels.</span><br>    <span class="hljs-comment">#  N is the number of endmembers.</span><br>    <span class="hljs-comment">#----------------------------------------------------------------------</span><br>    <span class="hljs-comment">#  Output</span><br>    <span class="hljs-comment">#  alpha_tilde is an (N-1)-by-N matrix whose columns are DR purest pixels.</span><br>    <span class="hljs-comment">#======================================================================</span><br>    <span class="hljs-comment">#======================================================================</span><br><br>    <span class="hljs-comment">#----------- Define default parameters------------------</span><br>    con_tol = <span class="hljs-number">1e-8</span> <span class="hljs-comment"># the convergence tolence in SPA</span><br>    num_SPA_itr = N <span class="hljs-comment"># number of iterations in post-processing of SPA</span><br>    N_max = N <span class="hljs-comment"># max number of iterations</span><br><br>    <span class="hljs-comment">#------------------------ initialization of SPA ------------------------</span><br>    A_set = np.zeros((N, <span class="hljs-number">0</span>))<br>    Xd_t = np.vstack((Xd, np.ones(L)))<br>    index = []<br>    val = np.<span class="hljs-built_in">sum</span>(Xd_t**<span class="hljs-number">2</span>, axis=<span class="hljs-number">0</span>)<br>    ind = np.argmax(val)<br>    A_set = np.hstack((A_set, Xd_t[:, ind].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)))<br>    index.append(ind)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, N):<br>        XX = Xd_t - A_set @ np.linalg.pinv(A_set.T @ A_set) @ A_set.T @ Xd_t<br>        val = np.<span class="hljs-built_in">sum</span>(XX**<span class="hljs-number">2</span>, axis=<span class="hljs-number">0</span>)<br>        ind = np.argmax(val)<br>        A_set = np.hstack((A_set, Xd_t[:, ind].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)))<br>        index.append(ind)<br>    alpha_tilde = Xd[:, index]<br><br>    <span class="hljs-comment">#------------------------ post-processing of SPA ------------------------</span><br>    current_vol = np.linalg.det(alpha_tilde[:, :-<span class="hljs-number">1</span>] - alpha_tilde[:, -<span class="hljs-number">1</span>].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> jjj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_SPA_itr):<br>        b = np.zeros((N-<span class="hljs-number">1</span>, N))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>            b[:, i] = compute_bi(alpha_tilde, i, N)<br>            b[:, i] = -b[:, i]<br>            idx = np.argmax(b[:, i].T @ Xd)<br>            alpha_tilde[:, i] = Xd[:, idx]<br>        new_vol = np.linalg.det(alpha_tilde[:, :-<span class="hljs-number">1</span>] - alpha_tilde[:, -<span class="hljs-number">1</span>].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">if</span> (new_vol - current_vol) / current_vol &lt; con_tol:<br>            <span class="hljs-keyword">break</span><br>        current_vol = new_vol<br>    <span class="hljs-keyword">return</span> alpha_tilde<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Remote-Sensing-Algorithm/" class="category-chain-item">Remote Sensing, Algorithm</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/HyperCSI/" class="print-no-link">#HyperCSI</a>
      
        <a href="/tags/Hyperspectral-unmixing/" class="print-no-link">#Hyperspectral unmixing</a>
      
        <a href="/tags/Remote-Sensing/" class="print-no-link">#Remote Sensing</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>基于最小体积单纯形的快速高光谱图像解混算法</div>
      <div>http://jingmengzhiyue.top/2024/03/24/HyperCSI/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jingmengzhiyue</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/19/ppi-en/" title="Endmember Extraction Using the Pixel Purity Index (PPI) Algorithm">
                        <span class="hidden-mobile">Endmember Extraction Using the Pixel Purity Index (PPI) Algorithm</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"eZ6fNr2wGbxSreDqCc24Ik6y-gzGzoHsz","appKey":"I1HMoNZO5iKmmCSzqE0wTpGr","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 18954 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 9873 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
