<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于纯像元指数(PPI)的端元提取算法</title>
    <link href="/2024/03/19/ppi/"/>
    <url>/2024/03/19/ppi/</url>
    
    <content type="html"><![CDATA[<p>PPI算法用于从高光谱数据立方体中提取端元光谱。该算法通过在降维后的数据上投影随机生成的单位向量,来识别出表现出最大投影值的端元像元。</p><h2 id="算法原理">算法原理</h2><ol type="1"><li>对高光谱数据立方体进行降维处理,可选择PCA(主成分分析)、MNF(最大噪声分数)或不降维三种方式。</li><li>生成一定数量的随机单位向量(默认10000个)。</li><li>将降维后的数据投影到每个随机单位向量上,记录每个像元点获得的最大投影值。</li><li>根据最大投影值对像元点排序,选取投影值最大的N个像元点作为端元光谱。</li></ol><h2 id="算法实现">算法实现</h2><p>这里介绍如何使用MATLAB实现PPI算法。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs matlab">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endmemSig</span> = <span class="hljs-title">ppi</span><span class="hljs-params">(cube, num, option)</span></span><br><span class="hljs-comment">%PPI 使用像素纯度指数提取端元签名。</span><br><span class="hljs-comment">%   ENDMEMSIG = PPI(CUBE, NUM) 通过在随机生成的单位向量上投影降维数据来估计端元签名。</span><br><span class="hljs-comment">%   NUM 描述了CUBE中存在的端元签名数量。CUBE是一个包含高光谱数据或hypercube对象的</span><br><span class="hljs-comment">%   M-by-N-by-C的数值数组。M和N分别是高光谱立方体的行和列，C是高光谱立方体中的波段数量。</span><br><span class="hljs-comment">%   ENDMEMSIG是一个数值矩阵，提供了维度为C-by-NUM的端元签名。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   ENDMEMSIG = PPI(___, Name, Value) 通过在选定NV对的降维数据上投影随机生成的单位向量来</span><br><span class="hljs-comment">%   估计端元签名。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   &#x27;NumVectors&#x27;    随机生成的单位向量数量。随着数量增加，算法在找到端元的同时也增加了计算复杂度。</span><br><span class="hljs-comment">%                   默认值为10^4。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   &#x27;ReductionMethod&#x27;: 执行降维的方法。选项包括：</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%       &#x27;PCA&#x27;  基于最大数据变异量的主成分分析（PCA），通过保留大部分信息将大数据集转换为较小的数据集。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%       &#x27;MNF&#x27;  基于噪声分数的最大噪声分数（MNF），同样是通过保留大部分信息来缩减数据集大小。MNF是一种根据图像质量排序组件的方法。默认方法为MNF。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%       &#x27;NONE&#x27; 在随机生成的单位向量上投影原始数据。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   注：</span><br><span class="hljs-comment">%   1) PPI算法使用默认的随机种子生成随机单位向量。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   类支持：</span><br><span class="hljs-comment">%   输入数组CUBE必须是以下类之一：uint8, uint16, uint32, int8, int16, int32, single, double, uint64, int64或hypercube对象。</span><br><span class="hljs-comment">%   它必须是实数且非稀疏的。NUM和NumVectors是正整数值的数值标量。输出ENDMEMSIG是与输入cube同类的数值矩阵，大小为C-by-NUM。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   参考：</span><br><span class="hljs-comment">%   J.W  Boardman, F.A. Kruse 和 R.O. Green, &quot;通过部分解混AVIRIS数据映射目标签名&quot;, 技术报告, 加利福尼亚, 美国, 1995。</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   示例 - 1 : 寻找端元签名。</span><br><span class="hljs-comment">%   % 加载indian pines数据集</span><br><span class="hljs-comment">%   cube = load(&#x27;indian_pines.mat&#x27;);</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   % 估计端元数量。</span><br><span class="hljs-comment">%   num = countEndmembersHFC(cube.indian_pines);</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   % 估计并可视化端元签名</span><br><span class="hljs-comment">%   endmemSig = ppi(cube.indian_pines, num);</span><br><span class="hljs-comment">%   plot(endmemSig);</span><br><span class="hljs-comment">%   xlabel(&#x27;波段索引&#x27;)</span><br><span class="hljs-comment">%   ylabel(&#x27;签名&#x27;)</span><br><span class="hljs-comment">%   title(&#x27;端元&#x27;)</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   示例 - 2 : 使用&#x27;PCA&#x27;降维方法寻找端元签名。</span><br><span class="hljs-comment">%   % 加载高光谱立方体。</span><br><span class="hljs-comment">%   obj = hypercube(&#x27;paviaU.hdr&#x27;);</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   % 估计端元数量。</span><br><span class="hljs-comment">%   num = countEndmembersHFC(obj);</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">%   % 使用PPI估计并可视化端元签名。</span><br><span class="hljs-comment">%   endmemSig = ppi(obj, num, &#x27;ReductionMethod&#x27;, &#x27;pca&#x27;, &#x27;NumVectors&#x27;, 10^3);</span><br><span class="hljs-comment">%   plot(endmemSig);</span><br><span class="hljs-comment">%   xlabel(&#x27;波段索引&#x27;)</span><br><span class="hljs-comment">%   ylabel(&#x27;签名&#x27;)</span><br><span class="hljs-comment">%   title(&#x27;端元&#x27;)</span><br><br><br><br><span class="hljs-keyword">arguments</span><br>    cube &#123;mustBeA(cube,<span class="hljs-string">&#x27;hypercube&#x27;</span>)&#125;<br>    num (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) &#123;mustBeNumeric, mustBeNonNan, mustBeFinite, mustBeNonsparse, ...<br>        mustBeNonempty, mustBeReal, mustBeInteger, mustBePositive, ...<br>        mustBeLessSize(num, cube)&#125;<br>    option.NumVectors (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) &#123;mustBeNumeric, mustBeNonNan, mustBeFinite, ...<br>        mustBeNonsparse, mustBeNonempty, mustBeReal, mustBeInteger,...<br>        mustBePositive&#125; = <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br>    option.ReductionMethod (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) string ...<br>        &#123;validatestring(option.ReductionMethod,&#123;<span class="hljs-string">&#x27;MNF&#x27;</span>, <span class="hljs-string">&#x27;PCA&#x27;</span>, <span class="hljs-string">&#x27;NONE&#x27;</span>&#125;)&#125; = <span class="hljs-string">&quot;MNF&quot;</span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% For compiler tests</span><br><span class="hljs-keyword">if</span> isdeployed<br>    rootDir = ctfroot;<br><span class="hljs-keyword">else</span><br>    rootDir = matlabroot;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% Register resources/hyperspectral.</span><br>matlab.internal.msgcat.setAdditionalResourceLocation(rootDir);<br><br><span class="hljs-comment">% Input parsing.</span><br><span class="hljs-keyword">if</span> isobject(cube)<br>    cube = cube.DataCube;<br><span class="hljs-keyword">end</span><br><br>numOfUnitVec = option.NumVectors;<br>method = validatestring(option.ReductionMethod, &#123;<span class="hljs-string">&#x27;MNF&#x27;</span>, <span class="hljs-string">&#x27;PCA&#x27;</span>, <span class="hljs-string">&#x27;NONE&#x27;</span>&#125;);<br><br><span class="hljs-comment">% Volume dimensions.</span><br>[rows, cols, channels] = <span class="hljs-built_in">size</span>(cube);<br>numOfSamples = rows*cols;<br><br>originalCube = <span class="hljs-built_in">reshape</span>(cube, numOfSamples, channels);<br><br><span class="hljs-comment">% Cast the input data to single data type</span><br><span class="hljs-keyword">if</span> isinteger(cube)<br>    cube = single(cube);<br>    num = single(num);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> strcmpi(method, <span class="hljs-string">&#x27;PCA&#x27;</span>)<br>    <span class="hljs-comment">% Principal Component Analysis (PCA) on hyperspectral cube.</span><br>    cube = <span class="hljs-built_in">reshape</span>(hyperpca(cube, num),numOfSamples, num);<br><br><span class="hljs-keyword">elseif</span> strcmpi(method, <span class="hljs-string">&#x27;MNF&#x27;</span>)<br>    <span class="hljs-comment">% Maximum noise fraction (MNF) transformation is used to reduce the</span><br>    <span class="hljs-comment">% computational requirement.</span><br>    cube = <span class="hljs-built_in">reshape</span>(hypermnf(cube, num), numOfSamples, num);<br><br><span class="hljs-keyword">else</span><br>    cube = <span class="hljs-built_in">reshape</span>(cube, numOfSamples, channels);<br><span class="hljs-keyword">end</span><br><br>cube = cube&#x27;;<br><br><span class="hljs-comment">% Determine the maximum projection.</span><br>maxProjections = cast(<span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(cube, <span class="hljs-number">2</span>), <span class="hljs-number">1</span>), class(cube));<br><br><span class="hljs-comment">% Generate random unit vectors.</span><br>prevS = rng(<span class="hljs-string">&#x27;default&#x27;</span>);<br>unitVec = <span class="hljs-built_in">randn</span>(numOfUnitVec, <span class="hljs-built_in">size</span>(cube,<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">% Clean up the random state.</span><br>cleanup = onCleanup(@() rng(prevS));<br><span class="hljs-keyword">for</span> numVect = <span class="hljs-number">1</span>:numOfUnitVec<br>    [~, idx] =  <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(unitVec(numVect,:) *cube));<br>    maxProjections(idx) = maxProjections(idx) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% Find the maximum projected votes to decide the endmember signatures.</span><br>[~, idx] = <span class="hljs-built_in">sort</span>(maxProjections, <span class="hljs-string">&#x27;descend&#x27;</span>);<br><br><span class="hljs-comment">% Extract endmembers form the volume.</span><br>endmemSig = originalCube(idx(<span class="hljs-number">1</span>:num),:)&#x27;;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mustBeA</span><span class="hljs-params">(hypercube,classIn)</span></span><br><br><span class="hljs-keyword">if</span> isobject(hypercube)<br>    validateattributes(hypercube,&#123;classIn&#125;,&#123;<span class="hljs-string">&#x27;nonempty&#x27;</span>&#125;, <span class="hljs-string">&#x27;ppi&#x27;</span>,<span class="hljs-string">&#x27;hypercube&#x27;</span>);<br>    cube = hypercube.DataCube;<br><span class="hljs-keyword">else</span><br>    cube = hypercube;<br><span class="hljs-keyword">end</span><br>validateattributes(cube, ...<br>    &#123;<span class="hljs-string">&#x27;numeric&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;nonsparse&#x27;</span>, <span class="hljs-string">&#x27;nonempty&#x27;</span>, <span class="hljs-string">&#x27;real&#x27;</span>,<span class="hljs-string">&#x27;nonnan&#x27;</span>, ...<br>    <span class="hljs-string">&#x27;finite&#x27;</span>, <span class="hljs-string">&#x27;ndims&#x27;</span>, <span class="hljs-number">3</span>&#125;, mfilename, <span class="hljs-string">&#x27;hypercube&#x27;</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% Validate the numComponents are less than number of bands.</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mustBeLessSize</span><span class="hljs-params">(a, b)</span></span><br><span class="hljs-keyword">if</span> isobject(b)<br>    cube = b.DataCube;<br><span class="hljs-keyword">else</span><br>    cube = b;<br><span class="hljs-keyword">end</span><br>sz = <span class="hljs-built_in">size</span>(cube);<br>validateattributes(a, &#123;<span class="hljs-string">&#x27;numeric&#x27;</span>&#125;,...<br>    &#123;<span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&lt;=&#x27;</span>,sz(<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;scalar&#x27;</span>&#125;,mfilename, <span class="hljs-string">&#x27;num&#x27;</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">if</span> (a &gt;= sz(<span class="hljs-number">1</span>)*sz(<span class="hljs-number">2</span>))<br>    error(message(<span class="hljs-string">&#x27;hyperspectral:hyperpca:notGreaterEqual&#x27;</span>));<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>总的来说，PPI算法是一种基于几何的无监督端元提取方法，通过将降维数据投影到随机单位向量上并找到具有最大投影值的像素来识别端元像素。它通常用于高光谱图像的端元提取和非线性解混分析。</p>]]></content>
    
    
    <categories>
      
      <category>Remote Sensing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Remote Sensing</tag>
      
      <tag>Endmember</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于特征值阈值的端元数估计方法</title>
    <link href="/2024/03/19/est-endnum/"/>
    <url>/2024/03/19/est-endnum/</url>
    
    <content type="html"><![CDATA[<h1id="基于特征值阈值的端元数估计方法">基于特征值阈值的端元数估计方法</h1><p>在高光谱图像分析中，端元数估计是一个关键步骤，它关系到后续处理的准确性和效率。本文介绍了一种基于特征值阈值的端元数估计方法，该方法通过噪声白化和特征值分析来确定高光谱数据中的端元数量。</p><h2 id="高光谱图像的噪声白化">高光谱图像的噪声白化</h2><p>首先，我们考虑一个高光谱图像 <span class="math inline">\(\mathbf{X}\in \mathbb{R}^{M \times B}\)</span>，其中 <spanclass="math inline">\(M\)</span> 是空间像素数，<spanclass="math inline">\(B\)</span> 是谱带数。每个谱带可以表示为 <spanclass="math inline">\(\mathbf{X}\)</span> 的一个列向量 <spanclass="math inline">\(\mathbf{x}_i\)</span>。</p><p>噪声白化是预处理高光谱数据的第一步，目的是减少数据中的噪声，从而更容易识别出端元。为此，我们首先计算高光谱数据的协方差矩阵<span class="math inline">\(\mathbf{C}_x\)</span>，其定义如下：</p><p><span class="math display">\[    \mathbf{C}_x = \operatorname{Cov}(\mathbf{X}) =\left[\begin{array}{ccc}                \sigma\left(\mathbf{x}_{1}, \mathbf{x}_{1}\right) &amp;\cdots &amp; \sigma\left(\mathbf{x}_{1}, \mathbf{x}_{B}\right) \\                \vdots &amp; \ddots &amp; \vdots \\                \sigma\left(\mathbf{x}_{B}, \mathbf{x}_{1}\right) &amp;\cdots &amp; \sigma\left(\mathbf{x}_{B}, \mathbf{x}_{B}\right)            \end{array}\right] \in \mathbb{R}^{B \times B}\]</span></p><p>其中，<span class="math inline">\(\sigma\left(\mathbf{x}_{m},\mathbf{x}_{k}\right)\)</span> 是两个向量 <spanclass="math inline">\(\mathbf{x}_m\)</span> 和 <spanclass="math inline">\(\mathbf{x}_k\)</span>之间的协方差，计算公式为：</p><p><span class="math display">\[    \sigma\left(\mathbf{x}_{m}, \mathbf{x}_{k}\right) = \frac{1}{n-1}\sum_{i=1}^{n}\left(\mathbf{x}_{m i} -\bar{\mathbf{x}}_{m}\right)\left(\mathbf{x}_{k i} -\bar{\mathbf{x}}_{k}\right)\]</span></p><p>接下来，我们根据协方差矩阵 <spanclass="math inline">\(\mathbf{C}_x\)</span> 计算噪声矩阵协方差 <spanclass="math inline">\(\mathbf{N}\)</span>：</p><p><span class="math display">\[    \mathbf{N} =\operatorname{diag}\left(\frac{1}{\operatorname{Getdiag}(\mathbf{C}_x^{-1})}\right)\in \mathbb{R}^{B \times B}\]</span></p><p>其中，<spanclass="math inline">\(\operatorname{Getdiag}(\cdot)\)</span>表示提取矩阵的对角线元素，<spanclass="math inline">\(\operatorname{diag}(\cdot)\)</span>表示将向量转换为对角矩阵。</p><p>有了噪声矩阵协方差 <spanclass="math inline">\(\mathbf{N}\)</span>，我们可以计算白化噪声矩阵<span class="math inline">\(\mathbf{Y}\)</span>：</p><p><span class="math display">\[    \mathbf{Y} =\mathbf{X}\left(\left(\sqrt{\mathbf{N}}\right)^{-1}\right)^\top\]</span></p><h2 id="特征值软阈值算法">特征值软阈值算法</h2><p>白化后的噪声矩阵 <span class="math inline">\(\mathbf{Y}\)</span>用于端元数估计。我们首先计算 <spanclass="math inline">\(\mathbf{Y}\)</span> 的自相关矩阵 <spanclass="math inline">\(\mathbf{C}_y\)</span> 和自协方差矩阵 <spanclass="math inline">\(\mathbf{R}_y\)</span>：</p><p><span class="math display">\[    \mathbf{C}_y = \operatorname{Cov}(\mathbf{Y}) \in \mathbb{R}^{B\times B}\]</span></p><p><span class="math display">\[    \mathbf{R}_y = E\left(\mathbf{Y} \mathbf{Y}^{T}\right) \in\mathbb{R}^{B \times B}\]</span></p><p>其中，自相关矩阵 <span class="math inline">\(\mathbf{C}_y\)</span>的元素 <span class="math inline">\(\sigma\left(\mathbf{y}_{i},\mathbf{y}_{j}\right)\)</span> 和自协方差矩阵 <spanclass="math inline">\(\mathbf{R}_y\)</span> 的元素 <spanclass="math inline">\(\rho(\mathbf{y}_i, \mathbf{y}_j)\)</span>定义如下：</p><p><span class="math display">\[    \rho(\mathbf{y}_i, \mathbf{y}_j) = \operatorname{corr}(\mathbf{y}_i,\mathbf{y}_j) = \frac{\operatorname{cov}(\mathbf{y}_i,\mathbf{y}_j)}{\sigma_Y \sigma_Y}\]</span></p><p>接下来，我们分别计算这两个矩阵的特征值：</p><p><span class="math display">\[    \mathbf{\Sigma}_C = \operatorname{eig}(\mathbf{C}_y)\]</span></p><p><span class="math display">\[    \mathbf{\Sigma}_R = \operatorname{eig}(\mathbf{R}_y)\]</span></p><p>特征值矩阵 <span class="math inline">\(\mathbf{\Sigma}_C\)</span> 和<span class="math inline">\(\mathbf{\Sigma}_R\)</span>包含了自相关矩阵和自协方差矩阵的特征值。我们通过这两个矩阵计算特征值之间的方差<span class="math inline">\(\mathbf{D}\)</span>：</p><p><span class="math display">\[    \mathbf{D} = \mathbf{\Sigma}_R - \mathbf{\Sigma}_C\]</span></p><p>然后，我们估计噪声方差 <spanclass="math inline">\(\mathbf{V}\)</span>：</p><p><span class="math display">\[    \mathbf{V} = \frac{2}{M}\left(\mathbf{\Sigma}_R^2 +\mathbf{\Sigma}_C^2\right)\]</span></p><p>最后，我们根据噪声方差 <spanclass="math inline">\(\mathbf{V}\)</span> 计算特征值阈值门限 <spanclass="math inline">\(\operatorname{gate}\)</span>：</p><p><span class="math display">\[    \operatorname{gate} = \sqrt{2 \times \mathbf{V}}\]</span></p><p>利用特征值阈值算法，我们可以得到估计的端元数 <spanclass="math inline">\(I\)</span>：</p><p><span class="math display">\[    I = \sum_{i = 1}^B (\mathbf{D}_{ii} &gt; \operatorname{gate})\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Remote Sensing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Remote Sensing</tag>
      
      <tag>Endmember</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>端元初始化</title>
    <link href="/2024/03/19/endmember/"/>
    <url>/2024/03/19/endmember/</url>
    
    <content type="html"><![CDATA[<h1id="端元估计在高光谱图像处理中的重要性">端元估计在高光谱图像处理中的重要性</h1><p>高光谱图像处理领域经常会遇到端元矩阵初始化的问题，而端元矩阵的准确估计对于最终处理结果的性能有着重要的影响。在处理凸优化问题时，初始值的选择对最终结果的影响相对较小。然而，面对非凸优化问题，一个接近全局最优解的初始值能够显著提升算法的性能。</p><figure><img src="/img/End.jpg" alt="凸优化与非凸优化" /><figcaption aria-hidden="true">凸优化与非凸优化</figcaption></figure><h2 id="端元数量的重要性">端元数量的重要性</h2><p>在高光谱领域的多种模型中，端元数量扮演着关键角色。例如，给定一个高光谱图像<span class="math inline">\(\mathcal{Z} \in \mathbb{R}^{M\times N\timesB}\)</span>，我们假设其端元数量为 <spanclass="math inline">\(R\)</span>。在非负矩阵分解模型中，我们有：</p><p><span class="math display">\[\mathbf{Z} \in \mathbb{R}^{B\times MN} = (\mathbf{A} \in\mathbb{R}^{B\times R})(\mathbf{S} \in \mathbb{R}^{R\times MN})\]</span></p><p>式中，<span class="math inline">\(\mathbb{R}^{B\timesMN}\)</span>，表示端元矩阵。</p><p>在张量CP分解模型中，表达式变为：</p><p><span class="math display">\[\mathcal{Z} = \sum_{r=1}^{R} \omega_{r}(\mathbf{a}_{r} \circ\mathbf{b}_{r} \circ \mathbf{c}_{r})\]</span></p><p>式中<span class="math inline">\(\omega_{r}\)</span>表示第<spanclass="math inline">\(r\)</span>个分量的权重，将其中的<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>进行矩阵化可以得到秩1近似的空间信息矩阵，而<spanclass="math inline">\(c\)</span>矩阵就是包含光谱信息的矩阵</p><p>对于Tucker分解模型，表达式为：</p><p><span class="math display">\[\mathcal{Z} \in \mathbb{R}^{M\times N\times B} = (\mathcal{G} \in\mathbb{R}^{m\times n\times R}) \times_{1} \mathbf{A} \times_{2}\mathbf{B} \times_{3} (\mathbf{C} \in \mathbb{R}^{B\times R})\]</span> 式中，<span class="math inline">\(\mathbf{C} \in\mathbb{R}^{B\timesR}\)</span>表示光谱因子矩阵，包含了光谱的成分信息。将它初始化为端元矩阵往往会提升算法的性能以及收敛速度。</p><p>最后，在BTD(Block Term Decomposition)分解中，我们得到：</p><p><span class="math display">\[\mathcal{Z} = \sum_{r=1}^{R} \mathcal{G}_{r} \times_{1} \mathbf{A}_{r}\times_{2} \mathbf{B}_{r} \times_{3} \mathbf{C}_{r} \approx\sum_{r=1}^{R} \mathbf{A}_{r} \cdot \mathbf{B}_{r}^{T} \circ\mathbf{c}_{r} = \sum_{r=1}^{R} \mathbf{E}_{r} \circ \mathbf{c}_{r}\]</span></p><p>在BTD分解中进行地址假设对标准分解形式进行华建，最终得到空间因子矩阵和光谱因子矩阵的乘积，矩阵<spanclass="math inline">\(\mathbf{C}\)</span>表示高光谱图像中的光谱特征矩阵。同样将它初始化为端元矩阵，可以提升算法的性能和收敛速度。</p><p>在这些模型中，端元数量 <span class="math inline">\(R\)</span>的选择对于算法的性能和结果的准确性至关重要。正确估计端元数量不仅可以提高处理效率，还能确保最终结果的准确性和可靠性。</p>]]></content>
    
    
    <categories>
      
      <category>Remote Sensing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Remote Sensing</tag>
      
      <tag>Endmember</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Using OpenCV C++ on Windows Subsystem for Linux (WSL)</title>
    <link href="/2024/03/16/OpenCV-WSL/"/>
    <url>/2024/03/16/OpenCV-WSL/</url>
    
    <content type="html"><![CDATA[<p>Setting up OpenCV C++ on Windows Subsystem for Linux (WSL) involvesseveral steps, including installing WSL, installing necessarydependencies, downloading the OpenCV source code, and compiling andinstalling OpenCV. This blog post provides a step-by-step guide to helpyou through the process.</p><h2 id="summary">Summary</h2><p>The process of using OpenCV C++ on Windows Subsystem for Linux (WSL)involves enabling WSL on your Windows system, installing a Linuxdistribution (like Ubuntu), updating and installing requireddependencies, downloading the OpenCV and OpenCV Contrib source code,configuring the build environment with CMake, compiling and installingOpenCV, and finally verifying the installation by running a simpleOpenCV C++ program.</p><h2 id="step-by-step-guide">Step-by-Step Guide</h2><ol type="1"><li><p><strong>Install WSL</strong>: Ensure that WSL is enabled on yourWindows 10 or higher system. You can run the following command inPowerShell to enable WSL and install Ubuntu (or any other Linuxdistribution of your choice):</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--install</span><br></code></pre></td></tr></table></figure><p>After restarting your computer, open the Microsoft Store, search forUbuntu, and install your preferred version.</p></li><li><p><strong>Update and Install Dependencies</strong>: Launch yourLinux distribution (e.g., Ubuntu), and use the following commands toupdate your package manager and install the required dependencies forcompiling OpenCV:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update &amp;&amp; sudo apt upgrade -y<br>sudo apt install -y build-essential cmake git pkg-config libgtk-3-dev \<br>libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \<br>libxvidcore-dev libx264-dev libjpeg-dev libpng-dev libtiff-dev \<br>gfortran openexr libatlas-base-dev python3-dev python3-numpy \<br>libtbb2 libtbb-dev libdc1394-22-dev<br></code></pre></td></tr></table></figure></li><li><p><strong>Download OpenCV and OpenCV Contrib Source Code</strong>:Download the OpenCV and OpenCV Contrib source code from the OpenCVGitHub repository:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/opencv_build &amp;&amp; <span class="hljs-built_in">cd</span> ~/opencv_build<br>git <span class="hljs-built_in">clone</span> https://github.com/opencv/opencv.git<br>git <span class="hljs-built_in">clone</span> https://github.com/opencv/opencv_contrib.git<br></code></pre></td></tr></table></figure><p>Ensure both repositories are on the same version, e.g., OpenCV4.x:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/opencv_build/opencv<br>git checkout 4.x<br><span class="hljs-built_in">cd</span> ../opencv_contrib<br>git checkout 4.x<br></code></pre></td></tr></table></figure></li><li><p><strong>Compile and Install OpenCV</strong>: Create a builddirectory, configure the build environment using CMake, and then compileand install OpenCV:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/opencv_build/opencv<br><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br>cmake -D CMAKE_BUILD_TYPE=RELEASE \<br>-D CMAKE_INSTALL_PREFIX=/usr/local \<br>-D INSTALL_C_EXAMPLES=ON \<br>-D INSTALL_PYTHON_EXAMPLES=ON \<br>-D OPENCV_GENERATE_PKGCONFIG=ON \<br>-D OPENCV_EXTRA_MODULES_PATH=~/opencv_build/opencv_contrib/modules \<br>-D BUILD_EXAMPLES=ON ..<br>make -j$(<span class="hljs-built_in">nproc</span>)<br>sudo make install<br></code></pre></td></tr></table></figure></li><li><p><strong>Configure Environment Variables</strong>: To ensure thecompiler can find the OpenCV libraries, you need to update the<code>LD_LIBRARY_PATH</code> environment variable. Add the followingline to your <code>~/.bashrc</code> or <code>~/.profile</code> file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/usr/local/lib<br></code></pre></td></tr></table></figure><p>Then, execute <code>source ~/.bashrc</code> or restart your terminalapplication to apply the changes.</p></li><li><p><strong>Verify Installation</strong>: Compile and run a simpleOpenCV program to verify the successful installation. You can create asimple C++ program that uses OpenCV to read and display animage.</p></li></ol><p>By following these steps, you should be able to successfully set upand use OpenCV C++ on the Windows Subsystem for Linux (WSL).</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV Basics</title>
    <link href="/2024/03/14/OpenCV-Basics/"/>
    <url>/2024/03/14/OpenCV-Basics/</url>
    
    <content type="html"><![CDATA[<p>This blog post covers the basics of OpenCV, a popular computer visionlibrary. It explains how to load, display, and save images using OpenCVfunctions. Additionally, it delves into the Mat class, which is used torepresent images in OpenCV as matrices. The post demonstrates how tocreate Mat objects, access their properties, and traverse and manipulatepixel values using both array-based and pointer-based methods. ## HelloWorld</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace cv;<br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;start\n&quot;</span>;<br>    <span class="hljs-comment">// Read an image</span><br>    Mat src = imread(<span class="hljs-string">&quot;E:\\Datum\\Code\\CV4\\CV4\\a.png&quot;</span>);<br>    <span class="hljs-keyword">if</span> (src.empty()) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;could not open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    namedWindow(<span class="hljs-string">&quot;input&quot;</span>, WINDOW_AUTOSIZE); <span class="hljs-comment">// Create a window with the given title and automatic image size</span><br>    <span class="hljs-comment">// In OpenCV 3, use namedWindow(&quot;input&quot;, CV_WINDOW_AUTOSIZE)</span><br>    imshow(<span class="hljs-string">&quot;input&quot;</span>, src); <span class="hljs-comment">// Display the image in the &quot;input&quot; window</span><br>    waitKey(<span class="hljs-number">0</span>); <span class="hljs-comment">// Prevent the window from closing immediately, wait for user input</span><br>    destroyAllWindows(); <span class="hljs-comment">// Destroy all windows</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>In OpenCV 4, you can directly use<code>#include &lt;opencv2/opencv.hpp&gt;</code> to import all OpenCVfunctions.</li><li><code>using namespace cv;</code> uses the OpenCV namespace.</li><li>Define a <code>Mat</code> variable <code>src</code> and read animage into it.</li><li>Perform robustness check; if the loaded image is not empty, displayit.</li><li>Use <code>namedWindow("input", WINDOW_AUTOSIZE);</code> to create awindow. The first parameter is the window name, and the second parameteris the window size, which in OpenCV 4 is defined as automatic windowsize. In OpenCV 3, use<code>nameWindow("input", CV_WINDOW_AUTOSIZE)</code> to define thewindow.</li><li>Use <code>imshow("input", src)</code> to display the image. Thefirst parameter is the window to display in, and the second parameter isthe image to display.</li><li>To prevent the displayed image from disappearing immediately, use<code>waitKey(0)</code> to wait for user input.</li><li>Use <code>destroyAllWindows()</code> to destroy all windows.</li></ol><h2 id="image-file-loading-displaying-and-saving">Image File Loading,Displaying, and Saving</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace cv;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Mat src = imread(&quot;./lenna.tiff&quot;, IMREAD_COLOR); // Load as a color image, default mode, transparency channel will be discarded</span><br>    <span class="hljs-comment">// Mat src = imread(&quot;./lenna.tiff&quot;, IMREAD_GRAYSCALE); // Load as a grayscale image</span><br>    <span class="hljs-comment">// Mat src = imread(&quot;./lenna.tiff&quot;, IMREAD_ANYCOLOR); // Load with any color format</span><br>    Mat src = imread(<span class="hljs-string">&quot;./test.png&quot;</span>, IMREAD_UNCHANGED); <span class="hljs-comment">// Do not change the number of channels, supports loading PNG transparency channel</span><br>    <span class="hljs-keyword">if</span> (src.empty()) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;can not open&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-comment">// namedWindow(&quot;input&quot;, WINDOW_AUTOSIZE); // Automatically fit image size, cannot be changed</span><br>    <span class="hljs-comment">// namedWindow(&quot;input&quot;, WINDOW_FREERATIO); // Freely change image display size</span><br>    namedWindow(<span class="hljs-string">&quot;input&quot;</span>, WINDOW_NORMAL); <span class="hljs-comment">// Can change image display size</span><br>    imshow(<span class="hljs-string">&quot;input&quot;</span>, src);<br>    waitKey(<span class="hljs-number">0</span>);<br>    destroyAllWindows();<br>    imwrite(<span class="hljs-string">&quot;./test.png&quot;</span>, src); <span class="hljs-comment">// Save as the corresponding format based on the file extension</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="image-file-loading">Image File Loading</h3><p>The <code>imread("filename", load_mode)</code> function: 1. Bydefault, loads a BGR color image. 2. Supports grayscale and any colorformat images.</p><p>Common load modes include: 1. <code>IMREAD_COLOR</code>: Load as acolor image, the default mode, transparency channel will be discarded.2. <code>IMREAD_GRAYSCALE</code>: Load as a grayscale image. 3.<code>IMREAD_ANYCOLOR</code>: Load with any color format. 4.<code>IMREAD_UNCHANGED</code>: Do not change the number of channels,supports loading PNG transparency channel.</p><h3 id="window-and-display">Window and Display</h3><p>The <code>imshow("window_name", display_mode)</code> function:</p><p>Display modes include: 1. <code>WINDOW_AUTOSIZE</code>: Automaticallyfit the image size, cannot be changed. 2. <code>WINDOW_FREERATIO</code>:Freely change the image display size. 3. <code>WINDOW_NORMAL</code>: Canchange the image display size.</p><h3 id="image-file-saving">Image File Saving</h3><p>The <code>imwrite("save_address", variable)</code> function: Savesthe image in the corresponding format based on the file extension.</p><h2 id="mat-class">Mat Class</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Image object Mat</span><br><span class="hljs-comment">// An image is a matrix, Mat is an object that stores matrices</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace cv;<br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Mat src = imread(<span class="hljs-string">&quot;./lenna.tiff&quot;</span>);<br>    <span class="hljs-keyword">if</span> (src.empty()) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;cannot open&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    namedWindow(<span class="hljs-string">&quot;input&quot;</span>, WINDOW_FREERATIO);<br>    imshow(<span class="hljs-string">&quot;input&quot;</span>, src);<br>    <span class="hljs-type">int</span> width = src.cols; <span class="hljs-comment">// Get the image width</span><br>    <span class="hljs-type">int</span> height = src.rows; <span class="hljs-comment">// Get the image height</span><br>    <span class="hljs-type">int</span> dim = src.channels(); <span class="hljs-comment">// Get the number of image channels</span><br>    <span class="hljs-type">int</span> d = src.depth(); <span class="hljs-comment">// Image depth, enum type</span><br>    <span class="hljs-type">int</span> t = src.type(); <span class="hljs-comment">// Image type, enum type</span><br>    <span class="hljs-keyword">if</span> (t == CV_8UC3) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; width &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; height &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; dim &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; d &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; t &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    waitKey(<span class="hljs-number">0</span>);<br>    destroyAllWindows();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>An image is essentially a matrix, so in OpenCV, images are stored inmatrix form, i.e., Mat. Common attributes of Mat include:</p><ol type="1"><li><code>src.cols;</code> // Get the image width.</li><li><code>src.rows;</code> // Get the image height.</li><li><code>src.channels();</code> // Get the number of imagechannels.</li><li><code>src.depth();</code> // Image depth, enum type, returns thedepth of each pixel element. Common values include <code>CV_8U</code>(8-bit unsigned integer), <code>CV_16U</code> (16-bit unsigned integer),<code>CV_32F</code> (32-bit float), etc.</li><li><code>src.type();</code> // Image type, enum type. Common typesinclude <code>CV_8U</code> (8-bit unsigned integer), <code>CV_8S</code>(8-bit signed integer), <code>CV_16U</code> (16-bit unsigned integer),<code>CV_16S</code> (16-bit signed integer), <code>CV_32F</code> (32-bitfloat), <code>CV_64F</code> (64-bit float), etc.</li><li><code>src.size</code> // Returns a tuple containing the number ofrows and columns of the image.</li><li><code>src.empty()</code>: Check if the Mat object is empty.</li><li><code>src.total()</code>: Returns the total number of elements inthe Mat object.</li></ol><h2 id="creating-and-using-mat-objects">Creating and Using MatObjects</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>using namespace cv;<br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    Mat src = imread(<span class="hljs-string">&quot;./lenna.tiff&quot;</span>);<br>    Mat t1 = Mat(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, CV_8UC3); <span class="hljs-comment">// Create a 256x256 grayscale image</span><br>    t1 = Scalar(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>); <span class="hljs-comment">// Assign values to the image matrix</span><br>    imshow(<span class="hljs-string">&quot;t1&quot;</span>, t1);<br>    Mat t2 = Mat(Size(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>), CV_8UC3); <span class="hljs-comment">// Create a 512x512 grayscale image</span><br>    t2 = Scalar(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>); <span class="hljs-comment">// Assign values to the image matrix</span><br>    imshow(<span class="hljs-string">&quot;t2&quot;</span>, t2);<br>    Mat t3 = Mat::zeros(Size(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>), CV_8SC3); <span class="hljs-comment">// Directly create a 256x256 all-black image during creation</span><br>    imshow(<span class="hljs-string">&quot;t3&quot;</span>, t3);<br>    <span class="hljs-comment">// Create from an existing image</span><br>    Mat t4 = src;<br>    <span class="hljs-comment">// t4 = Scalar(0, 255, 255); // Assigning values to t4 will also change t5</span><br>    imshow(<span class="hljs-string">&quot;t4&quot;</span>, t4);<br>    <span class="hljs-comment">// Create using the clone method</span><br>    Mat t5 = src.clone();<br>    t5 = Scalar(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>); <span class="hljs-comment">// Assigning values to t5 will not change t4</span><br>    imshow(<span class="hljs-string">&quot;t5&quot;</span>, t5);<br>    Mat t6;<br>    src.copyTo(t6);<br>    imshow(<span class="hljs-string">&quot;t6&quot;</span>, t6);<br>    Mat t7 = Mat::zeros(src.size(), src.type()); <span class="hljs-comment">// Create an all-zero image with the same size as src</span><br>    waitKey(<span class="hljs-number">0</span>);<br>    destroyAllWindows();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="creating-mat-objects">Creating Mat Objects</h3><ol type="1"><li>Use <code>Mat t1 = Mat(256, 256, CV_8UC3);</code> to create a256x256 grayscale image. The type represents an unsigned 3-channelimage.</li><li><code>t1 = Scalar(0, 0, 256);</code> assigns constant values to theimage matrix.</li><li><code>Mat t2 = Mat(Size(512, 512), CV_8UC3);</code> creates a512x512 grayscale image.</li><li><code>Mat t3 = Mat::zeros(Size(256, 256), CV_8SC3);</code> directlycreates a 256x256 all-black image with an unsigned 3-channel type duringcreation.</li><li><code>Mat t4 = src;</code> creates <code>t4</code> directly from<code>src</code>.</li><li><code>Mat t5 = src.clone();</code> creates a clone of<code>src</code>.</li><li><code>Mat t6; src.copyTo(t6);</code> copies <code>src</code> to<code>t6</code>.</li><li><code>Mat t7 = Mat::zeros(src.size(), src.type());</code> creates anall-zero image with the same size and type as <code>src</code>.</li></ol><h3 id="traversing-and-accessing-pixel-values">Traversing and AccessingPixel Values</h3><p>OpenCV provides several methods to access and manipulate individualpixels in an image. Here's a concise overview of the differenttechniques:</p><h4 id="array-based-pixel-access-with-at">1. Array-based Pixel Accesswith <code>at</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">methodAt</span><span class="hljs-params">(Mat&amp; image)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; image.rows; y++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; image.cols; x++) &#123;<br>            <span class="hljs-comment">// For grayscale images</span><br>            <span class="hljs-comment">// uchar&amp; pixel = image.at&lt;uchar&gt;(y, x);</span><br>            <span class="hljs-comment">// pixel = ...;</span><br><br>            <span class="hljs-comment">// For color (BGR) images</span><br>            Vec3b&amp; color = image.<span class="hljs-built_in">at</span>&lt;Vec3b&gt;(y, x);<br>            <span class="hljs-comment">// Operate on pixel, e.g., invert color</span><br>            color[<span class="hljs-number">0</span>] = <span class="hljs-number">255</span> - color[<span class="hljs-number">0</span>]; <span class="hljs-comment">// B</span><br>            color[<span class="hljs-number">1</span>] = <span class="hljs-number">255</span> - color[<span class="hljs-number">1</span>]; <span class="hljs-comment">// G</span><br>            color[<span class="hljs-number">2</span>] = <span class="hljs-number">255</span> - color[<span class="hljs-number">2</span>]; <span class="hljs-comment">// R</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Use nested loops to iterate over every row and column of theimage</li><li>Access color pixels with<code>image.at&lt;Vec3b&gt;(y, x)</code></li><li>Access grayscale pixels with<code>image.at&lt;uchar&gt;(y, x)</code></li><li>Directly read and write pixel values, e.g.,<code>pixel[0] = 255 - blue</code></li><li>Requires obtaining the image's height, width, and number ofchannels</li></ul><h4 id="pointer-based-pixel-access">2. Pointer-based Pixel Access</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">methodPointer</span><span class="hljs-params">(Mat&amp; image)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; image.rows; y++) &#123;<br>        <span class="hljs-comment">// Get a pointer to the start of the y-th row</span><br>        uchar* row = image.<span class="hljs-built_in">ptr</span>&lt;uchar&gt;(y);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; image.cols; x++) &#123;<br>            <span class="hljs-comment">// For grayscale images</span><br>            <span class="hljs-comment">// uchar&amp; pixel = row[x];</span><br>            <span class="hljs-comment">// pixel = ...;</span><br><br>            <span class="hljs-comment">// For color (BGR) images</span><br>            <span class="hljs-comment">// BGR format, each pixel occupies 3 uchars</span><br>            uchar&amp; blue = row[x * <span class="hljs-number">3</span>];<br>            uchar&amp; green = row[x * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>];<br>            uchar&amp; red = row[x * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>];<br>            <span class="hljs-comment">// Operate on pixel</span><br>            blue = <span class="hljs-number">255</span> - blue;<br>            green = <span class="hljs-number">255</span> - green;<br>            red = <span class="hljs-number">255</span> - red;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Use nested loops to iterate over every row and column of theimage</li><li>Get a pointer to the start of each row with<code>image.ptr&lt;uchar&gt;(y)</code></li><li>Access color pixels by incrementing the pointer by<code>x * 3</code> for each channel</li><li>Access grayscale pixels by incrementing the pointer by<code>x</code></li></ul><h4 id="iterator-based-pixel-access">3. Iterator-based Pixel Access</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">methodIterator</span><span class="hljs-params">(Mat&amp; image)</span> </span>&#123;<br>    <span class="hljs-comment">// cv::Mat_&lt;Vec3b&gt; is the iterator type for color images</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = image.<span class="hljs-built_in">begin</span>&lt;Vec3b&gt;(); it != image.<span class="hljs-built_in">end</span>&lt;Vec3b&gt;(); it++) &#123;<br>        <span class="hljs-comment">// Invert color</span><br>        (*it)[<span class="hljs-number">0</span>] = <span class="hljs-number">255</span> - (*it)[<span class="hljs-number">0</span>]; <span class="hljs-comment">// B</span><br>        (*it)[<span class="hljs-number">1</span>] = <span class="hljs-number">255</span> - (*it)[<span class="hljs-number">1</span>]; <span class="hljs-comment">// G</span><br>        (*it)[<span class="hljs-number">2</span>] = <span class="hljs-number">255</span> - (*it)[<span class="hljs-number">2</span>]; <span class="hljs-comment">// R</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Use iterators to traverse the image pixels</li><li><code>image.begin&lt;Vec3b&gt;()</code> returns an iterator to thefirst pixel in the image</li><li><code>image.end&lt;Vec3b&gt;()</code> returns an iterator to theposition after the last pixel</li><li>Directly access and modify pixel values using the iteratordereferencing operator <code>*it</code></li></ul><p>These techniques provide different ways to access and manipulatepixel data in OpenCV images. The choice depends on personal preference,code readability, and performance considerations for the specific usecase.</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 11 + WSL + VS Code + Rust Environment Setup</title>
    <link href="/2024/03/11/rust-wal2-vscode/"/>
    <url>/2024/03/11/rust-wal2-vscode/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>You can set up a Rust environment on either Windows or Linux. Aftersearching online, I found that setting up a Rust environment on Linux ismuch quicker than on Windows, but I still use the Windows system on adaily basis.</p><p>Therefore, I ultimately chose to set up the Rust environment in theWSL2 of Windows 11, and then use VS Code to connect to WSL.</p><h2 id="overall-steps">Overall Steps</h2><ol type="1"><li>Install WSL on Windows 11</li><li>Change the source on WSL in Windows 11</li><li>Install gcc on WSL in Windows 11</li><li>Install Rust on WSL in Windows 11</li><li>Install Remote-WSL on VS Code in Windows 11</li><li>Install rust-analyzer on VS Code in Windows 11</li><li>Simple verification</li><li>Run and debug</li></ol><h2 id="install-wsl-on-windows-11">Install WSL on Windows 11</h2><p>Reference: <ahref="https://learn.microsoft.com/en-us/windows/wsl/about">https://learn.microsoft.com/en-us/windows/wsl/about</a></p><p><ahref="https://learn.microsoft.com/en-us/windows/wsl/install">https://learn.microsoft.com/en-us/windows/wsl/install</a></p><p>Prerequisites:</p><figure><img src="/img/图片40.png" alt="image-20231126161500760" /><figcaption aria-hidden="true">image-20231126161500760</figcaption></figure><p>Open PowerShell or Windows Command Prompt as an administrator, andenter the <code>wsl --install</code> command to start installing WSL. Bydefault, this will install the latest stable version of Ubuntu. You canmanually choose other versions; see the <ahref="https://learn.microsoft.com/en-us/windows/wsl/install">Microsofttutorial</a> for specific instructions.</p><p>After the installation is complete, you need to restart your computerfor the configuration to take effect.</p><p>PS: It might be because I had a VPN running all the time, but duringthe WSL installation, it kept prompting "wsl: Localhost proxyconfiguration detected, but not mirrored to WSL. Localhost proxy is notsupported in NAT mode for WSL."</p><p>I'm not sure if this would affect the network of WSL, but to be safe,I followed the <ahref="https://github.com/microsoft/WSL/issues/10753">instructions</a> tomake some configurations.</p><p>In WSL, there is a configuration file used to configure advancedsetting options, which is <ahref="https://learn.microsoft.com/en-us/windows/wsl/wsl-config">.wslconfig</a>.This file doesn't exist by default; if you want to configure it, youneed to create it manually.</p><p>This file is located at<code>C:\Users\&lt;UserName&gt;\.wslconfig</code>.</p><p>After creating the file, enter the following content and save it:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[experimental]</span><br><span class="hljs-attr">autoMemoryReclaim</span>=gradual <span class="hljs-comment"># gradual | dropcache | disabled</span><br><span class="hljs-attr">networkingMode</span>=mirrored<br><span class="hljs-attr">dnsTunneling</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">firewall</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">autoProxy</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>Then, open PowerShell and enter <code>wsl --shutdown</code>, andreopen WSL. The previous prompt should be gone.</p><h2 id="change-the-source-on-wsl-in-windows-11">Change the Source on WSLin Windows 11</h2><p>Just like a normal Ubuntu system, WSL uses foreign sources bydefault, which are inconvenient for us to use. Therefore, we can changeto domestic sources, and the method is the same as in the Ubuntusystem.</p><p>PS: Make sure to confirm the system version installed in WSL first.Here, the default installation is Ubuntu 22.04.3 LTS.</p><p><strong>Domestic Sources</strong></p><p>Tsinghua University:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># Default commented out source code mirror to improve apt update speed, uncomment if needed</span><br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><br><span class="hljs-comment"># Prerelease software source, not recommended to enable</span><br><span class="hljs-comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></code></pre></td></tr></table></figure><p>Alibaba Cloud:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-proposed main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-proposed main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>University of Science and Technology of China:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br>deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br>deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br>deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br>deb https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-proposed main restricted universe multiverse<br>deb-src https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>NetEase:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy-proposed main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy-proposed main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//mi</span>rrors.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>After choosing a domestic source, execute the following commands:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> upgrade<br></code></pre></td></tr></table></figure><h2 id="install-gcc-on-wsl-in-windows-11">Install gcc on WSL in Windows11</h2><p>Open WSL and run the following commands:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span> # Make sure apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-<span class="hljs-type">date</span>, <span class="hljs-keyword">as</span> it may report an error <span class="hljs-keyword">when</span> installing gcc<br>sudo apt install gcc<br></code></pre></td></tr></table></figure><h2 id="install-rust-on-wsl-in-windows-11">Install Rust on WSL inWindows 11</h2><p>Two commands are enough:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> rustc<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> cargo<br></code></pre></td></tr></table></figure><p>After the installation is complete, run <code>cargo version</code> inthe terminal.</p><p>If you see the following output, it means Rust has been installedsuccessfully.</p><figure><img src="/img/图片31.png" alt="image-20231126163636737" /><figcaption aria-hidden="true">image-20231126163636737</figcaption></figure><h2 id="install-remote-wsl-on-vs-code-in-windows-11">Install Remote-WSLon VS Code in Windows 11</h2><p>Currently, VS Code provides a plugin that allows you to connect toWSL2 from the Windows version of VS Code. This plugin is calledRemote-WSL.</p><figure><img src="/img/图片32.png" alt="image-20231126163800014" /><figcaption aria-hidden="true">image-20231126163800014</figcaption></figure><p>So, as long as you install this plugin in the Windows version of VSCode, you can connect to WSL2.</p><p>The first time you connect, you may need to wait for some time, as itneeds to perform some initialization work.</p><p>After the initialization is complete, click "Open Folder" to select afolder in WSL2.</p><figure><img src="/img/图片33.png" alt="image-20231126163942891" /><figcaption aria-hidden="true">image-20231126163942891</figcaption></figure><h2 id="install-rust-analyzer-on-vs-code-in-windows-11">Installrust-analyzer on VS Code in Windows 11</h2><p>After connecting VS Code to WSL, the installed plugins have two"versions": one for use on Windows, and one installed in WSL.</p><figure><img src="/img/图片34.png" alt="image-20231126164254143" /><figcaption aria-hidden="true">image-20231126164254143</figcaption></figure><p>Here, we only need one for now, which is rust-analyzer.</p><p>In the VS Code window connected to WSL, search for rust-analyzer andinstall the plugin.</p><h2 id="simple-verification">Simple Verification</h2><p>In WSL, navigate to any directory and enter<code>cargo init hello-world</code>.</p><p>Then, enter <code>code .</code> to open the Rust project in VSCode.</p><figure><img src="/img/图片35.png" alt="image-20231126164600855" /><figcaption aria-hidden="true">image-20231126164600855</figcaption></figure><p>In the VS Code terminal, run <code>cargo run</code> to verify if theenvironment is configured successfully. If successful, the output shouldlook like the following:</p><figure><img src="/img/图片36.png" alt="image-20231126164727968" /><figcaption aria-hidden="true">image-20231126164727968</figcaption></figure><p>At this point, the basic Rust environment has been set upsuccessfully.</p><h2 id="run-and-debug">Run and Debug</h2><figure><img src="/img/图片37.png" alt="image-20231126170853688" /><figcaption aria-hidden="true">image-20231126170853688</figcaption></figure><p>After entering <code>code .</code> in WSL to open VS Code, click the"Run" button in the top-left corner of the code editor to execute theprogram.</p><p>To debug, you need to install the CodeLLDB plugin.</p><p>After installing the plugin, you can use the debuggingfunctionality.</p><figure><img src="/img/图片38.png" alt="image-20231126171239141" /><figcaption aria-hidden="true">image-20231126171239141</figcaption></figure><p>Currently, the plugins installed on WSL are as follows:</p><figure><img src="/img/图片39.png" alt="image-20231126171146275" /><figcaption aria-hidden="true">image-20231126171146275</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Environment Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
      <tag>Rust</tag>
      
      <tag>VS Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Using Windows Proxy Settings in WSL2</title>
    <link href="/2024/03/11/WSL2-proxy/"/>
    <url>/2024/03/11/WSL2-proxy/</url>
    
    <content type="html"><![CDATA[<h1 id="setting-up-a-proxy-for-wsl2">Setting up a Proxy for WSL2</h1><p>WSL2 (Windows Subsystem for Linux 2) utilizes a virtual machineapproach, separating its network from Windows. This means that networktraffic no longer shares the same subnet as the Windows host, making itmore challenging to use the host's proxy settings.</p><h2 id="obtaining-the-host-ip-in-wsl">Obtaining the Host IP in WSL</h2><p>In WSL, the IP address changes with each reboot, so you cannot set astatic proxy. WSL2 writes the IP address to<code>/etc/resolv.conf</code>, allowing you to retrieve the host's IPusing the following command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/resolv.conf | grep nameserver | awk <span class="hljs-string">&#x27;&#123; print $2 &#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>To obtain WSL2's IP address, you can use:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostname -I | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="setting-up-the-proxy">Setting up the Proxy</h2><p>With the host's IP address, you can set up the proxy by exportingenvironment variables. Replace <code>&lt;Port&gt;</code> with yourproxy's port number, and don't forget to allow connections from thelocal network in your proxy software.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&#x27;http://&lt;Windows IP&gt;:&lt;Port&gt;&#x27;</span><br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&#x27;http://&lt;Windows IP&gt;:&lt;Port&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>However, this method requires you to reset the proxy every time yourestart the terminal, and you'll need to manually enter the IP address,which can be cumbersome. This is where a script comes in handy!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>hostip=$(<span class="hljs-built_in">cat</span> /etc/resolv.conf | grep nameserver | awk <span class="hljs-string">&#x27;&#123; print $2 &#125;&#x27;</span>)<br>wslip=$(hostname -I | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)<br>port=&lt;PORT&gt;<br><br>PROXY_HTTP=<span class="hljs-string">&quot;http://<span class="hljs-variable">$&#123;hostip&#125;</span>:<span class="hljs-variable">$&#123;port&#125;</span>&quot;</span><br><br><span class="hljs-function"><span class="hljs-title">set_proxy</span></span>()&#123;<br>    <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> HTTP_PROXY=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br><br>    <span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br>    <span class="hljs-built_in">export</span> HTTPS_proxy=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">unset_proxy</span></span>()&#123;<br>    <span class="hljs-built_in">unset</span> http_proxy<br>    <span class="hljs-built_in">unset</span> HTTP_PROXY<br>    <span class="hljs-built_in">unset</span> https_proxy<br>    <span class="hljs-built_in">unset</span> HTTPS_PROXY<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">test_setting</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Host ip:&quot;</span> <span class="hljs-variable">$&#123;hostip&#125;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;WSL ip:&quot;</span> <span class="hljs-variable">$&#123;wslip&#125;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Current proxy:&quot;</span> <span class="hljs-variable">$https_proxy</span><br>&#125;<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&quot;set&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    set_proxy<br><br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&quot;unset&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    unset_proxy<br><br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> = <span class="hljs-string">&quot;test&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    test_setting<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Unsupported arguments.&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>Remember to replace <code>&lt;PORT&gt;</code> on line 4 with yourproxy's port number!</p><p>If you want Git to use the proxy as well, add the following commandsto the <code>set_proxy</code> and <code>unset_proxy</code>functions:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">// Add proxy<br>git config --global http.proxy <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br>git config --global https.proxy <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PROXY_HTTP&#125;</span>&quot;</span><br><br>// Remove proxy<br>git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><p>After that, run <code>. ./proxy.sh set</code> to automatically setthe proxy. Use <code>unset</code> to cancel the proxy and<code>test</code> to check the proxy status and verify if theenvironment variables are correctly modified.</p><p>Remember to include the <code>.</code> before running the script(e.g., <code>. ./proxy.sh set</code> or<code>source ./proxy.sh set</code>). Running the script directly (e.g.,<code>./proxy.sh set</code> or <code>sh proxy.sh set</code>) willexecute it in a child shell, which won't affect the current shell'senvironment variables.</p><p>Additionally, you can add the following lines to your<code>~/.bashrc</code> file, replacing the paths with the location ofyour script:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> proxy=<span class="hljs-string">&quot;source /path/to/proxy.sh&quot;</span><br>. /path/to/proxy.sh <span class="hljs-built_in">set</span><br></code></pre></td></tr></table></figure><p>The first line sets an alias for the script, allowing you to use the<code>proxy</code> command from any directory to access the script'sfunctionality. The second line runs the script during shell startup,automatically setting the proxy without additional steps.</p><h2 id="firewall-settings">Firewall Settings</h2><p>If you've completed the previous steps and can already use the proxysuccessfully, you can skip this section. However, if the proxy iscorrectly set up, especially if you've allowed connections from thelocal network, but you still can't access the internet, and the proxysoftware isn't receiving requests, it's possible that the WindowsFirewall is blocking the connection.</p><p>Try pinging the host IP and using <code>telnet</code> to connect tothe proxy port to check if the connection is successful. If theconnection fails, it's likely a firewall issue.</p><p>You can try allowing the proxy software through the firewall in the"Allow an app or feature through Windows Defender Firewall" section ofthe Control Panel's firewall settings.</p><p>Alternatively, you can create an inbound rule in the AdvancedSettings. If you're unsure, you can allow any program using any protocoland permit inbound requests from the 172.16.0.0/12 and 192.168.0.0/16remote IP ranges.</p>]]></content>
    
    
    <categories>
      
      <category>Environment Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Installing Windows &amp; Linux Dual Boot System</title>
    <link href="/2024/03/11/Dual-System/"/>
    <url>/2024/03/11/Dual-System/</url>
    
    <content type="html"><![CDATA[<p>Ever found yourself torn between the sleek, user-friendly experienceof Windows and the robustness and open-source allure of Linux? Fret not,for you can have the best of both worlds with a seamless dual-bootsetup. In this comprehensive guide, we'll walk you through the intricateprocess of installing Windows and Linux on the same machine, unlocking arealm of endless possibilities and flexibility.</p><p>Imagine being able to seamlessly transition between operatingsystems, harnessing the power of Linux for development, servermanagement, or simply embracing its customizable nature, while stillhaving access to the familiarity and compatibility of Windows for dailytasks or gaming. With a dual-boot configuration, you'll no longer haveto compromise; instead, you'll wield the ultimate computing experiencetailored to your needs.</p><p>But installing a dual-boot system is no mere child's play; itrequires meticulous planning, attention to detail, and a deepunderstanding of partitioning and boot management. Fear not, for thisguide will hold your hand every step of the way, from crafting abootable USB drive to meticulously dividing your disk space andconfiguring boot options.</p><p>So, buckle up and prepare to embark on a journey that will transformyour computing paradigm, empowering you with the versatility and freedomto harness the capabilities of both Windows and Linux on a singlemachine. Get ready to unlock a world of endless possibilities andunleash your true potential as a power user.</p><h2 id="preparation-work">1. Preparation Work</h2><h3 id="creating-a-bootable-usb-drive">1.1 Creating a Bootable USBDrive</h3><p>Prepare a USB drive with 8GB or more capacity (4GB is sufficient).Back up any data on the drive as it will be formatted.</p><p>Next, go to the <a href="https://www.ubuntu.com/">Ubuntu</a> officialwebsite and download the desired ISO image file, typically Ubuntu 18 orUbuntu 16. If you're not comfortable with English, you can use theChrome browser which will automatically translate the webpage.</p><ol type="1"><li><ahref="https://www.ubuntu.com/download/desktop">https://www.ubuntu.com/download/desktop</a>// Download links for Ubuntu 18.04.2 and 19.04</li><li><ahref="http://releases.ubuntu.com/?_ga=2.132932682.518720393.1557799252-856679875.1557799252">http://releases.ubuntu.com/?_ga=2.132932682.518720393.1557799252-856679875.1557799252</a>// Other mirror download links</li></ol><p><img src="/img/图片1.jpg" /></p><p>Next, create the bootable USB drive using the <ahref="https://rufus.ie/">Rufus</a> tool.</p><p>After downloading Rufus, open it, select the downloaded ISO file, andit will automatically set the parameters. Click "Start" and wait for theprocess to complete.</p><p><img src="/img/图片2.jpg" /></p><p>If you see any prompt messages, select the default option.</p><p><img src="/img/图片3.jpg" /> <img src="/img/图片4.jpg" /></p><p>Detailed instructions are also available on the official website.Here's the <ahref="https://tutorials.ubuntu.com/tutorial/tutorial-create-a-usb-stick-on-windows?_ga=2.232393947.518720393.1557799252-856679875.1557799252#0">link</a>.If the link is broken, you can find it on the official website under thedownload section.</p><p><img src="/img/图片5.jpg" /></p><h3 id="allocating-disk-space">1.2 Allocating Disk Space</h3><p>Allocate a portion of your computer's hard drive for Ubuntuinstallation.</p><p>Press Windows + X and select "Disk Management," or right-click on "MyComputer" &gt; "Manage" &gt; "Disk Management."</p><p>Select a drive other than C: that has sufficient free space (100GB ormore). If possible, choose the last drive letter (E: if you have C, D,and E drives; F: if you have C, D, E, and F drives). Right-click on thedrive and select "Shrink Volume." Enter the desired amount of space youwant to allocate for the Ubuntu system. You can revisit this step laterafter learning about Ubuntu partitions and decide on the appropriatespace allocation based on your needs.</p><p><img src="/img/图片6.jpg" /></p><p>In my case, I had plenty of free space, so I allocated 600GB. You cansee a 600GB independent space that will be assigned to Ubuntu later.</p><p><img src="/img/图片7.jpg" /></p><h2 id="installing-ubuntu">2. Installing Ubuntu</h2><p>Insert the bootable USB drive you created earlier into your computerand press the hotkey during boot to enter the boot menu. You should seea prominent "Ubuntu" boot option; select it.</p><p>You'll then see the Ubuntu boot screen, followed by several options.The first two options are likely "Try Ubuntu" and "Install Ubuntu."Select "Install Ubuntu."</p><p><img src="/img/图片8.jpg" /></p><p>Prepare for the installation. If you have an internet connection,it's recommended to check the option to download updates.</p><p><img src="/img/图片9.jpg" /></p><p>Next, select the installation type. Choosing "Erase entire disk" willerase your existing Windows system, so select the "Something else"option to perform manual partitioning.</p><p><img src="/img/图片10.jpg" /></p><p>You should see several partitions on this screen, including the freespace you allocated earlier.</p><p><img src="/img/图片11.jpg" /></p><h3 id="partitioning">2.1 Partitioning</h3><p>Now, let's discuss partitioning. Partitioning involves dividing yourfree space into several sections, each with its ownresponsibilities.</p><p>Ubuntu Linux can mount partitions as directories. For a typical harddrive size (500GB-1000GB), the recommended directory allocation is asfollows:</p><table><thead><tr class="header"><th>Directory</th><th>Suggested Size</th><th>Format</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>/</td><td>150GB-200GB</td><td>ext4</td><td>Root directory</td></tr><tr class="even"><td>/tmp</td><td>Around 5GB</td><td>ext4</td><td>System temporary files, typically not saved after a system restart.(Required for server setup?)</td></tr><tr class="odd"><td>/boot</td><td>Around 1GB</td><td>ext4</td><td>System boot starting location. Recommended: Should be larger than400MB or 1GB. Linux kernel and boot system program files, such asvmlinuz and initrd.img, are located in this directory. In general, theGRUB or LILO system boot manager is also located here. Boot fileslocation, such as kernels, initrd, and grub.</td></tr><tr class="even"><td>/home</td><td>As large as possible</td><td>ext4</td><td>User working directory; personal configuration files, such asenvironment variables; each account is assigned a workingdirectory.</td></tr><tr class="odd"><td>swap</td><td>Twice the physical memory</td><td>Swap space</td><td>Swap space: Similar to "virtual memory" in Windows. If you have lowmemory (1-4GB), allocate twice the physical memory. For higher memory(8-16GB), set it equal to the physical memory or physical memory +2GB.</td></tr></tbody></table><p>/tmp is optional, and /boot can be 1GB. The root directory (/) and/home should be allocated more space, from tens to hundreds ofgigabytes, depending on your needs. When allocating space, it's best toallocate other partitions first and then allocate the swap space.</p><h3 id="partitioning-demonstration">2.2 Partitioning Demonstration</h3><p>Select your free space and click the "+" sign. First, allocate spacefor /boot.</p><p><img src="/img/图片12.jpg" /></p><p>There's a recommendation for dual-boot systems: If your computeralready has a primary partition-type boot loader, you can choose the"Logical Partition" for /boot. For a completely blank disk, /boot shouldbe set as a "Primary Partition." I haven't tried both methods, but thisshould be correct.</p><p>However, if you have a completely blank disk, you don't need topartition manually. You can simply choose the "Erase entire disk" optionat the beginning.</p><p><strong>Special Note: This article was written later, and I didn'tsave screenshots from when I installed Ubuntu. The images in thissection are taken from someone else's blog, where they allocated only300MB for /boot. My recommendation is still to allocate1GB.</strong></p><p>Click "+" again to allocate other partitions. The partition typeshould be "Logical Partition," and the location should be the startingposition of the free space. For the partition sizes, you can follow mysuggestions in the table below the red text.</p><p><img src="/img/图片13.jpg" /> <img src="/img/图片14.jpg" /></p><p>When allocating the swap space, remember to change the "Use as"option to "Swap Space."</p><p><img src="/img/图片15.jpg" /></p><h3 id="installation">2.3 Installation</h3><p>After partitioning is complete, prepare for the installation.</p><p>Select the partition corresponding to /boot for the "Device for bootloader installation." Confirm the details and click "Install."</p><p><img src="/img/图片16.jpg" /></p><p>Next, you'll go through some simple locale and language selectionsand create a user account. I won't cover those steps here.</p><p>Wait for the installation to complete...</p><p>After the installation is finished, you can check the partitions inWindows:</p><p><img src="/img/图片17.jpg" /></p><h2 id="modifying-boot-options">3. Modifying Boot Options</h2><p>After installing the dual-boot system, your computer may stilldefault to booting into Windows. If you want Ubuntu to be the defaultboot option, you'll need to modify the boot order.</p><p>In the Windows system, download the EasyBCD tool. Here's a link ifit's no longer available, you can search for it online.</p><p>Link: <ahref="https://pan.baidu.com/s/1slPiDZ3?pwd=z3r7">https://pan.baidu.com/s/1slPiDZ3</a>Password: z3r7</p><p><img src="/img/图片18.jpg" /> <img src="/img/图片19.jpg" /></p><p>Move the system you want to boot as the default to the top of thelist.</p><p><img src="/img/图片20.jpg" /></p><h2 id="uninstalling-the-windowslinux-dual-boot-system">Uninstalling theWindows+Linux Dual Boot System</h2><p>The following content is based on a post from <ahref="http://tieba.baidu.com/p/4485862313?see_lz=1">http://tieba.baidu.com/p/4485862313?see_lz=1</a>.</p><p>The post was visible a few days ago (as of May 14, 2019, 3:21:39 PM),but it suddenly disappeared. Fortunately, I found the Baidu cachedversion.</p><p>This section covers uninstalling Linux while keeping Windows(applicable to UEFI+GPT systems). For dual-boot installation, you canrefer to <ahref="https://blog.csdn.net/fanxueya1322/article/details/90205143">https://blog.csdn.net/fanxueya1322/article/details/90205143</a>.</p><h3 id="delete-ubuntu-partitions-in-windows">1. Delete Ubuntu Partitionsin Windows</h3><p>Press Windows + X to open Disk Management.</p><p>Windows is the key that looks like a flag next to the Alt key.</p><p><img src="/img/图片21.jpg" /></p><p>These are the partitions I created when installing Ubuntu.Right-click and delete each volume.</p><p><img src="/img/图片22.jpg" /></p><p>Restore the free space. In my case, I had originally shrunk the D:drive to create this 600GB space for Ubuntu. Select the D: drive,right-click, and select "Extend Volume" to restore it to its originalsize.</p><p><img src="/img/图片23.jpg" /></p><h3 id="removing-boot-entries">2. Removing Boot Entries</h3><p>After deleting all Ubuntu partitions and rebooting, the GRUBinterface is still present, but attempting to boot into Ubuntu fails.Next, you'll need to remove Ubuntu's boot files.</p><p>If you use the easyUEFI software to view the EFI boot entries, you'llfind that Ubuntu has written its EFI boot files to the Windows EFI bootpartition.</p><p><img src="/img/图片24.jpg" /> <img src="/img/图片25.jpg" /></p><p>If you only want to remove the boot files, you don't need to downloadeasyUEFI. It's just used to view the boot entries.</p><p>Here's how to remove the boot entries:</p><h4 id="mount-the-efi-partition">2.1 Mount the EFI Partition</h4><ol type="1"><li>Right-click on the Windows icon and select "Command Prompt(Admin)"<br /></li><li>Type "diskpart" and press Enter<br /></li><li>Type "list disk" to list all disks in the system<br /></li><li>Type "select disk 0" to select the disk containing the EFI bootpartition (adjust the disk number based on your system)<br /></li><li>Type "list partition" to list all partitions on the selecteddisk<br /></li><li>Type "select partition 1" to select the EFI boot partition (thepartition type should be "System")<br /></li><li>Type "assign letter=p" to assign a drive letter to the selectedpartition (use an available letter)</li></ol><p><img src="/img/图片26.jpg" /></p><h4 id="using-total-commander">2.2 Using Total Commander</h4><p>After mounting the EFI partition, you should see a new drive (P:) inMy Computer, but you won't have access permissions. Even running as anadministrator won't grant you access. What can you do?</p><p>We'll use a software called Total Commander. Search for it online,download, and install it. After installation, open the program (it'sfree for personal use) and follow the prompts.</p><p>Once open, select the P: drive.</p><p><img src="/img/图片27.jpg" /></p><p>Run Total Commander as an administrator.</p><p><img src="/img/图片28.jpg" /></p><p>Navigate to the EFI folder.</p><p><img src="/img/图片29.jpg" /></p><p>Select the Ubuntu folder (it should turn red), then press Shift +Delete to delete it.</p><p><img src="/img/图片30.jpg" /></p><p>Done!</p>]]></content>
    
    
    <categories>
      
      <category>Environment Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dotfiles多端同步</title>
    <link href="/2024/03/11/dotfiles%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5/"/>
    <url>/2024/03/11/dotfiles%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>在多台设备上管理dotfiles和应用程序(如Vim和Tmux)的配置可能是一项艰巨的任务。然而,通过以下几个简单步骤,您可以简化这一流程,在任何机器上实现一键配置。</p><ol type="1"><li><p><strong>版本控制:</strong>使用Git来跟踪您的dotfiles。创建一个Git仓库,并将您的配置文件存储在其中。这样可以让您管理文件版本并在不同机器之间同步设置。</p></li><li><p><strong>符号链接:</strong>在新机器上克隆您的dotfiles仓库,并创建指向这些文件的符号链接。这样,您就可以在仓库中保持文件位置,同时系统使用指向这些文件的符号链接。</p></li><li><p><strong>自动化脚本:</strong>编写一个安装脚本,当您在新机器上克隆仓库时,自动创建符号链接并安装必要的软件(如Vim和Tmux插件管理器)。</p></li><li><p><strong>插件管理器:</strong> 对于Vim,您可以使用<code>vim-plug</code>这样的插件管理器;对于Tmux,您可以使用<code>tpm</code>(Tmux PluginManager)。这样,您只需在配置文件中指定所需的插件,然后运行相应的命令自动安装它们。</p></li></ol><p>以下是设置和同步dotfiles、Vim和Tmux配置的简单分步指南:</p><h3 id="步骤1-设置git仓库">步骤1: 设置Git仓库</h3><p>在主机上,创建一个Git仓库来存储您的dotfiles:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">mkdir</span> dotfiles<br><span class="hljs-built_in">cd</span> dotfiles<br>git init<br></code></pre></td></tr></table></figure><p>将您的dotfiles移动到此目录并提交:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> .vimrc dotfiles/<br><span class="hljs-built_in">mv</span> .tmux.conf dotfiles/<br><span class="hljs-comment"># ...移动其他配置文件</span><br>git add .<br>git commit -m <span class="hljs-string">&quot;Add initial dotfiles&quot;</span><br></code></pre></td></tr></table></figure><h3 id="步骤2-创建符号链接">步骤2: 创建符号链接</h3><p>编写一个脚本自动创建指向dotfiles的符号链接:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>DOTFILES_DIR=~/dotfiles<br><br><span class="hljs-built_in">ln</span> -sf <span class="hljs-variable">$DOTFILES_DIR</span>/.vimrc ~/.vimrc<br><span class="hljs-built_in">ln</span> -sf <span class="hljs-variable">$DOTFILES_DIR</span>/.tmux.conf ~/.tmux.conf<br><span class="hljs-comment"># 为所有其他dotfiles重复上述步骤</span><br></code></pre></td></tr></table></figure><h3 id="步骤3-自动化脚本">步骤3: 自动化脚本</h3><p>创建一个安装脚本(如 <code>install.sh</code>)来设置新机器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 克隆dotfiles仓库</span><br>git <span class="hljs-built_in">clone</span> https://github.com/yourusername/dotfiles.git ~/dotfiles<br><br><span class="hljs-comment"># 运行创建符号链接的脚本</span><br>~/dotfiles/create_symlinks.sh<br><br><span class="hljs-comment"># 安装vim-plug插件管理器</span><br>curl -fLo ~/.vim/autoload/plug.vim --create-dirs \<br>https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim<br><br><span class="hljs-comment"># 安装Vim插件</span><br>vim +PlugInstall +qall<br><br><span class="hljs-comment"># 安装tpm (Tmux Plugin Manager)</span><br>git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm<br><br><span class="hljs-comment"># 安装Tmux插件</span><br>~/.tmux/plugins/tpm/bin/install_plugins<br></code></pre></td></tr></table></figure><p>确保您的 <code>install.sh</code> 和 <code>create_symlinks.sh</code>脚本具有可执行权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ~/dotfiles/install.sh<br><span class="hljs-built_in">chmod</span> +x ~/dotfiles/create_symlinks.sh<br></code></pre></td></tr></table></figure><h3 id="步骤4-同步到新机器">步骤4: 同步到新机器</h3><p>在新机器上,您只需克隆dotfiles仓库并运行安装脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/yourusername/dotfiles.git ~/dotfiles<br><span class="hljs-built_in">cd</span> ~/dotfiles<br>./install.sh<br></code></pre></td></tr></table></figure><p>这将设置您的环境并安装所有Vim和Tmux插件。</p><p>如果您的dotfiles包含敏感信息,请确保Git仓库是私有的。对于更复杂的设置,您可能需要在安装脚本中添加额外的逻辑,如安装依赖项、编译Vim(如需特定功能)或其他自定义设置。</p><p>通过这种方式,您可以在多台设备上无缝维护一致的开发环境,节省时间并确保工作流程的顺畅。</p><p>标题：跨设备轻松同步dotfiles与插件配置</p><p>在众多设备间管理dotfiles以及应用如Vim和Tmux的配置，往往让人感到繁琐。然而，遵循以下数个简单步骤，您可在任意设备上轻松实现一键部署配置。</p><p>版本控制：利用Git来追踪您的dotfiles。建立一个Git仓库，并将您的配置文件存放于其中。这样，您就可以轻松管理文件版本，并在不同设备间同步设置。</p><p>建立符号链接：在新设备上克隆dotfiles仓库，并针对这些文件创建符号链接。如此一来，文件在仓库中的位置保持不变，同时系统通过符号链接来使用这些文件。</p><p>编写自动化脚本：制作一个安装脚本，当您在新设备上克隆仓库时，它会自动创建符号链接并安装所需的软件（例如Vim和Tmux插件管理器）。</p><p>使用插件管理器：对于Vim，您可以采用像vim-plug这样的插件管理器；对于Tmux，可以使用tpm（TmuxPluginManager）。这样，您只需在配置文件中指定所需插件，然后运行相应命令即可自动安装。</p><p>以下是同步dotfiles、Vim与Tmux配置的分步指南：</p><p>第一步：搭建Git仓库 在主机上，创建用于存放dotfiles的Git仓库：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">mkdir</span> dotfiles<br><span class="hljs-built_in">cd</span> dotfiles<br>git init<br></code></pre></td></tr></table></figure> 将您的dotfiles移至此目录并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> .vimrc dotfiles/<br><span class="hljs-built_in">mv</span> .tmux.conf dotfiles/<br><span class="hljs-comment"># 移动其他配置文件...</span><br>git add .<br>git commit -m <span class="hljs-string">&quot;初始化dotfiles&quot;</span><br></code></pre></td></tr></table></figure><p>第二步：创建符号链接 编写一个脚本以自动创建指向dotfiles的符号链接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br> <br>DOTFILES_DIR=~/dotfiles<br> <br><span class="hljs-built_in">ln</span> -sf <span class="hljs-variable">$DOTFILES_DIR</span>/.vimrc ~/.vimrc<br><span class="hljs-built_in">ln</span> -sf <span class="hljs-variable">$DOTFILES_DIR</span>/.tmux.conf ~/.tmux.conf<br><span class="hljs-comment"># 对其他dotfiles重复以上操作</span><br></code></pre></td></tr></table></figure> 第三步：制作自动化安装脚本创建一个安装脚本（如install.sh），以便在新设备上快速设置： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br> <br><span class="hljs-comment"># 克隆dotfiles仓库</span><br>git <span class="hljs-built_in">clone</span> https://github.com/yourusername/dotfiles.git ~/dotfiles<br> <br><span class="hljs-comment"># 执行创建符号链接的脚本</span><br>~/dotfiles/create_symlinks.sh<br> <br><span class="hljs-comment"># 安装vim-plug插件管理器</span><br>curl -fLo ~/.vim/autoload/plug.vim --create-dirs \<br>https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim<br> <br><span class="hljs-comment"># 安装Vim插件</span><br>vim +PlugInstall +qall<br> <br><span class="hljs-comment"># 安装Tmux Plugin Manager</span><br>git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm<br> <br><span class="hljs-comment"># 安装Tmux插件</span><br>~/.tmux/plugins/tpm/bin/install_plugins<br></code></pre></td></tr></table></figure>确保install.sh和create_symlinks.sh脚本具备执行权限： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ~/dotfiles/install.sh<br><span class="hljs-built_in">chmod</span> +x ~/dotfiles/create_symlinks.sh<br></code></pre></td></tr></table></figure>第四步：在新设备上同步 在新设备上，只需克隆dotfiles仓库并运行安装脚本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/yourusername/dotfiles.git ~/dotfiles<br><span class="hljs-built_in">cd</span> ~/dotfiles<br>./install.sh<br></code></pre></td></tr></table></figure>执行以上操作后，您的开发环境即可设置完毕，所有Vim和Tmux插件也将安装就绪。</p><p>若dotfiles中含有敏感信息，请确保Git仓库保持私密状态。对于更为复杂的设置，您可能需要在安装脚本中加入额外的逻辑处理，例如安装依赖项、编译Vim（以支持特定功能）或其他自定义设置。</p><p>通过这种方法，您可以在多台设备上轻松维护统一且高效的开发环境，节省宝贵时间，确保工作流程的连贯性。</p>]]></content>
    
    
    <categories>
      
      <category>Environment Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effortless Cross-Device Configuration with Dotfiles and Plugins</title>
    <link href="/2024/03/11/config-dotfile/"/>
    <url>/2024/03/11/config-dotfile/</url>
    
    <content type="html"><![CDATA[<p>Managing dotfiles and configurations for applications like Vim andTmux across multiple devices can be a daunting task. However, with a fewsimple steps, you can streamline the process and achieve seamlessone-click configuration on any machine.</p><ol type="1"><li><p><strong>Version Control:</strong> Use Git to track your dotfiles.Create a Git repository and store your configuration files within it.This allows you to manage file versions and sync your setup acrossdifferent machines.</p></li><li><p><strong>Symbolic Links:</strong> Clone your dotfiles repositoryon a new machine and create symbolic links pointing to these files. Thisway, you can maintain the file locations within the repository while thesystem uses the symbolic links.</p></li><li><p><strong>Automation Script:</strong> Write an installation scriptthat, when you clone the repository on a new machine, automaticallycreates symbolic links and installs necessary software (like Vim andTmux plugin managers).</p></li><li><p><strong>Plugin Managers:</strong> For Vim, you can use a pluginmanager like <code>vim-plug</code>, and for Tmux, you can use a toollike <code>tpm</code> (Tmux Plugin Manager). This way, you only need tospecify the required plugins in your configuration files, and then runthe corresponding commands to automatically install them.</p></li></ol><p>Here's a simple step-by-step guide to setting up and synchronizingyour dotfiles, Vim, and Tmux configurations:</p><h3 id="step-1-set-up-git-repository">Step 1: Set Up Git Repository</h3><p>On your host machine, create a Git repository to store yourdotfiles:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">mkdir</span> dotfiles<br><span class="hljs-built_in">cd</span> dotfiles<br>git init<br></code></pre></td></tr></table></figure><p>Move your dotfiles to this directory and commit them:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> .vimrc dotfiles/<br><span class="hljs-built_in">mv</span> .tmux.conf dotfiles/<br><span class="hljs-comment"># ...move other configuration files</span><br>git add .<br>git commit -m <span class="hljs-string">&quot;Add initial dotfiles&quot;</span><br></code></pre></td></tr></table></figure><h3 id="step-2-create-symbolic-links">Step 2: Create Symbolic Links</h3><p>Write a script to automatically create symbolic links pointing toyour dotfiles:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>DOTFILES_DIR=~/dotfiles<br><br><span class="hljs-built_in">ln</span> -sf <span class="hljs-variable">$DOTFILES_DIR</span>/.vimrc ~/.vimrc<br><span class="hljs-built_in">ln</span> -sf <span class="hljs-variable">$DOTFILES_DIR</span>/.tmux.conf ~/.tmux.conf<br><span class="hljs-comment"># Repeat for all other dotfiles</span><br></code></pre></td></tr></table></figure><h3 id="step-3-automation-script">Step 3: Automation Script</h3><p>Create an installation script (e.g., <code>install.sh</code>) forsetting up a new machine:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># Clone dotfiles repository</span><br>git <span class="hljs-built_in">clone</span> https://github.com/yourusername/dotfiles.git ~/dotfiles<br><br><span class="hljs-comment"># Run the script to create symbolic links</span><br>~/dotfiles/create_symlinks.sh<br><br><span class="hljs-comment"># Install vim-plug plugin manager</span><br>curl -fLo ~/.vim/autoload/plug.vim --create-dirs \<br>https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim<br><br><span class="hljs-comment"># Install Vim plugins</span><br>vim +PlugInstall +qall<br><br><span class="hljs-comment"># Install tpm (Tmux Plugin Manager)</span><br>git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm<br><br><span class="hljs-comment"># Install Tmux plugins</span><br>~/.tmux/plugins/tpm/bin/install_plugins<br></code></pre></td></tr></table></figure><p>Make sure your <code>install.sh</code> and<code>create_symlinks.sh</code> scripts are executable:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ~/dotfiles/install.sh<br><span class="hljs-built_in">chmod</span> +x ~/dotfiles/create_symlinks.sh<br></code></pre></td></tr></table></figure><h3 id="step-4-sync-to-a-new-machine">Step 4: Sync to a New Machine</h3><p>On a new machine, you only need to clone your dotfiles repository andrun the installation script:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/yourusername/dotfiles.git ~/dotfiles<br><span class="hljs-built_in">cd</span> ~/dotfiles<br>./install.sh<br></code></pre></td></tr></table></figure><p>This will set up your environment and install all Vim and Tmuxplugins.</p><p>Ensure your Git repository is private if your dotfiles containsensitive information. For more complex setups, you may need to addadditional logic to the installation script, such as installingdependencies, compiling Vim (if specific features are required), orother customizations.</p><p>With this approach, you can effortlessly maintain a consistentdevelopment environment across multiple devices, saving time andensuring a seamless workflow.</p>]]></content>
    
    
    <categories>
      
      <category>Environment Configuration</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello, welcome.</title>
    <link href="/2023/10/02/hello-world/"/>
    <url>/2023/10/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hello, my name is Huoshuai. I hold a Master's degree in Signal andInformation Processing. My primary research area is remote sensing imageprocessing, particularly the application of optimization theories tofuse hyperspectral and multispectral images. Additionally, I havescholarly interests in computer vision within the frameworks of machinelearning and deep learning. I am also intrigued by natural languageprocessing and deep reinforcement learning, with a dedicated focus onimproving the interpretability of deep learning models.</p><p>Currently, I am working as an Algorithm Engineer at the ChongqingWestern Handwriting Big Data Research Institute, where I am responsiblefor the pen sequence restoration project.</p><p>Throughout my studies and research, I have developed a strongunderstanding of the latest techniques and technologies in these fields.I am continuously striving to expand my knowledge, and I am excitedabout the potential contributions of my work to the advancement of theseareas.</p><p>Thank you for taking the time to learn more about me. I look forwardto further exploring these topics and collaborating with others whoshare my passion for these fascinating fields.</p><!-- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).## Quick Start### Create a new post<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a>--&gt;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pandas处理缺失数据</title>
    <link href="/2023/10/01/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE/"/>
    <url>/2023/10/01/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas处理缺失数据">Pandas处理缺失数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="一缺失值的统计和删除">一、缺失值的统计和删除</h2><h3 id="缺失信息的统计">1. 缺失信息的统计</h3><p>缺失数据可以使用<code>isna</code>或<code>isnull</code>（两个函数没有区别）来查看每个单元格是否缺失，结合<code>mean</code>可以计算出每列缺失值的比例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>, usecols = [<span class="hljs-string">&#x27;Grade&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>, <span class="hljs-string">&#x27;Transfer&#x27;</span>])<br>df.isna().head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade</th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>0</th><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr><tr><th>1</th><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr><tr><th>2</th><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr><tr><th>3</th><td>False</td><td>False</td><td>False</td><td>True</td><td>False</td><td>False</td></tr><tr><th>4</th><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.isna().mean() <span class="hljs-comment"># 查看缺失的比例</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">Grade       0.000Name        0.000Gender      0.000Height      0.085Weight      0.055Transfer    0.060dtype: float64</code></pre><p>如果想要查看某一列缺失或者非缺失的行，可以利用<code>Series</code>上的<code>isna</code>或者<code>notna</code>进行布尔索引。例如，查看身高缺失的行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[df.Height.isna()].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade</th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>3</th><td>Sophomore</td><td>Xiaojuan Sun</td><td>Female</td><td>NaN</td><td>41.0</td><td>N</td></tr><tr><th>12</th><td>Senior</td><td>Peng You</td><td>Female</td><td>NaN</td><td>48.0</td><td>NaN</td></tr><tr><th>26</th><td>Junior</td><td>Yanli You</td><td>Female</td><td>NaN</td><td>48.0</td><td>N</td></tr><tr><th>36</th><td>Freshman</td><td>Xiaojuan Qin</td><td>Male</td><td>NaN</td><td>79.0</td><td>Y</td></tr><tr><th>60</th><td>Freshman</td><td>Yanpeng Lv</td><td>Male</td><td>NaN</td><td>65.0</td><td>N</td></tr></tbody></table></div><p>如果想要同时对几个列，检索出全部为缺失或者至少有一个缺失或者没有缺失的行，可以使用<code>isna, notna</code>和<code>any, all</code>的组合。例如，对身高、体重和转系情况这3列分别进行这三种情况的检索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sub_set = df[[<span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>, <span class="hljs-string">&#x27;Transfer&#x27;</span>]]<br>df[sub_set.isna().<span class="hljs-built_in">all</span>(<span class="hljs-number">1</span>)] <span class="hljs-comment"># 全部缺失</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade</th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>102</th><td>Junior</td><td>Chengli Zhao</td><td>Male</td><td>NaN</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[sub_set.isna().<span class="hljs-built_in">any</span>(<span class="hljs-number">1</span>)].head() <span class="hljs-comment"># 至少有一个缺失</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade</th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>3</th><td>Sophomore</td><td>Xiaojuan Sun</td><td>Female</td><td>NaN</td><td>41.0</td><td>N</td></tr><tr><th>9</th><td>Junior</td><td>Juan Xu</td><td>Female</td><td>164.8</td><td>NaN</td><td>N</td></tr><tr><th>12</th><td>Senior</td><td>Peng You</td><td>Female</td><td>NaN</td><td>48.0</td><td>NaN</td></tr><tr><th>21</th><td>Senior</td><td>Xiaopeng Shen</td><td>Male</td><td>166.0</td><td>62.0</td><td>NaN</td></tr><tr><th>26</th><td>Junior</td><td>Yanli You</td><td>Female</td><td>NaN</td><td>48.0</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[sub_set.notna().<span class="hljs-built_in">all</span>(<span class="hljs-number">1</span>)].head() <span class="hljs-comment"># 没有缺失</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade</th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>0</th><td>Freshman</td><td>Gaopeng Yang</td><td>Female</td><td>158.9</td><td>46.0</td><td>N</td></tr><tr><th>1</th><td>Freshman</td><td>Changqiang You</td><td>Male</td><td>166.5</td><td>70.0</td><td>N</td></tr><tr><th>2</th><td>Senior</td><td>Mei Sun</td><td>Male</td><td>188.9</td><td>89.0</td><td>N</td></tr><tr><th>4</th><td>Sophomore</td><td>Gaojuan You</td><td>Male</td><td>174.0</td><td>74.0</td><td>N</td></tr><tr><th>5</th><td>Freshman</td><td>Xiaoli Qian</td><td>Female</td><td>158.0</td><td>51.0</td><td>N</td></tr></tbody></table></div><h3 id="缺失信息的删除">2. 缺失信息的删除</h3><p>数据处理中经常需要根据缺失值的大小、比例或其他特征来进行行样本或列特征的删除，<code>pandas</code>中提供了<code>dropna</code>函数来进行操作。</p><p><code>dropna</code>的主要参数为轴方向<code>axis</code>（默认为0，即删除行）、删除方式<code>how</code>、删除的非缺失值个数阈值<code>thresh</code>（<spanclass="math inline">\(\color{red}{非缺失值}\)</span>没有达到这个数量的相应维度会被删除）、备选的删除子集<code>subset</code>，其中<code>how</code>主要有<code>any</code>和<code>all</code>两种参数可以选择。</p><p>例如，删除身高体重至少有一个缺失的行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = df.dropna(how = <span class="hljs-string">&#x27;any&#x27;</span>, subset = [<span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>])<br>res.shape<br></code></pre></td></tr></table></figure><pre><code class="hljs">(174, 6)</code></pre><p>例如，删除超过15个缺失值的列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = df.dropna(<span class="hljs-number">1</span>, thresh=df.shape[<span class="hljs-number">0</span>]-<span class="hljs-number">15</span>) <span class="hljs-comment"># 身高被删除</span><br>res.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade</th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>0</th><td>Freshman</td><td>Gaopeng Yang</td><td>Female</td><td>46.0</td><td>N</td></tr><tr><th>1</th><td>Freshman</td><td>Changqiang You</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>2</th><td>Senior</td><td>Mei Sun</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>3</th><td>Sophomore</td><td>Xiaojuan Sun</td><td>Female</td><td>41.0</td><td>N</td></tr><tr><th>4</th><td>Sophomore</td><td>Gaojuan You</td><td>Male</td><td>74.0</td><td>N</td></tr></tbody></table></div><p>当然，不用<code>dropna</code>同样是可行的，例如上述的两个操作，也可以使用布尔索引来完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = df.loc[df[[<span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>]].notna().<span class="hljs-built_in">all</span>(<span class="hljs-number">1</span>)]<br>res.shape<br></code></pre></td></tr></table></figure><pre><code class="hljs">(174, 6)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = df.loc[:, ~(df.isna().<span class="hljs-built_in">sum</span>()&gt;<span class="hljs-number">15</span>)]<br>res.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade</th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>0</th><td>Freshman</td><td>Gaopeng Yang</td><td>Female</td><td>46.0</td><td>N</td></tr><tr><th>1</th><td>Freshman</td><td>Changqiang You</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>2</th><td>Senior</td><td>Mei Sun</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>3</th><td>Sophomore</td><td>Xiaojuan Sun</td><td>Female</td><td>41.0</td><td>N</td></tr><tr><th>4</th><td>Sophomore</td><td>Gaojuan You</td><td>Male</td><td>74.0</td><td>N</td></tr></tbody></table></div><h2 id="二缺失值的填充和插值">二、缺失值的填充和插值</h2><h3 id="利用fillna进行填充">1. 利用fillna进行填充</h3><p>在<code>fillna</code>中有三个参数是常用的：<code>value, method, limit</code>。其中，<code>value</code>为填充值，可以是标量，也可以是索引到元素的字典映射；<code>method</code>为填充方法，有用前面的元素填充<code>ffill</code>和用后面的元素填充<code>bfill</code>两种类型，<code>limit</code>参数表示连续缺失值的最大填充次数。</p><p>下面构造一个简单的<code>Series</code>来说明用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([np.nan, <span class="hljs-number">1</span>, np.nan, np.nan, <span class="hljs-number">2</span>, np.nan], <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;aaabcd&#x27;</span>))<br>s<br></code></pre></td></tr></table></figure><pre><code class="hljs">a    NaNa    1.0a    NaNb    NaNc    2.0d    NaNdtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.fillna(method=<span class="hljs-string">&#x27;ffill&#x27;</span>) <span class="hljs-comment"># 用前面的值向后填充</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">a    NaNa    1.0a    1.0b    1.0c    2.0d    2.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.fillna(method=<span class="hljs-string">&#x27;ffill&#x27;</span>, limit=<span class="hljs-number">1</span>) <span class="hljs-comment"># 连续出现的缺失，最多填充一次</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">a    NaNa    1.0a    1.0b    NaNc    2.0d    2.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.fillna(s.mean()) <span class="hljs-comment"># value为标量</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">a    1.5a    1.0a    1.5b    1.5c    2.0d    1.5dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.fillna(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">200</span>&#125;) <span class="hljs-comment"># 通过索引映射填充的值</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">a    100.0a      1.0a    100.0b      NaNc      2.0d    200.0dtype: float64</code></pre><p>有时为了更加合理地填充，需要先进行分组后再操作。例如，根据年级进行身高的均值填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby(<span class="hljs-string">&#x27;Grade&#x27;</span>)[<span class="hljs-string">&#x27;Height&#x27;</span>].transform(<span class="hljs-keyword">lambda</span> x: x.fillna(x.mean())).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    158.9000001    166.5000002    188.9000003    163.0758624    174.000000Name: Height, dtype: float64</code></pre><h4 id="练一练">【练一练】</h4><p>对一个序列以如下规则填充缺失值：如果单独出现的缺失值，就用前后均值填充，如果连续出现的缺失值就不填充，即序列<code>[1, NaN, 3, NaN, NaN]</code>填充后为<code>[1, 2, 3, NaN, NaN]</code>，请利用<code>fillna</code>函数实现。（提示：利用<code>limit</code>参数）#### 【END】 ### 2. 插值函数</p><p>在关于<code>interpolate</code>函数的<ahref="https://pandas.pydata.org/docs/reference/api/pandas.Series.interpolate.html#pandas.Series.interpolate">文档</a>描述中，列举了许多插值法，包括了大量<code>Scipy</code>中的方法。由于很多插值方法涉及到比较复杂的数学知识，因此这里只讨论比较常用且简单的三类情况，即线性插值、最近邻插值和索引插值。</p><p>对于<code>interpolate</code>而言，除了插值方法（默认为<code>linear</code>线性插值）之外，有与<code>fillna</code>类似的两个常用参数，一个是控制方向的<code>limit_direction</code>，另一个是控制最大连续缺失值插值个数的<code>limit</code>。其中，限制插值的方向默认为<code>forward</code>，这与<code>fillna</code>的<code>method</code>中的<code>ffill</code>是类似的，若想要后向限制插值或者双向限制插值可以指定为<code>backward</code>或<code>both</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([np.nan, np.nan, <span class="hljs-number">1</span>, np.nan, np.nan, np.nan, <span class="hljs-number">2</span>, np.nan, np.nan])<br>s.values<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([nan, nan,  1., nan, nan, nan,  2., nan, nan])</code></pre><p>例如，在默认线性插值法下分别进行<code>backward</code>和双向限制插值，同时限制最大连续条数为1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = s.interpolate(limit_direction=<span class="hljs-string">&#x27;backward&#x27;</span>, limit=<span class="hljs-number">1</span>)<br>res.values<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ nan, 1.  , 1.  ,  nan,  nan, 1.75, 2.  ,  nan,  nan])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = s.interpolate(limit_direction=<span class="hljs-string">&#x27;both&#x27;</span>, limit=<span class="hljs-number">1</span>)<br>res.values<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ nan, 1.  , 1.  , 1.25,  nan, 1.75, 2.  , 2.  ,  nan])</code></pre><p>第二种常见的插值是最近邻插补，即缺失值的元素和离它最近的非缺失值元素一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.interpolate(<span class="hljs-string">&#x27;nearest&#x27;</span>).values<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([nan, nan,  1.,  1.,  1.,  2.,  2., nan, nan])</code></pre><p>最后来介绍索引插值，即根据索引大小进行线性插值。例如，构造不等间距的索引进行演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">0</span>,np.nan,<span class="hljs-number">10</span>],index=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>])<br>s<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      0.01      NaN10    10.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.interpolate() <span class="hljs-comment"># 默认的线性插值，等价于计算中点的值</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0      0.01      5.010    10.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.interpolate(method=<span class="hljs-string">&#x27;index&#x27;</span>) <span class="hljs-comment"># 和索引有关的线性插值，计算相应索引大小对应的值</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0      0.01      1.010    10.0dtype: float64</code></pre><p>同时，这种方法对于时间戳索引也是可以使用的，有关时间序列的其他话题会在第十章进行讨论，这里举一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">0</span>,np.nan,<span class="hljs-number">10</span>], index=pd.to_datetime([<span class="hljs-string">&#x27;20200101&#x27;</span>, <span class="hljs-string">&#x27;20200102&#x27;</span>, <span class="hljs-string">&#x27;20200111&#x27;</span>]))<br>s<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01     0.02020-01-02     NaN2020-01-11    10.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.interpolate()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01     0.02020-01-02     5.02020-01-11    10.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.interpolate(method=<span class="hljs-string">&#x27;index&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01     0.02020-01-02     1.02020-01-11    10.0dtype: float64</code></pre><h4id="note关于polynomial和spline插值的注意事项">【NOTE】关于polynomial和spline插值的注意事项</h4><p>在<code>interpolate</code>中如果选用<code>polynomial</code>的插值方法，它内部调用的是<code>scipy.interpolate.interp1d(*,*,kind=order)</code>，这个函数内部调用的是<code>make_interp_spline</code>方法，因此其实是样条插值而不是类似于<code>numpy</code>中的<code>polyfit</code>多项式拟合插值；而当选用<code>spline</code>方法时，<code>pandas</code>调用的是<code>scipy.interpolate.UnivariateSpline</code>而不是普通的样条插值。这一部分的文档描述比较混乱，而且这种参数的设计也是不合理的，当使用这两类插值方法时，用户一定要小心谨慎地根据自己的实际需求选取恰当的插值方法。#### 【END】 ## 三、Nullable类型 ### 1. 缺失记号及其缺陷</p><p>在<code>python</code>中的缺失值用<code>None</code>表示，该元素除了等于自己本身之外，与其他任何元素不相等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">None</span> == <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">None</span> == <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">None</span> == []<br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">None</span> == <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><p>在<code>numpy</code>中利用<code>np.nan</code>来表示缺失值，该元素除了不和其他任何元素相等之外，和自身的比较结果也返回<code>False</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nan == np.nan<br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nan == <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nan == <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><p>值得注意的是，虽然在对缺失序列或表格的元素进行比较操作的时候，<code>np.nan</code>的对应位置会返回<code>False</code>，但是在使用<code>equals</code>函数进行两张表或两个序列的相同性检验时，会自动跳过两侧表都是缺失值的位置，直接返回<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = pd.Series([<span class="hljs-number">1</span>, np.nan])<br>s2 = pd.Series([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>s3 = pd.Series([<span class="hljs-number">1</span>, np.nan])<br>s1 == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1    Falsedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s1.equals(s2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s1.equals(s3)<br></code></pre></td></tr></table></figure><pre><code class="hljs">True</code></pre><p>在时间序列的对象中，<code>pandas</code>利用<code>pd.NaT</code>来指代缺失值，它的作用和<code>np.nan</code>是一致的（时间序列的对象和构造将在第十章讨论）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.to_timedelta([<span class="hljs-string">&#x27;30s&#x27;</span>, np.nan]) <span class="hljs-comment"># Timedelta中的NaT</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">TimedeltaIndex([&#39;0 days 00:00:30&#39;, NaT], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.to_datetime([<span class="hljs-string">&#x27;20200101&#x27;</span>, np.nan]) <span class="hljs-comment"># Datetime中的NaT</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01&#39;, &#39;NaT&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>那么为什么要引入<code>pd.NaT</code>来表示时间对象中的缺失呢？仍然以<code>np.nan</code>的形式存放会有什么问题？在<code>pandas</code>中可以看到<code>object</code>类型的对象，而<code>object</code>是一种混杂对象类型，如果出现了多个类型的元素同时存储在<code>Series</code>中，它的类型就会变成<code>object</code>。例如，同时存放整数和字符串的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      11    twodtype: object</code></pre><p><code>NaT</code>问题的根源来自于<code>np.nan</code>的本身是一种浮点类型，而如果浮点和时间类型混合存储，如果不设计新的内置缺失类型来处理，就会变成含糊不清的<code>object</code>类型，这显然是不希望看到的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">type</span>(np.nan)<br></code></pre></td></tr></table></figure><pre><code class="hljs">float</code></pre><p>同时，由于<code>np.nan</code>的浮点性质，如果在一个整数的<code>Series</code>中出现缺失，那么其类型会转变为<code>float64</code>；而如果在一个布尔类型的序列中出现缺失，那么其类型就会转为<code>object</code>而不是<code>bool</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([<span class="hljs-number">1</span>, np.nan]).dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype(&#39;float64&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, np.nan]).dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype(&#39;O&#39;)</code></pre><p>因此，在进入<code>1.0.0</code>版本后，<code>pandas</code>尝试设计了一种新的缺失类型<code>pd.NA</code>以及三种<code>Nullable</code>序列类型来应对这些缺陷，它们分别是<code>Int, boolean</code>和<code>string</code>。</p><h3 id="nullable类型的性质">2. Nullable类型的性质</h3><p>从字面意义上看<code>Nullable</code>就是可空的，言下之意就是序列类型不受缺失值的影响。例如，在上述三个<code>Nullable</code>类型中存储缺失值，都会转为<code>pandas</code>内置的<code>pd.NA</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([np.nan, <span class="hljs-number">1</span>], dtype = <span class="hljs-string">&#x27;Int64&#x27;</span>) <span class="hljs-comment"># &quot;i&quot;是大写的</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    &lt;NA&gt;1       1dtype: Int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([np.nan, <span class="hljs-literal">True</span>], dtype = <span class="hljs-string">&#x27;boolean&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    &lt;NA&gt;1    Truedtype: boolean</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([np.nan, <span class="hljs-string">&#x27;my_str&#x27;</span>], dtype = <span class="hljs-string">&#x27;string&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      &lt;NA&gt;1    my_strdtype: string</code></pre><p>在<code>Int</code>的序列中，返回的结果会尽可能地成为<code>Nullable</code>的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([np.nan, <span class="hljs-number">0</span>], dtype = <span class="hljs-string">&#x27;Int64&#x27;</span>) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    &lt;NA&gt;1       1dtype: Int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([np.nan, <span class="hljs-number">0</span>], dtype = <span class="hljs-string">&#x27;Int64&#x27;</span>) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    &lt;NA&gt;1    Truedtype: boolean</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series([np.nan, <span class="hljs-number">0</span>], dtype = <span class="hljs-string">&#x27;Int64&#x27;</span>) * <span class="hljs-number">0.5</span> <span class="hljs-comment"># 只能是浮点</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    NaN1    0.0dtype: float64</code></pre><p>对于<code>boolean</code>类型的序列而言，其和<code>bool</code>序列的行为主要有两点区别：</p><p>第一点是带有缺失的布尔列表无法进行索引器中的选择，而<code>boolean</code>会把缺失值看作<code>False</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>])<br>s_bool = pd.Series([<span class="hljs-literal">True</span>, np.nan])<br>s_boolean = pd.Series([<span class="hljs-literal">True</span>, np.nan]).astype(<span class="hljs-string">&#x27;boolean&#x27;</span>)<br><span class="hljs-comment"># s[s_bool] # 报错</span><br>s[s_boolean]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    adtype: object</code></pre><p>第二点是在进行逻辑运算时，<code>bool</code>类型在缺失处返回的永远是<code>False</code>，而<code>boolean</code>会根据逻辑运算是否能确定唯一结果来返回相应的值。那什么叫能否确定唯一结果呢？举个简单例子：<code>True | pd.NA</code>中无论缺失值为什么值，必然返回<code>True</code>；<code>False | pd.NA</code>中的结果会根据缺失值取值的不同而变化，此时返回<code>pd.NA</code>；<code>False &amp; pd.NA</code>中无论缺失值为什么值，必然返回<code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s_boolean &amp; <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    True1    &lt;NA&gt;dtype: boolean</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s_boolean | <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    True1    Truedtype: boolean</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">~s_boolean <span class="hljs-comment"># 取反操作同样是无法唯一地判断缺失结果</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1     &lt;NA&gt;dtype: boolean</code></pre><p>关于<code>string</code>类型的具体性质将在下一章文本数据中进行讨论。</p><p>一般在实际数据处理时，可以在数据集读入后，先通过<code>convert_dtypes</code>转为<code>Nullable</code>类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>)<br>df = df.convert_dtypes()<br>df.dtypes<br></code></pre></td></tr></table></figure><pre><code class="hljs">School          stringGrade           stringName            stringGender          stringHeight         float64Weight           Int64Transfer        stringTest_Number      Int64Test_Date       stringTime_Record     stringdtype: object</code></pre><h3 id="缺失数据的计算和分组">3. 缺失数据的计算和分组</h3><p>当调用函数<code>sum, prod</code>使用加法和乘法的时候，缺失数据等价于被分别视作0和1，即不改变原来的计算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,np.nan,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>s.<span class="hljs-built_in">sum</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">14.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.prod()<br></code></pre></td></tr></table></figure><pre><code class="hljs">120.0</code></pre><p>当使用累计函数时，会自动跳过缺失值所处的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.cumsum()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     2.01     5.02     NaN3     9.04    14.0dtype: float64</code></pre><p>当进行单个标量运算的时候，除了<code>np.nan ** 0</code>和<code>1 ** np.nan</code>这两种情况为确定的值之外，所有运算结果全为缺失（<code>pd.NA</code>的行为与此一致），并且<code>np.nan</code>在比较操作时一定返回<code>False</code>，而<code>pd.NA</code>返回<code>pd.NA</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nan == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.NA == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;NA&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nan &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.NA &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;NA&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nan + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">nan</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.log(np.nan)<br></code></pre></td></tr></table></figure><pre><code class="hljs">nan</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.add(np.nan, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">nan</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nan ** <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">1.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.NA ** <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> ** np.nan<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> ** pd.NA<br></code></pre></td></tr></table></figure><pre><code class="hljs">1</code></pre><p>另外需要注意的是，<code>diff, pct_change</code>这两个函数虽然功能相似，但是对于缺失的处理不同，前者凡是参与缺失计算的部分全部设为了缺失值，而后者缺失值位置会被设为0% 的变化率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.diff()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    NaN1    1.02    NaN3    NaN4    1.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.pct_change()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0         NaN1    0.5000002    0.0000003    0.3333334    0.250000dtype: float64</code></pre><p>对于一些函数而言，缺失可以作为一个类别处理，例如在<code>groupby, get_dummies</code>中可以设置相应的参数来进行增加缺失类别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_nan = pd.DataFrame(&#123;<span class="hljs-string">&#x27;category&#x27;</span>:[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,np.nan,np.nan], <span class="hljs-string">&#x27;value&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]&#125;)<br>df_nan<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>category</th><th>value</th></tr></thead><tbody><tr><th>0</th><td>a</td><td>1</td></tr><tr><th>1</th><td>a</td><td>3</td></tr><tr><th>2</th><td>b</td><td>5</td></tr><tr><th>3</th><td>NaN</td><td>7</td></tr><tr><th>4</th><td>NaN</td><td>9</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_nan.groupby(<span class="hljs-string">&#x27;category&#x27;</span>, dropna=<span class="hljs-literal">False</span>)[<span class="hljs-string">&#x27;value&#x27;</span>].mean() <span class="hljs-comment"># pandas版本大于1.1.0</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">categorya      2b      5NaN    8Name: value, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.get_dummies(df_nan.category, dummy_na=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>a</th><th>b</th><th>NaN</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>0</td><td>0</td></tr><tr><th>1</th><td>1</td><td>0</td><td>0</td></tr><tr><th>2</th><td>0</td><td>1</td><td>0</td></tr><tr><th>3</th><td>0</td><td>0</td><td>1</td></tr><tr><th>4</th><td>0</td><td>0</td><td>1</td></tr></tbody></table></div><h2 id="四练习">四、练习</h2><h3 id="ex1缺失值与类别的相关性检验">Ex1：缺失值与类别的相关性检验</h3><p>在数据处理中，含有过多缺失值的列往往会被删除，除非缺失情况与标签强相关。下面有一份关于二分类问题的数据集，其中<code>X_1, X_2</code>为特征变量，<code>y</code>为二分类标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/missing_chi.csv&#x27;</span>)<br>df.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>X_1</th><th>X_2</th><th>y</th></tr></thead><tbody><tr><th>0</th><td>NaN</td><td>NaN</td><td>0</td></tr><tr><th>1</th><td>NaN</td><td>NaN</td><td>0</td></tr><tr><th>2</th><td>NaN</td><td>NaN</td><td>0</td></tr><tr><th>3</th><td>43.0</td><td>NaN</td><td>0</td></tr><tr><th>4</th><td>NaN</td><td>NaN</td><td>0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.isna().mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">X_1    0.855X_2    0.894y      0.000dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.y.value_counts(normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    0.9181    0.082Name: y, dtype: float64</code></pre><p>事实上，有时缺失值出现或者不出现本身就是一种特征，并且在一些场合下可能与标签的正负是相关的。关于缺失出现与否和标签的正负性，在统计学中可以利用卡方检验来断言它们是否存在相关性。按照特征缺失的正例、特征缺失的负例、特征不缺失的正例、特征不缺失的负例，可以分为四种情况，设它们分别对应的样例数为<spanclass="math inline">\(n_{11}, n_{10}, n_{01},n_{00}\)</span>。假若它们是不相关的，那么特征缺失中正例的理论值，就应该接近于特征缺失总数<spanclass="math inline">\(\times\)</span>总体正例的比例，即：</p><p><span class="math display">\[E_{11} = n_{11} \approx(n_{11}+n_{10})\times\frac{n_{11}+n_{01}}{n_{11}+n_{10}+n_{01}+n_{00}} =F_{11}\]</span></p><p>其他的三种情况同理。现将实际值和理论值分别记作<spanclass="math inline">\(E_{ij},F_{ij}\)</span>，那么希望下面的统计量越小越好，即代表实际值接近不相关情况的理论值：</p><p><span class="math display">\[S = \sum_{i\in \{0,1\}}\sum_{j\in\{0,1\}} \frac{(E_{ij}-F_{ij})^2}{F_{ij}}\]</span></p><p>可以证明上面的统计量近似服从自由度为<spanclass="math inline">\(1\)</span>的卡方分布，即<spanclass="math inline">\(S\overset{\cdot}{\sim}\chi^2(1)\)</span>。因此，可通过计算<spanclass="math inline">\(P(\chi^2(1)&gt;S)\)</span>的概率来进行相关性的判别，一般认为当此概率小于<spanclass="math inline">\(0.05\)</span>时缺失情况与标签正负存在相关关系，即不相关条件下的理论值与实际值相差较大。</p><p>上面所说的概率即为统计学上关于<spanclass="math inline">\(2\times2\)</span>列联表检验问题的<spanclass="math inline">\(p\)</span>值，它可以通过<code>scipy.stats.chi2.sf(S, 1)</code>得到。请根据上面的材料，分别对<code>X_1, X_2</code>列进行检验。</p><h3 id="ex2用回归模型解决分类问题">Ex2：用回归模型解决分类问题</h3><p><code>KNN</code>是一种监督式学习模型，既可以解决回归问题，又可以解决分类问题。对于分类变量，利用<code>KNN</code>分类模型可以实现其缺失值的插补，思路是度量缺失样本的特征与所有其他样本特征的距离，当给定了模型参数<code>n_neighbors=n</code>时，计算离该样本距离最近的<spanclass="math inline">\(n\)</span>个样本点中最多的那个类别，并把这个类别作为该样本的缺失预测类别，具体如下图所示，未知的类别被预测为黄色：</p><p><img src="../source/_static/ch7_ex.png" width="25%"></p><p>上面有色点的特征数据提供如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_excel(<span class="hljs-string">&#x27;../data/color.xlsx&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>X1</th><th>X2</th><th>Color</th></tr></thead><tbody><tr><th>0</th><td>-2.5</td><td>2.8</td><td>Blue</td></tr><tr><th>1</th><td>-1.5</td><td>1.8</td><td>Blue</td></tr><tr><th>2</th><td>-0.8</td><td>2.8</td><td>Blue</td></tr></tbody></table></div><p>已知待预测的样本点为<span class="math inline">\(X_1=0.8,X_2=-0.2\)</span>，那么预测类别可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>clf = KNeighborsClassifier(n_neighbors=<span class="hljs-number">6</span>)<br>clf.fit(df.iloc[:,:<span class="hljs-number">2</span>], df.Color)<br>clf.predict([[<span class="hljs-number">0.8</span>, -<span class="hljs-number">0.2</span>]])<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([&#39;Yellow&#39;], dtype=object)</code></pre><ol type="1"><li>对于回归问题而言，需要得到的是一个具体的数值，因此预测值由最近的<spanclass="math inline">\(n\)</span>个样本对应的平均值获得。请把上面的这个分类问题转化为回归问题，仅使用<code>KNeighborsRegressor</code>来完成上述的<code>KNeighborsClassifier</code>功能。</li><li>请根据第1问中的方法，对<code>audit</code>数据集中的<code>Employment</code>变量进行缺失值插补。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/audit.csv&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>ID</th><th>Age</th><th>Employment</th><th>Marital</th><th>Income</th><th>Gender</th><th>Hours</th></tr></thead><tbody><tr><th>0</th><td>1004641</td><td>38</td><td>Private</td><td>Unmarried</td><td>81838.00</td><td>Female</td><td>72</td></tr><tr><th>1</th><td>1010229</td><td>35</td><td>Private</td><td>Absent</td><td>72099.00</td><td>Male</td><td>30</td></tr><tr><th>2</th><td>1024587</td><td>32</td><td>Private</td><td>Divorced</td><td>154676.74</td><td>Male</td><td>40</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础</title>
    <link href="/2023/10/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/10/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="预备知识">预备知识</h1><h2 id="一python基础">一、Python基础</h2><h3 id="列表推导式与条件赋值">1. 列表推导式与条件赋值</h3><p>在生成一个数字序列的时候，在<code>Python</code>中可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">L = []<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    L.append(my_func(i))<br>L<br></code></pre></td></tr></table></figure><pre><code class="hljs">[0, 2, 4, 6, 8]</code></pre><p>事实上可以利用列表推导式进行写法上的简化：<code>[* for i in *]</code>。其中，第一个<code>*</code>为映射函数，其输入为后面<code>i</code>指代的内容，第二个<code>*</code>表示迭代的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[my_func(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br></code></pre></td></tr></table></figure><pre><code class="hljs">[0, 2, 4, 6, 8]</code></pre><p>列表表达式还支持多层嵌套，如下面的例子中第一个<code>for</code>为外层循环，第二个为内层循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[m+<span class="hljs-string">&#x27;_&#x27;</span>+n <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]]<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;a_c&#39;, &#39;a_d&#39;, &#39;b_c&#39;, &#39;b_d&#39;]</code></pre><p>除了列表推导式，另一个实用的语法糖是带有<code>if</code>选择的条件赋值，其形式为<code>value = a if condition else b</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">value = <span class="hljs-string">&#x27;cat&#x27;</span> <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;dog&#x27;</span><br>value<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;cat&#39;</code></pre><p>等价于如下的写法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b = <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span><br>condition = <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> <span class="hljs-comment"># 此时为True</span><br><span class="hljs-keyword">if</span> condition:<br>    value = a<br><span class="hljs-keyword">else</span>:<br>    value = b<br></code></pre></td></tr></table></figure></p><p>下面举一个例子，截断列表中超过5的元素，即超过5的用5代替，小于5的保留原来的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">L = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br>[i <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">5</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> L]<br></code></pre></td></tr></table></figure><pre><code class="hljs">[1, 2, 3, 4, 5, 5, 5]</code></pre><h3 id="匿名函数与map方法">2. 匿名函数与map方法</h3><p>有一些函数的定义具有清晰简单的映射关系，例如上面的<code>my_func</code>函数，这时候可以用匿名函数的方法简洁地表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_func = <span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span>*x<br>my_func(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">6</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">multi_para_func = <span class="hljs-keyword">lambda</span> a, b: a + b<br>multi_para_func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br></code></pre></td></tr></table></figure><pre><code class="hljs">3</code></pre><p>但上面的用法其实违背了“匿名”的含义，事实上它往往在无需多处调用的场合进行使用，例如上面列表推导式中的例子，用户不关心函数的名字，只关心这种映射的关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span>*x)(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br></code></pre></td></tr></table></figure><pre><code class="hljs">[0, 2, 4, 6, 8]</code></pre><p>对于上述的这种列表推导式的匿名函数映射，<code>Python</code>中提供了<code>map</code>函数来完成，它返回的是一个<code>map</code>对象，需要通过<code>list</code>转为列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span>*x, <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[0, 2, 4, 6, 8]</code></pre><p>对于多个输入值的函数映射，可以通过追加迭代对象实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: <span class="hljs-built_in">str</span>(x)+<span class="hljs-string">&#x27;_&#x27;</span>+y, <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>), <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcde&#x27;</span>)))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;0_a&#39;, &#39;1_b&#39;, &#39;2_c&#39;, &#39;3_d&#39;, &#39;4_e&#39;]</code></pre><h3 id="zip对象与enumerate方法">3. zip对象与enumerate方法</h3><p><code>zip</code>函数能够把多个可迭代对象打包成一个元组构成的可迭代对象，它返回了一个<code>zip</code>对象，通过<code>tuple</code>,<code>list</code>可以得到相应的打包结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">L1, L2, L3 = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abc&#x27;</span>), <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;def&#x27;</span>), <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;hij&#x27;</span>)<br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(L1, L2, L3))<br></code></pre></td></tr></table></figure><pre><code class="hljs">[(&#39;a&#39;, &#39;d&#39;, &#39;h&#39;), (&#39;b&#39;, &#39;e&#39;, &#39;i&#39;), (&#39;c&#39;, &#39;f&#39;, &#39;j&#39;)]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">zip</span>(L1, L2, L3))<br></code></pre></td></tr></table></figure><pre><code class="hljs">((&#39;a&#39;, &#39;d&#39;, &#39;h&#39;), (&#39;b&#39;, &#39;e&#39;, &#39;i&#39;), (&#39;c&#39;, &#39;f&#39;, &#39;j&#39;))</code></pre><p>往往会在循环迭代的时候使用到<code>zip</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, j, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(L1, L2, L3):<br>     <span class="hljs-built_in">print</span>(i, j, k)<br></code></pre></td></tr></table></figure><pre><code class="hljs">a d hb e ic f j</code></pre><p><code>enumerate</code>是一种特殊的打包，它可以在迭代时绑定迭代元素的遍历序号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">L = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>)<br><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(L):<br>     <span class="hljs-built_in">print</span>(index, value)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0 a1 b2 c3 d</code></pre><p>用<code>zip</code>对象也能够简单地实现这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(L)), L):<br>     <span class="hljs-built_in">print</span>(index, value)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0 a1 b2 c3 d</code></pre><p>当需要对两个列表建立字典映射时，可以利用<code>zip</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(L1, L2))<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#123;&#39;a&#39;: &#39;d&#39;, &#39;b&#39;: &#39;e&#39;, &#39;c&#39;: &#39;f&#39;&#125;</code></pre><p>既然有了压缩函数，那么<code>Python</code>也提供了<code>*</code>操作符和<code>zip</code>联合使用来进行解压操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">zipped = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(L1, L2, L3))<br>zipped<br></code></pre></td></tr></table></figure><pre><code class="hljs">[(&#39;a&#39;, &#39;d&#39;, &#39;h&#39;), (&#39;b&#39;, &#39;e&#39;, &#39;i&#39;), (&#39;c&#39;, &#39;f&#39;, &#39;j&#39;)]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*zipped)) <span class="hljs-comment"># 三个元组分别对应原来的列表</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">[(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;d&#39;, &#39;e&#39;, &#39;f&#39;), (&#39;h&#39;, &#39;i&#39;, &#39;j&#39;)]</code></pre><h2 id="二numpy基础">二、Numpy基础</h2><h3 id="np数组的构造">1. np数组的构造</h3><p>最一般的方法是通过<code>array</code>来构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 2, 3])</code></pre><p>下面讨论一些特殊数组的生成方式：</p><p>【a】等差序列：<code>np.linspace</code>, <code>np.arange</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">11</span>) <span class="hljs-comment"># 起始、终止（包含）、样本个数</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1. , 1.4, 1.8, 2.2, 2.6, 3. , 3.4, 3.8, 4.2, 4.6, 5. ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 起始、终止（不包含）、步长</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 3])</code></pre><p>【b】特殊矩阵：<code>zeros</code>, <code>eye</code>,<code>full</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 传入元组表示各维度大小</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 0., 0.],       [0., 0., 0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.eye(<span class="hljs-number">3</span>) <span class="hljs-comment"># 3*3的单位矩阵</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1., 0., 0.],       [0., 1., 0.],       [0., 0., 1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.eye(<span class="hljs-number">3</span>, k=<span class="hljs-number">1</span>) <span class="hljs-comment"># 偏移主对角线1个单位的伪单位矩阵</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 1., 0.],       [0., 0., 1.],       [0., 0., 0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.full((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), <span class="hljs-number">10</span>) <span class="hljs-comment"># 元组传入大小，10表示填充数值</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[10, 10, 10],       [10, 10, 10]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.full((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment"># 每行填入相同的列表</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1, 2, 3],       [1, 2, 3]])</code></pre><p>【c】随机矩阵：<code>np.random</code></p><p>最常用的随机生成函数为<code>rand</code>, <code>randn</code>,<code>randint</code>,<code>choice</code>，它们分别表示0-1均匀分布的随机数组、标准正态的随机数组、随机整数组和随机列表抽样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.rand(<span class="hljs-number">3</span>) <span class="hljs-comment"># 生成服从0-1均匀分布的三个随机数</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0.92340835, 0.20019461, 0.40755472])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) <span class="hljs-comment"># 注意这里传入的不是元组，每个维度大小分开输入</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0.8012362 , 0.53154881, 0.05858554],       [0.13103034, 0.18108091, 0.30253153],       [0.00528884, 0.99402007, 0.36348797]])</code></pre><p>对于服从区间<code>a</code>到<code>b</code>上的均匀分布可以如下生成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b = <span class="hljs-number">5</span>, <span class="hljs-number">15</span><br>(b - a) * np.random.rand(<span class="hljs-number">3</span>) + a<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([6.59370831, 8.03865138, 9.19172546])</code></pre><p>一般的，可以选择已有的库函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([11.26499636, 13.12311185,  6.00774156])</code></pre><p><code>randn</code>生成了<code>N(0,I)</code>的标准正态分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.randn(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ 1.87000209,  1.19885561, -0.58802943])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.randn(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[-1.3642839 , -0.31497567],       [-1.9452492 , -3.17272882]])</code></pre><p>对于服从方差为<spanclass="math inline">\(\sigma^2\)</span>均值为<spanclass="math inline">\(\mu\)</span>的一元正态分布可以如下生成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sigma, mu = <span class="hljs-number">2.5</span>, <span class="hljs-number">3</span><br>mu + np.random.randn(<span class="hljs-number">3</span>) * sigma<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1.56024917, 0.22829486, 7.3764211 ])</code></pre><p>同样的，也可选择从已有函数生成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.normal(<span class="hljs-number">3</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([3.53517851, 5.3441269 , 3.51192744])</code></pre><p><code>randint</code>可以指定生成随机整数的最小值最大值（不包含）和维度大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">low, high, size = <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 生成5到14的随机整数</span><br>np.random.randint(low, high, size)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[ 5, 12],       [14,  9]])</code></pre><p><code>choice</code>可以从给定的列表中，以一定概率和方式抽取结果，当不指定概率时为均匀采样，默认抽取方式为有放回抽样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br>np.random.choice(my_list, <span class="hljs-number">2</span>, replace=<span class="hljs-literal">False</span>, p=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.1</span> ,<span class="hljs-number">0.1</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([&#39;b&#39;, &#39;a&#39;], dtype=&#39;&lt;U1&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.choice(my_list, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[&#39;c&#39;, &#39;b&#39;, &#39;d&#39;],       [&#39;d&#39;, &#39;a&#39;, &#39;d&#39;],       [&#39;a&#39;, &#39;c&#39;, &#39;d&#39;]], dtype=&#39;&lt;U1&#39;)</code></pre><p>当返回的元素个数与原列表相同时，不放回抽样等价于使用<code>permutation</code>函数，即打散原列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.permutation(my_list)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([&#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;b&#39;], dtype=&#39;&lt;U1&#39;)</code></pre><p>最后，需要提到的是随机种子，它能够固定随机数的输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>np.random.rand()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.5488135039273248</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>np.random.rand()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0.5488135039273248</code></pre><h3 id="np数组的变形与合并">2. np数组的变形与合并</h3><p>【a】转置：<code>T</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)).T<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 0.],       [0., 0.],       [0., 0.]])</code></pre><p>【b】合并操作：<code>r_</code>, <code>c_</code></p><p>对于二维数组而言，<code>r_</code>和<code>c_</code>分别表示上下合并和左右合并：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.r_[np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 0., 0.],       [0., 0., 0.],       [0., 0., 0.],       [0., 0., 0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.c_[np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 0., 0., 0., 0., 0.],       [0., 0., 0., 0., 0., 0.]])</code></pre><p>一维数组和二维数组进行合并时，应当把其视作列向量，在长度匹配的情况下只能够使用左右合并的<code>c_</code>操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>     np.r_[np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))]<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>     Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure><pre><code class="hljs">ValueError(&#39;all the input arrays must have same number of dimensions, but the array at index 0 has 1 dimension(s) and the array at index 1 has 2 dimension(s)&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.r_[np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros(<span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0., 0., 0., 0.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.c_[np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0., 0., 0., 0.],       [0., 0., 0., 0.]])</code></pre><p>【c】维度变换：<code>reshape</code></p><p><code>reshape</code>能够帮助用户把原数组按照新的维度重新排列。在使用时有两种模式，分别为<code>C</code>模式和<code>F</code>模式，分别以逐行和逐列的顺序进行填充读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">target = np.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>target<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 1, 2, 3],       [4, 5, 6, 7]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), order=<span class="hljs-string">&#x27;C&#x27;</span>) <span class="hljs-comment"># 按照行读取和填充</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 1],       [2, 3],       [4, 5],       [6, 7]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), order=<span class="hljs-string">&#x27;F&#x27;</span>) <span class="hljs-comment"># 按照列读取和填充</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 2],       [4, 6],       [1, 3],       [5, 7]])</code></pre><p>特别地，由于被调用数组的大小是确定的，<code>reshape</code>允许有一个维度存在空缺，此时只需填充-1即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target.reshape((<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 1],       [2, 3],       [4, 5],       [6, 7]])</code></pre><p>下面将<code>n*1</code>大小的数组转为1维数组的操作是经常使用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">target = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br>target<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1.],       [1.],       [1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target.reshape(-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1., 1., 1.])</code></pre><h3 id="np数组的切片与索引">3. np数组的切片与索引</h3><p>数组的切片模式支持使用<code>slice</code>类型的<code>start:end:step</code>切片，还可以直接传入列表指定某个维度的索引进行切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">target = np.arange(<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br>target<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 1, 2],       [3, 4, 5],       [6, 7, 8]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target[:-<span class="hljs-number">1</span>, [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 2],       [3, 5]])</code></pre><p>此外，还可以利用<code>np.ix_</code>在对应的维度上使用布尔索引，但此时不能使用<code>slice</code>切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target[np.ix_([<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>], [<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>])]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 2],       [6, 8]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target[np.ix_([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>])]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[3, 5],       [6, 8]])</code></pre><p>当数组维度为1维时，可以直接进行布尔索引，而无需<code>np.ix_</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">new = target.reshape(-<span class="hljs-number">1</span>)<br>new[new%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0, 2, 4, 6, 8])</code></pre><h3 id="常用函数">4. 常用函数</h3><p>为了简单起见，这里假设下述函数输入的数组都是一维的。</p><p>【a】<code>where</code></p><p><code>where</code>是一种条件函数，可以指定满足条件与不满足条件位置对应的填充值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])<br>np.where(a&gt;<span class="hljs-number">0</span>, a, <span class="hljs-number">5</span>) <span class="hljs-comment"># 对应位置为True时填充a对应元素，否则填充5</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([5, 1, 5, 5])</code></pre><p>【b】<code>nonzero</code>, <code>argmax</code>,<code>argmin</code></p><p>这三个函数返回的都是索引，<code>nonzero</code>返回非零数的索引，<code>argmax</code>,<code>argmin</code>分别返回最大和最小数的索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([-<span class="hljs-number">2</span>,-<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>])<br>np.nonzero(a)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(array([0, 1, 3, 4, 5], dtype=int64),)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a.argmax()<br></code></pre></td></tr></table></figure><pre><code class="hljs">4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a.argmin()<br></code></pre></td></tr></table></figure><pre><code class="hljs">1</code></pre><p>【c】<code>any</code>, <code>all</code></p><p><code>any</code>指当序列至少 <strong>存在一个</strong><code>True</code>或非零元素时返回<code>True</code>，否则返回<code>False</code></p><p><code>all</code>指当序列元素 <strong>全为</strong><code>True</code>或非零元素时返回<code>True</code>，否则返回<code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br>a.<span class="hljs-built_in">any</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a.<span class="hljs-built_in">all</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><p>【d】<code>cumprod</code>, <code>cumsum</code>, <code>diff</code></p><p><code>cumprod</code>,<code>cumsum</code>分别表示累乘和累加函数，返回同长度的数组，<code>diff</code>表示和前一个元素做差，由于第一个元素为缺失值，因此在默认参数情况下，返回长度是原数组减1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>a.cumprod()<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 2, 6], dtype=int32)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a.cumsum()<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 3, 6], dtype=int32)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.diff(a)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([1, 1])</code></pre><p>【e】 统计函数</p><p>常用的统计函数包括<code>max, min, mean, median, std, var, sum, quantile</code>，其中分位数计算是全局方法，因此不能通过<code>array.quantile</code>的方法调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">target = np.arange(<span class="hljs-number">5</span>)<br>target<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0, 1, 2, 3, 4])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target.<span class="hljs-built_in">max</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.quantile(target, <span class="hljs-number">0.5</span>) <span class="hljs-comment"># 0.5分位数</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">2.0</code></pre><p>但是对于含有缺失值的数组，它们返回的结果也是缺失值，如果需要略过缺失值，必须使用<code>nan*</code>类型的函数，上述的几个统计函数都有对应的<code>nan*</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">target = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, np.nan])<br>target<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ 1.,  2., nan])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target.<span class="hljs-built_in">max</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">nan</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nanmax(target)<br></code></pre></td></tr></table></figure><pre><code class="hljs">2.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.nanquantile(target, <span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1.5</code></pre><p>对于协方差和相关系数分别可以利用<code>cov, corrcoef</code>如下计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">target1 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>])<br>target2 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">9</span>])<br>np.cov(target1, target2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[ 11.66666667, -16.66666667],       [-16.66666667,  38.66666667]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.corrcoef(target1, target2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[ 1.        , -0.78470603],       [-0.78470603,  1.        ]])</code></pre><p>最后，需要说明二维<code>Numpy</code>数组中统计函数的<code>axis</code>参数，它能够进行某一个维度下的统计特征计算，当<code>axis=0</code>时结果为列的统计指标，当<code>axis=1</code>时结果为行的统计指标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">target = np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>).reshape(<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>)<br>target<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1, 2, 3],       [4, 5, 6],       [7, 8, 9]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target.<span class="hljs-built_in">sum</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([12, 15, 18])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">target.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ 6, 15, 24])</code></pre><h3 id="广播机制">5. 广播机制</h3><p>广播机制用于处理两个不同维度数组之间的操作，这里只讨论不超过两维的数组广播机制。</p><p>【a】标量和数组的操作</p><p>当一个标量和数组进行运算时，标量会自动把大小扩充为数组大小，之后进行逐元素操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-number">3</span> * np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span><br>res<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[4., 4.],       [4., 4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-number">1</span> / res<br>res<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0.25, 0.25],       [0.25, 0.25]])</code></pre><p>【b】二维数组之间的操作</p><p>当两个数组维度完全一致时，使用对应元素的操作，否则会报错，除非其中的某个数组的维度是<spanclass="math inline">\(m×1\)</span>或者<spanclass="math inline">\(1×n\)</span>，那么会扩充其具有<spanclass="math inline">\(1\)</span>的维度为另一个数组对应维度的大小。例如，<spanclass="math inline">\(1×2\)</span>数组和<spanclass="math inline">\(3×2\)</span>数组做逐元素运算时会把第一个数组扩充为<spanclass="math inline">\(3×2\)</span>，扩充时的对应数值进行赋值。但是，需要注意的是，如果第一个数组的维度是<spanclass="math inline">\(1×3\)</span>，那么由于在第二维上的大小不匹配且不为<spanclass="math inline">\(1\)</span>，此时报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">2</span>))<br>res<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1., 1.],       [1., 1.],       [1., 1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">res * np.array([[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]) <span class="hljs-comment"># 第二个数组扩充第一维度为3</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[2., 3.],       [2., 3.],       [2., 3.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">res * np.array([[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>]]) <span class="hljs-comment"># 第二个数组扩充第二维度为2</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[2., 2.],       [3., 3.],       [4., 4.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">res * np.array([[<span class="hljs-number">2</span>]]) <span class="hljs-comment"># 等价于两次扩充，第二个数组两个维度分别扩充为3和2</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[2., 2.],       [2., 2.],       [2., 2.]])</code></pre><p>【c】一维数组与二维数组的操作</p><p>当一维数组<span class="math inline">\(A_k\)</span>与二维数组<spanclass="math inline">\(B_{m,n}\)</span>操作时，等价于把一维数组视作<spanclass="math inline">\(A_{1,k}\)</span>的二维数组，使用的广播法则与【b】中一致，当<spanclass="math inline">\(k!=n\)</span>且<spanclass="math inline">\(k,n\)</span>都不是<spanclass="math inline">\(1\)</span>时报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.ones(<span class="hljs-number">3</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[2., 2., 2.],       [2., 2., 2.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.ones(<span class="hljs-number">3</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[2., 2., 2.],       [2., 2., 2.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.ones(<span class="hljs-number">1</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[2., 2., 2.],       [2., 2., 2.]])</code></pre><h3 id="向量与矩阵的计算">6. 向量与矩阵的计算</h3><p>【a】向量内积：<code>dot</code></p><p><span class="math display">\[\rm \mathbf{a}\cdot\mathbf{b} =\sum_ia_ib_i\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>b = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])<br>a.dot(b)<br></code></pre></td></tr></table></figure><pre><code class="hljs">22</code></pre><p>【b】向量范数和矩阵范数：<code>np.linalg.norm</code></p><p>在矩阵范数的计算中，最重要的是<code>ord</code>参数，可选值如下：</p><table><thead><tr class="header"><th style="text-align: left;">ord</th><th style="text-align: right;">norm for matrices</th><th style="text-align: right;">norm for vectors</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">None</td><td style="text-align: right;">Frobenius norm</td><td style="text-align: right;">2-norm</td></tr><tr class="even"><td style="text-align: left;">'fro'</td><td style="text-align: right;">Frobenius norm</td><td style="text-align: right;">/</td></tr><tr class="odd"><td style="text-align: left;">'nuc'</td><td style="text-align: right;">nuclear norm</td><td style="text-align: right;">/</td></tr><tr class="even"><td style="text-align: left;">inf</td><td style="text-align: right;">max(sum(abs(x), axis=1))</td><td style="text-align: right;">max(abs(x))</td></tr><tr class="odd"><td style="text-align: left;">-inf</td><td style="text-align: right;">min(sum(abs(x), axis=1))</td><td style="text-align: right;">min(abs(x))</td></tr><tr class="even"><td style="text-align: left;">0</td><td style="text-align: right;">/</td><td style="text-align: right;">sum(x != 0)</td></tr><tr class="odd"><td style="text-align: left;">1</td><td style="text-align: right;">max(sum(abs(x), axis=0))</td><td style="text-align: right;">as below</td></tr><tr class="even"><td style="text-align: left;">-1</td><td style="text-align: right;">min(sum(abs(x), axis=0))</td><td style="text-align: right;">as below</td></tr><tr class="odd"><td style="text-align: left;">2</td><td style="text-align: right;">2-norm (largest sing. value)</td><td style="text-align: right;">as below</td></tr><tr class="even"><td style="text-align: left;">-2</td><td style="text-align: right;">smallest singular value</td><td style="text-align: right;">as below</td></tr><tr class="odd"><td style="text-align: left;">other</td><td style="text-align: right;">/</td><td style="text-align: right;">sum(abs(x)**ord)**(1./ord)</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">matrix_target =  np.arange(<span class="hljs-number">4</span>).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>matrix_target<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 1],       [2, 3]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linalg.norm(matrix_target, <span class="hljs-string">&#x27;fro&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">3.7416573867739413</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linalg.norm(matrix_target, np.inf)<br></code></pre></td></tr></table></figure><pre><code class="hljs">5.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linalg.norm(matrix_target, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">3.702459173643833</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">vector_target =  np.arange(<span class="hljs-number">4</span>)<br>vector_target<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0, 1, 2, 3])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linalg.norm(vector_target, np.inf)<br></code></pre></td></tr></table></figure><pre><code class="hljs">3.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linalg.norm(vector_target, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">3.7416573867739413</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linalg.norm(vector_target, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">3.3019272488946263</code></pre><p>【c】矩阵乘法：<code>@</code></p><p><span class="math display">\[\rm [\mathbf{A}_{m\timesp}\mathbf{B}_{p\times n}]_{ij} =\sum_{k=1}^p\mathbf{A}_{ik}\mathbf{B}_{kj}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">4</span>).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>a<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[0, 1],       [2, 3]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">b = np.arange(-<span class="hljs-number">4</span>,<span class="hljs-number">0</span>).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>b<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[-4, -3],       [-2, -1]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a@b<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[ -2,  -1],       [-14,  -9]])</code></pre><h2 id="三练习">三、练习</h2><h3 id="ex1利用列表推导式写矩阵乘法">Ex1：利用列表推导式写矩阵乘法</h3><p>一般的矩阵乘法根据公式，可以由三重循环写出，请将其改写为列表推导式的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">M1 = np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>M2 = np.random.rand(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>res = np.empty((M1.shape[<span class="hljs-number">0</span>],M2.shape[<span class="hljs-number">1</span>]))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M1.shape[<span class="hljs-number">0</span>]):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M2.shape[<span class="hljs-number">1</span>]):<br>        item = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M1.shape[<span class="hljs-number">1</span>]):<br>            item += M1[i][k] * M2[k][j]<br>        res[i][j] = item<br>(np.<span class="hljs-built_in">abs</span>((M1@M2 - res) &lt; <span class="hljs-number">1e-15</span>)).<span class="hljs-built_in">all</span>() <span class="hljs-comment"># 排除数值误差</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">True</code></pre><h3 id="ex2更新矩阵">Ex2：更新矩阵</h3><p>设矩阵 <span class="math inline">\(A_{m×n}\)</span> ，现在对 <spanclass="math inline">\(A\)</span> 中的每一个元素进行更新生成矩阵 <spanclass="math inline">\(B\)</span> ，更新方法是 <spanclass="math inline">\(B_{ij}=A_{ij}\sum_{k=1}^n\frac{1}{A_{ik}}\)</span>，例如下面的矩阵为 <span class="math inline">\(A\)</span> ，则 <spanclass="math inline">\(B_{2,2}=5\times(\frac{1}{4}+\frac{1}{5}+\frac{1}{6})=\frac{37}{12}\)</span>，请利用 <code>Numpy</code> 高效实现。 <spanclass="math display">\[\begin{split}A=\left[ \begin{matrix} 1 &amp; 2&amp;3\\4&amp;5&amp;6\\7&amp;8&amp;9 \end{matrix}\right]\end{split}\]</span></p><h3 id="ex3卡方统计量">Ex3：卡方统计量</h3><p>设矩阵<span class="math inline">\(A_{m\times n}\)</span>，记<spanclass="math inline">\(B_{ij} = \frac{(\sum_{i=1}^mA_{ij})\times(\sum_{j=1}^nA_{ij})}{\sum_{i=1}^m\sum_{j=1}^nA_{ij}}\)</span>，定义卡方值如下：<span class="math display">\[\chi^2 =\sum_{i=1}^m\sum_{j=1}^n\frac{(A_{ij}-B_{ij})^2}{B_{ij}}\]</span>请利用<code>Numpy</code>对给定的矩阵<spanclass="math inline">\(A\)</span>计算<spanclass="math inline">\(\chi^2\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>A = np.random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, (<span class="hljs-number">8</span>, <span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><h3 id="ex4改进矩阵计算的性能">Ex4：改进矩阵计算的性能</h3><p>设<span class="math inline">\(Z\)</span>为<spanclass="math inline">\(m×n\)</span>的矩阵，<spanclass="math inline">\(B\)</span>和<spanclass="math inline">\(U\)</span>分别是<spanclass="math inline">\(m×p\)</span>和<spanclass="math inline">\(p×n\)</span>的矩阵，<spanclass="math inline">\(B_i\)</span>为<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(i\)</span>行，<spanclass="math inline">\(U_j\)</span>为<spanclass="math inline">\(U\)</span>的第<spanclass="math inline">\(j\)</span>列，下面定义<spanclass="math inline">\(\displaystyleR=\sum_{i=1}^m\sum_{j=1}^n\|B_i-U_j\|_2^2Z_{ij}\)</span>，其中<spanclass="math inline">\(\|\mathbf{a}\|_2^2\)</span>表示向量<spanclass="math inline">\(a\)</span>的分量平方和<spanclass="math inline">\(\sum_i a_i^2\)</span>。</p><p>现有某人根据如下给定的样例数据计算<spanclass="math inline">\(R\)</span>的值，请充分利用<code>Numpy</code>中的函数，基于此问题改进这段代码的性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>m, n, p = <span class="hljs-number">100</span>, <span class="hljs-number">80</span>, <span class="hljs-number">50</span><br>B = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, (m, p))<br>U = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, (p, n))<br>Z = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, (m, n))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">B=B, U=U, Z=Z</span>):<br>    L_res = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            norm_value = ((B[i]-U[:,j])**<span class="hljs-number">2</span>).<span class="hljs-built_in">sum</span>()<br>            L_res.append(norm_value*Z[i][j])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(L_res)<br>solution(B, U, Z)<br></code></pre></td></tr></table></figure><pre><code class="hljs">100566</code></pre><h3 id="ex5连续整数的最大长度">Ex5：连续整数的最大长度</h3><p>输入一个整数的<code>Numpy</code>数组，返回其中严格递增连续整数子数组的最大长度，正向是指递增方向。例如，输入[1,2,5,6,7]，[5,6,7]为具有最大长度的连续整数子数组，因此输出3；输入[3,2,1,2,3,4,6]，[1,2,3,4]为具有最大长度的连续整数子数组，因此输出4。请充分利用<code>Numpy</code>的内置函数完成。（提示：考虑使用<code>nonzero, diff</code>函数）</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas分类数据</title>
    <link href="/2023/10/01/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE/"/>
    <url>/2023/10/01/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas分类数据">Pandas分类数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="一cat对象">一、cat对象</h2><h3 id="cat对象的属性">1. cat对象的属性</h3><p>在<code>pandas</code>中提供了<code>category</code>类型，使用户能够处理分类类型的变量，将一个普通序列转换成分类变量可以使用<code>astype</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>, usecols = [<span class="hljs-string">&#x27;Grade&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>])<br>s = df.Grade.astype(<span class="hljs-string">&#x27;category&#x27;</span>)<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     Freshman1     Freshman2       Senior3    Sophomore4    SophomoreName: Grade, dtype: categoryCategories (4, object): [&#39;Freshman&#39;, &#39;Junior&#39;, &#39;Senior&#39;, &#39;Sophomore&#39;]</code></pre><p>在一个分类类型的<code>Series</code>中定义了<code>cat</code>对象，它和上一章中介绍的<code>str</code>对象类似，定义了一些属性和方法来进行分类类别的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.cat<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.arrays.categorical.CategoricalAccessor object at 0x0000020F9B7A7108&gt;</code></pre><p>对于一个具体的分类，有两个组成部分，其一为类别的本身，它以<code>Index</code>类型存储，其二为是否有序，它们都可以通过<code>cat</code>的属性被访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.cat.categories<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;Freshman&#39;, &#39;Junior&#39;, &#39;Senior&#39;, &#39;Sophomore&#39;], dtype=&#39;object&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.cat.ordered<br></code></pre></td></tr></table></figure><pre><code class="hljs">False</code></pre><p>另外，每一个序列的类别会被赋予唯一的整数编号，它们的编号取决于<code>cat.categories</code>中的顺序，该属性可以通过<code>codes</code>访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.cat.codes.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    01    02    23    34    3dtype: int8</code></pre><h3 id="类别的增加删除和修改">2. 类别的增加、删除和修改</h3><p>通过<code>cat</code>对象的<code>categories</code>属性能够完成对类别的查询，那么应该如何进行“增改查删”的其他三个操作呢？</p><h4 id="note类别不得直接修改">【NOTE】类别不得直接修改</h4><p>在第三章中曾提到，索引 <code>Index</code> 类型是无法用<code>index_obj[0] = item</code> 来修改的，而 <code>categories</code>被存储在 <code>Index</code> 中，因此 <code>pandas</code> 在<code>cat</code> 属性上定义了若干方法来达到相同的目的。 #### 【END】</p><p>首先，对于类别的增加可以使用<code>add_categories</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = s.cat.add_categories(<span class="hljs-string">&#x27;Graduate&#x27;</span>) <span class="hljs-comment"># 增加一个毕业生类别</span><br>s.cat.categories<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;Freshman&#39;, &#39;Junior&#39;, &#39;Senior&#39;, &#39;Sophomore&#39;, &#39;Graduate&#39;], dtype=&#39;object&#39;)</code></pre><p>若要删除某一个类别可以使用<code>remove_categories</code>，同时所有原来序列中的该类会被设置为缺失。例如，删除大一的类别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = s.cat.remove_categories(<span class="hljs-string">&#x27;Freshman&#x27;</span>)<br>s.cat.categories<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;Junior&#39;, &#39;Senior&#39;, &#39;Sophomore&#39;, &#39;Graduate&#39;], dtype=&#39;object&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0          NaN1          NaN2       Senior3    Sophomore4    SophomoreName: Grade, dtype: categoryCategories (4, object): [&#39;Junior&#39;, &#39;Senior&#39;, &#39;Sophomore&#39;, &#39;Graduate&#39;]</code></pre><p>此外可以使用<code>set_categories</code>直接设置序列的新类别，原来的类别中如果存在元素不属于新类别，那么会被设置为缺失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = s.cat.set_categories([<span class="hljs-string">&#x27;Sophomore&#x27;</span>,<span class="hljs-string">&#x27;PhD&#x27;</span>]) <span class="hljs-comment"># 新类别为大二学生和博士</span><br>s.cat.categories<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;Sophomore&#39;, &#39;PhD&#39;], dtype=&#39;object&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0          NaN1          NaN2          NaN3    Sophomore4    SophomoreName: Grade, dtype: categoryCategories (2, object): [&#39;Sophomore&#39;, &#39;PhD&#39;]</code></pre><p>如果想要删除未出现在序列中的类别，可以使用<code>remove_unused_categories</code>来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = s.cat.remove_unused_categories() <span class="hljs-comment"># 移除了未出现的博士生类别</span><br>s.cat.categories<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;Sophomore&#39;], dtype=&#39;object&#39;)</code></pre><p>最后，“增改查删”中还剩下修改的操作，这可以通过<code>rename_categories</code>方法完成，同时需要注意的是，这个方法会对原序列的对应值也进行相应修改。例如，现在把<code>Sophomore</code>改成中文的<code>本科二年级学生</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = s.cat.rename_categories(&#123;<span class="hljs-string">&#x27;Sophomore&#x27;</span>:<span class="hljs-string">&#x27;本科二年级学生&#x27;</span>&#125;)<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0        NaN1        NaN2        NaN3    本科二年级学生4    本科二年级学生Name: Grade, dtype: categoryCategories (1, object): [&#39;本科二年级学生&#39;]</code></pre><h2 id="二有序分类">二、有序分类</h2><h3 id="序的建立">1. 序的建立</h3><p>有序类别和无序类别可以通过<code>as_unordered</code>和<code>reorder_categories</code>互相转化，需要注意的是后者传入的参数必须是由当前序列的无序类别构成的列表，不能够增加新的类别，也不能缺少原来的类别，并且必须指定参数<code>ordered=True</code>，否则方法无效。例如，对年级高低进行相对大小的类别划分，然后再恢复无序状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = df.Grade.astype(<span class="hljs-string">&#x27;category&#x27;</span>)<br>s = s.cat.reorder_categories([<span class="hljs-string">&#x27;Freshman&#x27;</span>, <span class="hljs-string">&#x27;Sophomore&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>],ordered=<span class="hljs-literal">True</span>)<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     Freshman1     Freshman2       Senior3    Sophomore4    SophomoreName: Grade, dtype: categoryCategories (4, object): [&#39;Freshman&#39; &lt; &#39;Sophomore&#39; &lt; &#39;Junior&#39; &lt; &#39;Senior&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.cat.as_unordered().head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     Freshman1     Freshman2       Senior3    Sophomore4    SophomoreName: Grade, dtype: categoryCategories (4, object): [&#39;Freshman&#39;, &#39;Sophomore&#39;, &#39;Junior&#39;, &#39;Senior&#39;]</code></pre><h4 id="note类别不得直接修改-1">【NOTE】类别不得直接修改</h4><p>如果不想指定<code>ordered=True</code>参数，那么可以先用<code>s.cat.as_ordered()</code>转化为有序类别，再利用<code>reorder_categories</code>进行具体的相对大小调整。#### 【END】 ### 2. 排序和比较</p><p>在第二章中，曾提到了字符串和数值类型序列的排序，此时就要说明分类变量的排序：只需把列的类型修改为<code>category</code>后，再赋予相应的大小关系，就能正常地使用<code>sort_index</code>和<code>sort_values</code>。例如，对年级进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df.Grade = df.Grade.astype(<span class="hljs-string">&#x27;category&#x27;</span>)<br>df.Grade = df.Grade.cat.reorder_categories([<span class="hljs-string">&#x27;Freshman&#x27;</span>, <span class="hljs-string">&#x27;Sophomore&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>],ordered=<span class="hljs-literal">True</span>)<br>df.sort_values(<span class="hljs-string">&#x27;Grade&#x27;</span>).head() <span class="hljs-comment"># 值排序</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade</th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th></tr></thead><tbody><tr><th>0</th><td>Freshman</td><td>Gaopeng Yang</td><td>Female</td><td>158.9</td><td>46.0</td></tr><tr><th>105</th><td>Freshman</td><td>Qiang Shi</td><td>Female</td><td>164.5</td><td>52.0</td></tr><tr><th>96</th><td>Freshman</td><td>Changmei Feng</td><td>Female</td><td>163.8</td><td>56.0</td></tr><tr><th>88</th><td>Freshman</td><td>Xiaopeng Han</td><td>Female</td><td>164.1</td><td>53.0</td></tr><tr><th>81</th><td>Freshman</td><td>Yanli Zhang</td><td>Female</td><td>165.1</td><td>52.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.set_index(<span class="hljs-string">&#x27;Grade&#x27;</span>).sort_index().head() <span class="hljs-comment"># 索引排序</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th></tr><tr><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Freshman</th><td>Gaopeng Yang</td><td>Female</td><td>158.9</td><td>46.0</td></tr><tr><th>Freshman</th><td>Qiang Shi</td><td>Female</td><td>164.5</td><td>52.0</td></tr><tr><th>Freshman</th><td>Changmei Feng</td><td>Female</td><td>163.8</td><td>56.0</td></tr><tr><th>Freshman</th><td>Xiaopeng Han</td><td>Female</td><td>164.1</td><td>53.0</td></tr><tr><th>Freshman</th><td>Yanli Zhang</td><td>Female</td><td>165.1</td><td>52.0</td></tr></tbody></table></div><p>由于序的建立，因此就可以进行比较操作。分类变量的比较操作分为两类，第一种是<code>==</code>或<code>!=</code>关系的比较，比较的对象可以是标量或者同长度的<code>Series</code>（或<code>list</code>），第二种是<code>&gt;,&gt;=,&lt;,&lt;=</code>四类大小关系的比较，比较的对象和第一种类似，但是所有参与比较的元素必须属于原序列的<code>categories</code>，同时要和原序列具有相同的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res1 = df.Grade == <span class="hljs-string">&#x27;Sophomore&#x27;</span><br>res1.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2    False3     True4     TrueName: Grade, dtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res2 = df.Grade == [<span class="hljs-string">&#x27;PhD&#x27;</span>]*df.shape[<span class="hljs-number">0</span>]<br>res2.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2    False3    False4    FalseName: Grade, dtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res3 = df.Grade &lt;= <span class="hljs-string">&#x27;Sophomore&#x27;</span><br>res3.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1     True2    False3     True4     TrueName: Grade, dtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res4 = df.Grade &lt;= df.Grade.sample(frac=<span class="hljs-number">1</span>).reset_index(drop=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 打乱后比较</span><br>res4.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1     True2    False3     True4     TrueName: Grade, dtype: bool</code></pre><h2 id="三区间类别">三、区间类别</h2><h3 id="利用cut和qcut进行区间构造">1. 利用cut和qcut进行区间构造</h3><p>区间是一种特殊的类别，在实际数据分析中，区间序列往往是通过<code>cut</code>和<code>qcut</code>方法进行构造的，这两个函数能够把原序列的数值特征进行装箱，即用区间位置来代替原来的具体数值。</p><p>首先介绍<code>cut</code>的常见用法：</p><p>其中，最重要的参数是<code>bins</code>，如果传入整数<code>n</code>，则代表把整个传入数组的按照最大和最小值等间距地分为<code>n</code>段。由于区间默认是左开右闭，需要在调整时把最小值包含进去，在<code>pandas</code>中的解决方案是在值最小的区间左端点再减去<code>0.001*(max-min)</code>，因此如果对序列<code>[1,2]</code>划分为2个箱子时，第一个箱子的范围<code>(0.999,1.5]</code>，第二个箱子的范围是<code>(1.5,2]</code>。如果需要指定左闭右开时，需要把<code>right</code>参数设置为<code>False</code>，相应的区间调整方法是在值最大的区间右端点再加上<code>0.001*(max-min)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>pd.cut(s, bins=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    (0.999, 1.5]1      (1.5, 2.0]dtype: categoryCategories (2, interval[float64]): [(0.999, 1.5] &lt; (1.5, 2.0]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.cut(s, bins=<span class="hljs-number">2</span>, right=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      [1.0, 1.5)1    [1.5, 2.001)dtype: categoryCategories (2, interval[float64]): [[1.0, 1.5) &lt; [1.5, 2.001)]</code></pre><p><code>bins</code>的另一个常见用法是指定区间分割点的列表（使用<code>np.infty</code>可以表示无穷大）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.cut(s, bins=[-np.infty, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.8</span>, <span class="hljs-number">2.2</span>, np.infty])<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    (-inf, 1.2]1     (1.8, 2.2]dtype: categoryCategories (4, interval[float64]): [(-inf, 1.2] &lt; (1.2, 1.8] &lt; (1.8, 2.2] &lt; (2.2, inf]]</code></pre><p>另外两个常用参数为<code>labels</code>和<code>retbins</code>，分别代表了区间的名字和是否返回分割点（默认不返回）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>res = pd.cut(s, bins=<span class="hljs-number">2</span>, labels=[<span class="hljs-string">&#x27;small&#x27;</span>, <span class="hljs-string">&#x27;big&#x27;</span>], retbins=<span class="hljs-literal">True</span>)<br>res[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    small1      bigdtype: categoryCategories (2, object): [&#39;small&#39; &lt; &#39;big&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">res[<span class="hljs-number">1</span>] <span class="hljs-comment"># 该元素为返回的分割点</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">array([0.999, 1.5  , 2.   ])</code></pre><p>从用法上来说，<code>qcut</code>和<code>cut</code>几乎没有差别，只是把<code>bins</code>参数变成的<code>q</code>参数，<code>qcut</code>中的<code>q</code>是指<code>quantile</code>。这里的<code>q</code>为整数<code>n</code>时，指按照<code>n</code>等分位数把数据分箱，还可以传入浮点列表指代相应的分位数分割点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = df.Weight<br>pd.qcut(s, q=<span class="hljs-number">3</span>).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    (33.999, 48.0]1      (55.0, 89.0]2      (55.0, 89.0]3    (33.999, 48.0]4      (55.0, 89.0]Name: Weight, dtype: categoryCategories (3, interval[float64]): [(33.999, 48.0] &lt; (48.0, 55.0] &lt; (55.0, 89.0]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.qcut(s, q=[<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.8</span>,<span class="hljs-number">1</span>]).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      (44.0, 69.4]1      (69.4, 89.0]2      (69.4, 89.0]3    (33.999, 44.0]4      (69.4, 89.0]Name: Weight, dtype: categoryCategories (3, interval[float64]): [(33.999, 44.0] &lt; (44.0, 69.4] &lt; (69.4, 89.0]]</code></pre><h3 id="一般区间的构造">2. 一般区间的构造</h3><p>对于某一个具体的区间而言，其具备三个要素，即左端点、右端点和端点的开闭状态，其中开闭状态可以指定<code>right, left, both, neither</code>中的一类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_interval = pd.Interval(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;right&#x27;</span>)<br>my_interval<br></code></pre></td></tr></table></figure><pre><code class="hljs">Interval(0, 1, closed=&#39;right&#39;)</code></pre><p>其属性包含了<code>mid, length, right, left, closed,</code>，分别表示中点、长度、右端点、左端点和开闭状态。</p><p>使用<code>in</code>可以判断元素是否属于区间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">0.5</span> <span class="hljs-keyword">in</span> my_interval<br></code></pre></td></tr></table></figure><pre><code class="hljs">True</code></pre><p>使用<code>overlaps</code>可以判断两个区间是否有交集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_interval_2 = pd.Interval(<span class="hljs-number">0.5</span>, <span class="hljs-number">1.5</span>, <span class="hljs-string">&#x27;left&#x27;</span>)<br>my_interval.overlaps(my_interval_2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">True</code></pre><p>一般而言，<code>pd.IntervalIndex</code>对象有四类方法生成，分别是<code>from_breaks, from_arrays, from_tuples, interval_range</code>，它们分别应用于不同的情况：</p><p><code>from_breaks</code>的功能类似于<code>cut</code>或<code>qcut</code>函数，只不过后两个是通过计算得到的分割点，而前者是直接传入自定义的分割点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.IntervalIndex.from_breaks([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>], closed=<span class="hljs-string">&#x27;both&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">IntervalIndex([[1, 3], [3, 6], [6, 10]],              closed=&#39;both&#39;,              dtype=&#39;interval[int64]&#39;)</code></pre><p><code>from_arrays</code>是分别传入左端点和右端点的列表，适用于有交集并且知道起点和终点的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.IntervalIndex.from_arrays(left = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>], right = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>], closed = <span class="hljs-string">&#x27;neither&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">IntervalIndex([(1, 5), (3, 4), (6, 9), (10, 11)],              closed=&#39;neither&#39;,              dtype=&#39;interval[int64]&#39;)</code></pre><p><code>from_tuples</code>传入的是起点和终点元组构成的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.IntervalIndex.from_tuples([(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">6</span>,<span class="hljs-number">9</span>),(<span class="hljs-number">10</span>,<span class="hljs-number">11</span>)], closed=<span class="hljs-string">&#x27;neither&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">IntervalIndex([(1, 5), (3, 4), (6, 9), (10, 11)],              closed=&#39;neither&#39;,              dtype=&#39;interval[int64]&#39;)</code></pre><p>一个等差的区间序列由起点、终点、区间个数和区间长度决定，其中三个量确定的情况下，剩下一个量就确定了，<code>interval_range</code>中的<code>start, end, periods, freq</code>参数就对应了这四个量，从而就能构造出相应的区间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.interval_range(start=<span class="hljs-number">1</span>,end=<span class="hljs-number">5</span>,periods=<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">IntervalIndex([(1.0, 1.5], (1.5, 2.0], (2.0, 2.5], (2.5, 3.0], (3.0, 3.5], (3.5, 4.0], (4.0, 4.5], (4.5, 5.0]],              closed=&#39;right&#39;,              dtype=&#39;interval[float64]&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.interval_range(end=<span class="hljs-number">5</span>,periods=<span class="hljs-number">8</span>,freq=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">IntervalIndex([(1.0, 1.5], (1.5, 2.0], (2.0, 2.5], (2.5, 3.0], (3.0, 3.5], (3.5, 4.0], (4.0, 4.5], (4.5, 5.0]],              closed=&#39;right&#39;,              dtype=&#39;interval[float64]&#39;)</code></pre><h4 id="练一练">【练一练】</h4><p>无论是<code>interval_range</code>还是下一章时间序列中的<code>date_range</code>都是给定了等差序列中四要素中的三个，从而确定整个序列。请回顾等差数列中的首项、末项、项数和公差的联系，写出<code>interval_range</code>中四个参数之间的恒等关系。#### 【END】除此之外，如果直接使用<code>pd.IntervalIndex([...], closed=...)</code>，把<code>Interval</code>类型的列表组成传入其中转为区间索引，那么所有的区间会被强制转为指定的<code>closed</code>类型，因为<code>pd.IntervalIndex</code>只允许存放同一种开闭区间的<code>Interval</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_interval<br></code></pre></td></tr></table></figure><pre><code class="hljs">Interval(0, 1, closed=&#39;right&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_interval_2<br></code></pre></td></tr></table></figure><pre><code class="hljs">Interval(0.5, 1.5, closed=&#39;left&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.IntervalIndex([my_interval, my_interval_2], closed=<span class="hljs-string">&#x27;left&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">IntervalIndex([[0.0, 1.0), [0.5, 1.5)],              closed=&#39;left&#39;,              dtype=&#39;interval[float64]&#39;)</code></pre><h3 id="区间的属性与方法">3. 区间的属性与方法</h3><p><code>IntervalIndex</code>上也定义了一些有用的属性和方法。同时，如果想要具体利用<code>cut</code>或者<code>qcut</code>的结果进行分析，那么需要先将其转为该种索引类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">id_interval = pd.IntervalIndex(pd.cut(s, <span class="hljs-number">3</span>))<br>id_interval[:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">IntervalIndex([(33.945, 52.333], (52.333, 70.667], (70.667, 89.0]],              closed=&#39;right&#39;,              name=&#39;Weight&#39;,              dtype=&#39;interval[float64]&#39;)</code></pre><p>与单个<code>Interval</code>类型相似，<code>IntervalIndex</code>有若干常用属性：<code>left, right, mid, length</code>，分别表示左右端点、两端点均值和区间长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">id_demo = id_interval[:<span class="hljs-number">5</span>] <span class="hljs-comment"># 选出前5个展示</span><br>id_demo<br></code></pre></td></tr></table></figure><pre><code class="hljs">IntervalIndex([(33.945, 52.333], (52.333, 70.667], (70.667, 89.0], (33.945, 52.333], (70.667, 89.0]],              closed=&#39;right&#39;,              name=&#39;Weight&#39;,              dtype=&#39;interval[float64]&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id_demo.left<br></code></pre></td></tr></table></figure><pre><code class="hljs">Float64Index([33.945, 52.333, 70.667, 33.945, 70.667], dtype=&#39;float64&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id_demo.right<br></code></pre></td></tr></table></figure><pre><code class="hljs">Float64Index([52.333, 70.667, 89.0, 52.333, 89.0], dtype=&#39;float64&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id_demo.mid<br></code></pre></td></tr></table></figure><pre><code class="hljs">Float64Index([43.138999999999996, 61.5, 79.8335, 43.138999999999996, 79.8335], dtype=&#39;float64&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id_demo.length<br></code></pre></td></tr></table></figure><pre><code class="hljs">Float64Index([18.387999999999998, 18.334000000000003, 18.333,              18.387999999999998, 18.333],             dtype=&#39;float64&#39;)</code></pre><p><code>IntervalIndex</code>还有两个常用方法，包括<code>contains</code>和<code>overlaps</code>，分别指逐个判断每个区间是否包含某元素，以及是否和一个<code>pd.Interval</code>对象有交集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id_demo.contains(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([False, False, False, False, False])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id_demo.overlaps(pd.Interval(<span class="hljs-number">40</span>,<span class="hljs-number">60</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([ True,  True, False,  True, False])</code></pre><h2 id="四练习">四、练习</h2><h3 id="ex1统计未出现的类别">Ex1：统计未出现的类别</h3><p>在第五章中介绍了<code>crosstab</code>函数，在默认参数下它能够对两个列的组合出现的频数进行统计汇总：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>], <span class="hljs-string">&#x27;B&#x27;</span>:[<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>,<span class="hljs-string">&#x27;cat&#x27;</span>]&#125;)<br>pd.crosstab(df.A, df.B)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>B</th><th>cat</th><th>dog</th></tr><tr><th>A</th><th></th><th></th></tr></thead><tbody><tr><th>a</th><td>2</td><td>0</td></tr><tr><th>b</th><td>1</td><td>0</td></tr><tr><th>c</th><td>0</td><td>1</td></tr></tbody></table></div><p>但事实上有些列存储的是分类变量，列中并不一定包含所有的类别，此时如果想要对这些未出现的类别在<code>crosstab</code>结果中也进行汇总，则可以指定<code>dropna</code>参数为<code>False</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df.B = df.B.astype(<span class="hljs-string">&#x27;category&#x27;</span>).cat.add_categories(<span class="hljs-string">&#x27;sheep&#x27;</span>)<br>pd.crosstab(df.A, df.B, dropna=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>B</th><th>cat</th><th>dog</th><th>sheep</th></tr><tr><th>A</th><th></th><th></th><th></th></tr></thead><tbody><tr><th>a</th><td>2</td><td>0</td><td>0</td></tr><tr><th>b</th><td>1</td><td>0</td><td>0</td></tr><tr><th>c</th><td>0</td><td>1</td><td>0</td></tr></tbody></table></div><p>请实现一个带有<code>dropna</code>参数的<code>my_crosstab</code>函数来完成上面的功能。</p><h3 id="ex2钻石数据集">Ex2：钻石数据集</h3><p>现有一份关于钻石的数据集，其中<code>carat, cut, clarity, price</code>分别表示克拉重量、切割质量、纯净度和价格，样例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/diamonds.csv&#x27;</span>) <br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>carat</th><th>cut</th><th>clarity</th><th>price</th></tr></thead><tbody><tr><th>0</th><td>0.23</td><td>Ideal</td><td>SI2</td><td>326</td></tr><tr><th>1</th><td>0.21</td><td>Premium</td><td>SI1</td><td>326</td></tr><tr><th>2</th><td>0.23</td><td>Good</td><td>VS1</td><td>327</td></tr></tbody></table></div><ol type="1"><li>分别对<code>df.cut</code>在<code>object</code>类型和<code>category</code>类型下使用<code>nunique</code>函数，并比较它们的性能。</li><li>钻石的切割质量可以分为五个等级，由次到好分别是<code>Fair, Good, Very Good, Premium, Ideal</code>，纯净度有八个等级，由次到好分别是<code>I1, SI2, SI1, VS2, VS1, VVS2, VVS1, IF</code>，请对切割质量按照<strong>由好到次</strong>的顺序排序，相同切割质量的钻石，按照纯净度进行<strong>由次到好</strong>的排序。</li><li>分别采用两种不同的方法，把<code>cut, clarity</code>这两列按照<strong>由好到次</strong>的顺序，映射到从0到n-1的整数，其中n表示类别的个数。</li><li>对每克拉的价格分别按照分位数（q=[0.2, 0.4, 0.6, 0.8]）与[1000, 3500,5500,18000]割点进行分箱得到五个类别<code>Very Low, Low, Mid, High, Very High</code>，并把按这两种分箱方法得到的<code>category</code>序列依次添加到原表中。</li><li>第4问中按照整数分箱得到的序列中，是否出现了所有的类别？如果存在没有出现的类别请把该类别删除。</li><li>对第4问中按照分位数分箱得到的序列，求每个样本对应所在区间的左右端点值和长度。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas基础</title>
    <link href="/2023/10/01/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20pandas%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/01/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20pandas%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas基础">Pandas基础</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><p>请保证<code>pandas</code>的版本号不低于如下所示的版本，否则请务必升级！请确认已经安装了<code>xlrd, xlwt, openpyxl</code>这三个包，其中<code>xlrd</code>版本不得高于<code>2.0.0</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.__version__<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;1.1.5&#39;</code></pre><h2 id="一文件的读取和写入">一、文件的读取和写入</h2><h3 id="文件读取">1. 文件读取</h3><p><code>pandas</code>可以读取的文件格式有很多，这里主要介绍读取<code>csv, excel, txt</code>文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_csv = pd.read_csv(<span class="hljs-string">&#x27;../data/my_csv.csv&#x27;</span>)<br>df_csv<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col1</th><th>col2</th><th>col3</th><th>col4</th><th>col5</th></tr></thead><tbody><tr><th>0</th><td>2</td><td>a</td><td>1.4</td><td>apple</td><td>2020/1/1</td></tr><tr><th>1</th><td>3</td><td>b</td><td>3.4</td><td>banana</td><td>2020/1/2</td></tr><tr><th>2</th><td>6</td><td>c</td><td>2.5</td><td>orange</td><td>2020/1/5</td></tr><tr><th>3</th><td>5</td><td>d</td><td>3.2</td><td>lemon</td><td>2020/1/7</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_txt = pd.read_table(<span class="hljs-string">&#x27;../data/my_table.txt&#x27;</span>)<br>df_txt<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col1</th><th>col2</th><th>col3</th><th>col4</th></tr></thead><tbody><tr><th>0</th><td>2</td><td>a</td><td>1.4</td><td>apple 2020/1/1</td></tr><tr><th>1</th><td>3</td><td>b</td><td>3.4</td><td>banana 2020/1/2</td></tr><tr><th>2</th><td>6</td><td>c</td><td>2.5</td><td>orange 2020/1/5</td></tr><tr><th>3</th><td>5</td><td>d</td><td>3.2</td><td>lemon 2020/1/7</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_excel = pd.read_excel(<span class="hljs-string">&#x27;../data/my_excel.xlsx&#x27;</span>)<br>df_excel<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col1</th><th>col2</th><th>col3</th><th>col4</th><th>col5</th></tr></thead><tbody><tr><th>0</th><td>2</td><td>a</td><td>1.4</td><td>apple</td><td>2020/1/1</td></tr><tr><th>1</th><td>3</td><td>b</td><td>3.4</td><td>banana</td><td>2020/1/2</td></tr><tr><th>2</th><td>6</td><td>c</td><td>2.5</td><td>orange</td><td>2020/1/5</td></tr><tr><th>3</th><td>5</td><td>d</td><td>3.2</td><td>lemon</td><td>2020/1/7</td></tr></tbody></table></div><p>这里有一些常用的公共参数，<code>header=None</code>表示第一行不作为列名，<code>index_col</code>表示把某一列或几列作为索引，索引的内容将会在第三章进行详述，<code>usecols</code>表示读取列的集合，默认读取所有的列，<code>parse_dates</code>表示需要转化为时间的列，关于时间序列的有关内容将在第十章讲解，<code>nrows</code>表示读取的数据行数。上面这些参数在上述的三个函数里都可以使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_table(<span class="hljs-string">&#x27;../data/my_table.txt&#x27;</span>, header=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><th>0</th><td>col1</td><td>col2</td><td>col3</td><td>col4</td></tr><tr><th>1</th><td>2</td><td>a</td><td>1.4</td><td>apple 2020/1/1</td></tr><tr><th>2</th><td>3</td><td>b</td><td>3.4</td><td>banana 2020/1/2</td></tr><tr><th>3</th><td>6</td><td>c</td><td>2.5</td><td>orange 2020/1/5</td></tr><tr><th>4</th><td>5</td><td>d</td><td>3.2</td><td>lemon 2020/1/7</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;../data/my_csv.csv&#x27;</span>, index_col=[<span class="hljs-string">&#x27;col1&#x27;</span>, <span class="hljs-string">&#x27;col2&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>col3</th><th>col4</th><th>col5</th></tr><tr><th>col1</th><th>col2</th><th></th><th></th><th></th></tr></thead><tbody><tr><th>2</th><th>a</th><td>1.4</td><td>apple</td><td>2020/1/1</td></tr><tr><th>3</th><th>b</th><td>3.4</td><td>banana</td><td>2020/1/2</td></tr><tr><th>6</th><th>c</th><td>2.5</td><td>orange</td><td>2020/1/5</td></tr><tr><th>5</th><th>d</th><td>3.2</td><td>lemon</td><td>2020/1/7</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_table(<span class="hljs-string">&#x27;../data/my_table.txt&#x27;</span>, usecols=[<span class="hljs-string">&#x27;col1&#x27;</span>, <span class="hljs-string">&#x27;col2&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col1</th><th>col2</th></tr></thead><tbody><tr><th>0</th><td>2</td><td>a</td></tr><tr><th>1</th><td>3</td><td>b</td></tr><tr><th>2</th><td>6</td><td>c</td></tr><tr><th>3</th><td>5</td><td>d</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;../data/my_csv.csv&#x27;</span>, parse_dates=[<span class="hljs-string">&#x27;col5&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col1</th><th>col2</th><th>col3</th><th>col4</th><th>col5</th></tr></thead><tbody><tr><th>0</th><td>2</td><td>a</td><td>1.4</td><td>apple</td><td>2020-01-01</td></tr><tr><th>1</th><td>3</td><td>b</td><td>3.4</td><td>banana</td><td>2020-01-02</td></tr><tr><th>2</th><td>6</td><td>c</td><td>2.5</td><td>orange</td><td>2020-01-05</td></tr><tr><th>3</th><td>5</td><td>d</td><td>3.2</td><td>lemon</td><td>2020-01-07</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_excel(<span class="hljs-string">&#x27;../data/my_excel.xlsx&#x27;</span>, nrows=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col1</th><th>col2</th><th>col3</th><th>col4</th><th>col5</th></tr></thead><tbody><tr><th>0</th><td>2</td><td>a</td><td>1.4</td><td>apple</td><td>2020/1/1</td></tr><tr><th>1</th><td>3</td><td>b</td><td>3.4</td><td>banana</td><td>2020/1/2</td></tr></tbody></table></div><p>在读取<code>txt</code>文件时，经常遇到分隔符非空格的情况，<code>read_table</code>有一个分割参数<code>sep</code>，它使得用户可以自定义分割符号，进行<code>txt</code>数据的读取。例如，下面的读取的表以<code>||||</code>为分割：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_table(<span class="hljs-string">&#x27;../data/my_table_special_sep.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col1 |||| col2</th></tr></thead><tbody><tr><th>0</th><td>TS |||| This is an apple.</td></tr><tr><th>1</th><td>GQ |||| My name is Bob.</td></tr><tr><th>2</th><td>WT |||| Well done!</td></tr><tr><th>3</th><td>PT |||| May I help you?</td></tr></tbody></table></div><p>上面的结果显然不是理想的，这时可以使用<code>sep</code>，同时需要指定引擎为<code>python</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_table(<span class="hljs-string">&#x27;../data/my_table_special_sep.txt&#x27;</span>, sep=<span class="hljs-string">&#x27; \|\|\|\| &#x27;</span>, engine=<span class="hljs-string">&#x27;python&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col1</th><th>col2</th></tr></thead><tbody><tr><th>0</th><td>TS</td><td>This is an apple.</td></tr><tr><th>1</th><td>GQ</td><td>My name is Bob.</td></tr><tr><th>2</th><td>WT</td><td>Well done!</td></tr><tr><th>3</th><td>PT</td><td>May I help you?</td></tr></tbody></table></div><h4 id="warningsep是正则参数">【WARNING】<code>sep</code>是正则参数</h4><p>在使用<code>read_table</code>的时候需要注意，参数<code>sep</code>中使用的是正则表达式，因此需要对<code>|</code>进行转义变成<code>\|</code>，否则无法读取到正确的结果。有关正则表达式的基本内容可以参考第八章或者其他相关资料。</p><h4 id="end">【END】</h4><h3 id="数据写入">2. 数据写入</h3><p>一般在数据写入中，最常用的操作是把<code>index</code>设置为<code>False</code>，特别当索引没有特殊意义的时候，这样的行为能把索引在保存的时候去除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_csv.to_csv(<span class="hljs-string">&#x27;../data/my_csv_saved.csv&#x27;</span>, index=<span class="hljs-literal">False</span>)<br>df_excel.to_excel(<span class="hljs-string">&#x27;../data/my_excel_saved.xlsx&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><code>pandas</code>中没有定义<code>to_table</code>函数，但是<code>to_csv</code>可以保存为<code>txt</code>文件，并且允许自定义分隔符，常用制表符<code>\t</code>分割：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_txt.to_csv(<span class="hljs-string">&#x27;../data/my_txt_saved.txt&#x27;</span>, sep=<span class="hljs-string">&#x27;\t&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>如果想要把表格快速转换为<code>markdown</code>和<code>latex</code>语言，可以使用<code>to_markdown</code>和<code>to_latex</code>函数，此处需要安装<code>tabulate</code>包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df_csv.to_markdown())<br></code></pre></td></tr></table></figure><pre><code class="hljs">|    |   col1 | col2   |   col3 | col4   | col5     ||---:|-------:|:-------|-------:|:-------|:---------||  0 |      2 | a      |    1.4 | apple  | 2020/1/1 ||  1 |      3 | b      |    3.4 | banana | 2020/1/2 ||  2 |      6 | c      |    2.5 | orange | 2020/1/5 ||  3 |      5 | d      |    3.2 | lemon  | 2020/1/7 |</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df_csv.to_latex())<br></code></pre></td></tr></table></figure><pre><code class="hljs">\begin&#123;tabular&#125;&#123;lrlrll&#125;\toprule&#123;&#125; &amp;  col1 &amp; col2 &amp;  col3 &amp;    col4 &amp;      col5 \\\midrule0 &amp;     2 &amp;    a &amp;   1.4 &amp;   apple &amp;  2020/1/1 \\1 &amp;     3 &amp;    b &amp;   3.4 &amp;  banana &amp;  2020/1/2 \\2 &amp;     6 &amp;    c &amp;   2.5 &amp;  orange &amp;  2020/1/5 \\3 &amp;     5 &amp;    d &amp;   3.2 &amp;   lemon &amp;  2020/1/7 \\\bottomrule\end&#123;tabular&#125;</code></pre><h2 id="二基本数据结构">二、基本数据结构</h2><p><code>pandas</code>中具有两种基本的数据存储结构，存储一维<code>values</code>的<code>Series</code>和存储二维<code>values</code>的<code>DataFrame</code>，在这两种结构上定义了很多的属性和方法。</p><h3 id="series">1. Series</h3><p><code>Series</code>一般由四个部分组成，分别是序列的值<code>data</code>、索引<code>index</code>、存储类型<code>dtype</code>、序列的名字<code>name</code>。其中，索引也可以指定它的名字，默认为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series(data = [<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<span class="hljs-string">&#x27;dic1&#x27;</span>:<span class="hljs-number">5</span>&#125;],<br>              index = pd.Index([<span class="hljs-string">&#x27;id1&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;third&#x27;</span>], name=<span class="hljs-string">&#x27;my_idx&#x27;</span>),<br>              dtype = <span class="hljs-string">&#x27;object&#x27;</span>,<br>              name = <span class="hljs-string">&#x27;my_name&#x27;</span>)<br>s<br></code></pre></td></tr></table></figure><pre><code class="hljs">my_idxid1              10020                 athird    &#123;&#39;dic1&#39;: 5&#125;Name: my_name, dtype: object</code></pre><h4 id="noteobject类型">【NOTE】<code>object</code>类型</h4><p><code>object</code>代表了一种混合类型，正如上面的例子中存储了整数、字符串以及<code>Python</code>的字典数据结构。此外，目前<code>pandas</code>把纯字符串序列也默认认为是一种<code>object</code>类型的序列，但它也可以用<code>string</code>类型存储，文本序列的内容会在第八章中讨论。</p><h4 id="end-1">【END】</h4><p>对于这些属性，可以通过 . 的方式来获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.values<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([100, &#39;a&#39;, &#123;&#39;dic1&#39;: 5&#125;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.index<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;id1&#39;, 20, &#39;third&#39;], dtype=&#39;object&#39;, name=&#39;my_idx&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dtype<br></code></pre></td></tr></table></figure><pre><code class="hljs">dtype(&#39;O&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.name<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;my_name&#39;</code></pre><p>利用<code>.shape</code>可以获取序列的长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.shape<br></code></pre></td></tr></table></figure><pre><code class="hljs">(3,)</code></pre><p>索引是<code>pandas</code>中最重要的概念之一，它将在第三章中被详细地讨论。如果想要取出单个索引对应的值，可以通过<code>[index_item]</code>可以取出。</p><h3 id="dataframe">2. DataFrame</h3><p><code>DataFrame</code>在<code>Series</code>的基础上增加了列索引，一个数据框可以由二维的<code>data</code>与行列索引来构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1.2</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2.2</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3.2</span>]]<br>df = pd.DataFrame(data = data,<br>                  index = [<span class="hljs-string">&#x27;row_%d&#x27;</span>%i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)],<br>                  columns=[<span class="hljs-string">&#x27;col_0&#x27;</span>, <span class="hljs-string">&#x27;col_1&#x27;</span>, <span class="hljs-string">&#x27;col_2&#x27;</span>])<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col_0</th><th>col_1</th><th>col_2</th></tr></thead><tbody><tr><th>row_0</th><td>1</td><td>a</td><td>1.2</td></tr><tr><th>row_1</th><td>2</td><td>b</td><td>2.2</td></tr><tr><th>row_2</th><td>3</td><td>c</td><td>3.2</td></tr></tbody></table></div><p>但一般而言，更多的时候会采用从列索引名到数据的映射来构造数据框，同时再加上行索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(data = &#123;<span class="hljs-string">&#x27;col_0&#x27;</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>                          <span class="hljs-string">&#x27;col_1&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abc&#x27;</span>),<br>                          <span class="hljs-string">&#x27;col_2&#x27;</span>: [<span class="hljs-number">1.2</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.2</span>]&#125;,<br>                  index = [<span class="hljs-string">&#x27;row_%d&#x27;</span>%i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)])<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col_0</th><th>col_1</th><th>col_2</th></tr></thead><tbody><tr><th>row_0</th><td>1</td><td>a</td><td>1.2</td></tr><tr><th>row_1</th><td>2</td><td>b</td><td>2.2</td></tr><tr><th>row_2</th><td>3</td><td>c</td><td>3.2</td></tr></tbody></table></div><p>由于这种映射关系，在<code>DataFrame</code>中可以用<code>[col_name]</code>与<code>[col_list]</code>来取出相应的列与由多个列组成的表，结果分别为<code>Series</code>和<code>DataFrame</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;col_0&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">row_0    1row_1    2row_2    3Name: col_0, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[[<span class="hljs-string">&#x27;col_0&#x27;</span>, <span class="hljs-string">&#x27;col_1&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>col_0</th><th>col_1</th></tr></thead><tbody><tr><th>row_0</th><td>1</td><td>a</td></tr><tr><th>row_1</th><td>2</td><td>b</td></tr><tr><th>row_2</th><td>3</td><td>c</td></tr></tbody></table></div><p>与<code>Series</code>类似，在数据框中同样可以取出相应的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.values<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([[1, &#39;a&#39;, 1.2],       [2, &#39;b&#39;, 2.2],       [3, &#39;c&#39;, 3.2]], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.index<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;row_0&#39;, &#39;row_1&#39;, &#39;row_2&#39;], dtype=&#39;object&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.columns<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;col_0&#39;, &#39;col_1&#39;, &#39;col_2&#39;], dtype=&#39;object&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.dtypes <span class="hljs-comment"># 返回的是值为相应列数据类型的Series</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">col_0      int64col_1     objectcol_2    float64dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.shape<br></code></pre></td></tr></table></figure><pre><code class="hljs">(3, 3)</code></pre><p>通过<code>.T</code>可以把<code>DataFrame</code>进行转置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.T<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>row_0</th><th>row_1</th><th>row_2</th></tr></thead><tbody><tr><th>col_0</th><td>1</td><td>2</td><td>3</td></tr><tr><th>col_1</th><td>a</td><td>b</td><td>c</td></tr><tr><th>col_2</th><td>1.2</td><td>2.2</td><td>3.2</td></tr></tbody></table></div><h2 id="三常用基本函数">三、常用基本函数</h2><p>为了进行举例说明，在接下来的部分和其余章节都将会使用一份<code>learn_pandas.csv</code>的虚拟数据集，它记录了四所学校学生的体测个人信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>)<br>df.columns<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;School&#39;, &#39;Grade&#39;, &#39;Name&#39;, &#39;Gender&#39;, &#39;Height&#39;, &#39;Weight&#39;, &#39;Transfer&#39;,       &#39;Test_Number&#39;, &#39;Test_Date&#39;, &#39;Time_Record&#39;],      dtype=&#39;object&#39;)</code></pre><p>上述列名依次代表学校、年级、姓名、性别、身高、体重、是否为转系生、体测场次、测试时间、1000米成绩，本章只需使用其中的前七列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df = df[df.columns[:<span class="hljs-number">7</span>]]<br></code></pre></td></tr></table></figure><h3 id="汇总函数">1. 汇总函数</h3><p><code>head, tail</code>函数分别表示返回表或者序列的前<code>n</code>行和后<code>n</code>行，其中<code>n</code>默认为5：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.head(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>0</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Gaopeng Yang</td><td>Female</td><td>158.9</td><td>46.0</td><td>N</td></tr><tr><th>1</th><td>Peking University</td><td>Freshman</td><td>Changqiang You</td><td>Male</td><td>166.5</td><td>70.0</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.tail(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Name</th><th>Gender</th><th>Height</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>197</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Chengqiang Chu</td><td>Female</td><td>153.9</td><td>45.0</td><td>N</td></tr><tr><th>198</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Chengmei Shen</td><td>Male</td><td>175.3</td><td>71.0</td><td>N</td></tr><tr><th>199</th><td>Tsinghua University</td><td>Sophomore</td><td>Chunpeng Lv</td><td>Male</td><td>155.7</td><td>51.0</td><td>N</td></tr></tbody></table></div><p><code>info, describe</code>分别返回表的信息概况和表中数值列对应的主要统计量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.info()<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 200 entries, 0 to 199Data columns (total 7 columns): #   Column    Non-Null Count  Dtype  ---  ------    --------------  -----   0   School    200 non-null    object  1   Grade     200 non-null    object  2   Name      200 non-null    object  3   Gender    200 non-null    object  4   Height    183 non-null    float64 5   Weight    189 non-null    float64 6   Transfer  188 non-null    object dtypes: float64(2), object(5)memory usage: 11.1+ KB</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.describe()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Height</th><th>Weight</th></tr></thead><tbody><tr><th>count</th><td>183.000000</td><td>189.000000</td></tr><tr><th>mean</th><td>163.218033</td><td>55.015873</td></tr><tr><th>std</th><td>8.608879</td><td>12.824294</td></tr><tr><th>min</th><td>145.400000</td><td>34.000000</td></tr><tr><th>25%</th><td>157.150000</td><td>46.000000</td></tr><tr><th>50%</th><td>161.900000</td><td>51.000000</td></tr><tr><th>75%</th><td>167.500000</td><td>65.000000</td></tr><tr><th>max</th><td>193.900000</td><td>89.000000</td></tr></tbody></table></div><h4 id="note更全面的数据汇总">【NOTE】更全面的数据汇总</h4><p><code>info, describe</code>只能实现较少信息的展示，如果想要对一份数据集进行全面且有效的观察，特别是在列较多的情况下，推荐使用<ahref="https://pandas-profiling.github.io/pandas-profiling/docs/">pandas-profiling</a>包，它将在第十一章被再次提到。</p><h4 id="end-2">【END】</h4><h3 id="特征统计函数">2. 特征统计函数</h3><p>在<code>Series</code>和<code>DataFrame</code>上定义了许多统计函数，最常见的是<code>sum, mean, median, var, std, max, min</code>。例如，选出身高和体重列进行演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo = df[[<span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>]]<br>df_demo.mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Height    163.218033Weight     55.015873dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.<span class="hljs-built_in">max</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Height    193.9Weight     89.0dtype: float64</code></pre><p>此外，需要介绍的是<code>quantile, count, idxmax</code>这三个函数，它们分别返回的是分位数、非缺失值个数、最大值对应的索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.quantile(<span class="hljs-number">0.75</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Height    167.5Weight     65.0Name: 0.75, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.count()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Height    183Weight    189dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.idxmax() <span class="hljs-comment"># idxmin是对应的函数</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">Height    193Weight      2dtype: int64</code></pre><p>上面这些所有的函数，由于操作后返回的是标量，所以又称为聚合函数，它们有一个公共参数<code>axis</code>，默认为0代表逐列聚合，如果设置为1则表示逐行聚合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.mean(axis=<span class="hljs-number">1</span>).head() <span class="hljs-comment"># 在这个数据集上体重和身高的均值并没有意义</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    102.451    118.252    138.953     41.004    124.00dtype: float64</code></pre><h3 id="唯一值函数">3. 唯一值函数</h3><p>对序列使用<code>unique</code>和<code>nunique</code>可以分别得到其唯一值组成的列表和唯一值的个数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;School&#x27;</span>].unique()<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([&#39;Shanghai Jiao Tong University&#39;, &#39;Peking University&#39;,       &#39;Fudan University&#39;, &#39;Tsinghua University&#39;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;School&#x27;</span>].nunique()<br></code></pre></td></tr></table></figure><pre><code class="hljs">4</code></pre><p><code>value_counts</code>可以得到唯一值和其对应出现的频数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;School&#x27;</span>].value_counts()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Tsinghua University              69Shanghai Jiao Tong University    57Fudan University                 40Peking University                34Name: School, dtype: int64</code></pre><p>如果想要观察多个列组合的唯一值，可以使用<code>drop_duplicates</code>。其中的关键参数是<code>keep</code>，默认值<code>first</code>表示每个组合保留第一次出现的所在行，<code>last</code>表示保留最后一次出现的所在行，<code>False</code>表示把所有重复组合所在的行剔除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo = df[[<span class="hljs-string">&#x27;Gender&#x27;</span>,<span class="hljs-string">&#x27;Transfer&#x27;</span>,<span class="hljs-string">&#x27;Name&#x27;</span>]]<br>df_demo.drop_duplicates([<span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Transfer&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Gender</th><th>Transfer</th><th>Name</th></tr></thead><tbody><tr><th>0</th><td>Female</td><td>N</td><td>Gaopeng Yang</td></tr><tr><th>1</th><td>Male</td><td>N</td><td>Changqiang You</td></tr><tr><th>12</th><td>Female</td><td>NaN</td><td>Peng You</td></tr><tr><th>21</th><td>Male</td><td>NaN</td><td>Xiaopeng Shen</td></tr><tr><th>36</th><td>Male</td><td>Y</td><td>Xiaojuan Qin</td></tr><tr><th>43</th><td>Female</td><td>Y</td><td>Gaoli Feng</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.drop_duplicates([<span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Transfer&#x27;</span>], keep=<span class="hljs-string">&#x27;last&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Gender</th><th>Transfer</th><th>Name</th></tr></thead><tbody><tr><th>147</th><td>Male</td><td>NaN</td><td>Juan You</td></tr><tr><th>150</th><td>Male</td><td>Y</td><td>Chengpeng You</td></tr><tr><th>169</th><td>Female</td><td>Y</td><td>Chengquan Qin</td></tr><tr><th>194</th><td>Female</td><td>NaN</td><td>Yanmei Qian</td></tr><tr><th>197</th><td>Female</td><td>N</td><td>Chengqiang Chu</td></tr><tr><th>199</th><td>Male</td><td>N</td><td>Chunpeng Lv</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.drop_duplicates([<span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>], keep=<span class="hljs-literal">False</span>).head() <span class="hljs-comment"># 保留只出现过一次的性别和姓名组合</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Gender</th><th>Transfer</th><th>Name</th></tr></thead><tbody><tr><th>0</th><td>Female</td><td>N</td><td>Gaopeng Yang</td></tr><tr><th>1</th><td>Male</td><td>N</td><td>Changqiang You</td></tr><tr><th>2</th><td>Male</td><td>N</td><td>Mei Sun</td></tr><tr><th>4</th><td>Male</td><td>N</td><td>Gaojuan You</td></tr><tr><th>5</th><td>Female</td><td>N</td><td>Xiaoli Qian</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;School&#x27;</span>].drop_duplicates() <span class="hljs-comment"># 在Series上也可以使用</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    Shanghai Jiao Tong University1                Peking University3                 Fudan University5              Tsinghua UniversityName: School, dtype: object</code></pre><p>此外，<code>duplicated</code>和<code>drop_duplicates</code>的功能类似，但前者返回了是否为唯一值的布尔列表，其<code>keep</code>参数与后者一致。其返回的序列，把重复元素设为<code>True</code>，否则为<code>False</code>。<code>drop_duplicates</code>等价于把<code>duplicated</code>为<code>True</code>的对应行剔除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.duplicated([<span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Transfer&#x27;</span>]).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2     True3     True4     Truedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;School&#x27;</span>].duplicated().head() <span class="hljs-comment"># 在Series上也可以使用</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2     True3    False4     TrueName: School, dtype: bool</code></pre><h3 id="替换函数">4. 替换函数</h3><p>一般而言，替换操作是针对某一个列进行的，因此下面的例子都以<code>Series</code>举例。<code>pandas</code>中的替换函数可以归纳为三类：映射替换、逻辑替换、数值替换。其中映射替换包含<code>replace</code>方法、第八章中的<code>str.replace</code>方法以及第九章中的<code>cat.codes</code>方法，此处介绍<code>replace</code>的用法。</p><p>在<code>replace</code>中，可以通过字典构造，或者传入两个列表来进行替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;Gender&#x27;</span>].replace(&#123;<span class="hljs-string">&#x27;Female&#x27;</span>:<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Male&#x27;</span>:<span class="hljs-number">1</span>&#125;).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    01    12    13    04    1Name: Gender, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;Gender&#x27;</span>].replace([<span class="hljs-string">&#x27;Female&#x27;</span>, <span class="hljs-string">&#x27;Male&#x27;</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    01    12    13    04    1Name: Gender, dtype: int64</code></pre><p>另外，<code>replace</code>还有一种特殊的方向替换，指定<code>method</code>参数为<code>ffill</code>则为用前面一个最近的未被替换的值进行替换，<code>bfill</code>则使用后面最近的未被替换的值进行替换。从下面的例子可以看到，它们的结果是不同的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>])<br>s.replace([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], method=<span class="hljs-string">&#x27;ffill&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    a1    a2    b3    b4    b5    b6    adtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.replace([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], method=<span class="hljs-string">&#x27;bfill&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    a1    b2    b3    a4    a5    a6    adtype: object</code></pre><h4id="warning正则替换请使用str.replace">【WARNING】正则替换请使用<code>str.replace</code></h4><p>虽然对于<code>replace</code>而言可以使用正则替换，但是当前版本下对于<code>string</code>类型的正则替换还存在<code>bug</code>，因此如有此需求，请选择<code>str.replace</code>进行替换操作，具体的方式将在第八章中讲解。</p><h4 id="end-3">【END】</h4><p>逻辑替换包括了<code>where</code>和<code>mask</code>，这两个函数是完全对称的：<code>where</code>函数在传入条件为<code>False</code>的对应行进行替换，而<code>mask</code>在传入条件为<code>True</code>的对应行进行替换，当不指定替换值时，替换为缺失值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([-<span class="hljs-number">1</span>, <span class="hljs-number">1.2345</span>, <span class="hljs-number">100</span>, -<span class="hljs-number">50</span>])<br>s.where(s&lt;<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    -1.01     NaN2     NaN3   -50.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.where(s&lt;<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     -1.01    100.02    100.03    -50.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.mask(s&lt;<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0         NaN1      1.23452    100.00003         NaNdtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.mask(s&lt;<span class="hljs-number">0</span>, -<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    -50.00001      1.23452    100.00003    -50.0000dtype: float64</code></pre><p>需要注意的是，传入的条件只需是与被调用的<code>Series</code>索引一致的布尔序列即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s_condition= pd.Series([<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">True</span>],index=s.index)<br>s.mask(s_condition, -<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    -50.00001      1.23452    100.00003    -50.0000dtype: float64</code></pre><p>数值替换包含了<code>round, abs, clip</code>方法，它们分别表示按照给定精度四舍五入、取绝对值和截断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([-<span class="hljs-number">1</span>, <span class="hljs-number">1.2345</span>, <span class="hljs-number">100</span>, -<span class="hljs-number">50</span>])<br>s.<span class="hljs-built_in">round</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     -1.001      1.232    100.003    -50.00dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">abs</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      1.00001      1.23452    100.00003     50.0000dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.clip(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 前两个数分别表示上下截断边界</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    0.00001    1.23452    2.00003    0.0000dtype: float64</code></pre><h4 id="练一练">【练一练】</h4><p>在 clip中，超过边界的只能截断为边界值，如果要把超出边界的替换为自定义的值，应当如何做？</p><h4 id="end-4">【END】</h4><h3 id="排序函数">5. 排序函数</h3><p>排序共有两种方式，其一为值排序，其二为索引排序，对应的函数是<code>sort_values</code>和<code>sort_index</code>。</p><p>为了演示排序函数，下面先利用<code>set_index</code>方法把年级和姓名两列作为索引，多级索引的内容和索引设置的方法将在第三章进行详细讲解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo = df[[<span class="hljs-string">&#x27;Grade&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>]].set_index([<span class="hljs-string">&#x27;Grade&#x27;</span>,<span class="hljs-string">&#x27;Name&#x27;</span>])<br>df_demo.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Height</th><th>Weight</th></tr><tr><th>Grade</th><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">Freshman</th><th>Gaopeng Yang</th><td>158.9</td><td>46.0</td></tr><tr><th>Changqiang You</th><td>166.5</td><td>70.0</td></tr><tr><th>Senior</th><th>Mei Sun</th><td>188.9</td><td>89.0</td></tr></tbody></table></div><p>对身高进行排序，默认参数<code>ascending=True</code>为升序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.sort_values(<span class="hljs-string">&#x27;Height&#x27;</span>).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Height</th><th>Weight</th></tr><tr><th>Grade</th><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>Junior</th><th>Xiaoli Chu</th><td>145.4</td><td>34.0</td></tr><tr><th>Senior</th><th>Gaomei Lv</th><td>147.3</td><td>34.0</td></tr><tr><th>Sophomore</th><th>Peng Han</th><td>147.8</td><td>34.0</td></tr><tr><th>Senior</th><th>Changli Lv</th><td>148.7</td><td>41.0</td></tr><tr><th>Sophomore</th><th>Changjuan You</th><td>150.5</td><td>40.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.sort_values(<span class="hljs-string">&#x27;Height&#x27;</span>, ascending=<span class="hljs-literal">False</span>).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Height</th><th>Weight</th></tr><tr><th>Grade</th><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="3" valign="top">Senior</th><th>Xiaoqiang Qin</th><td>193.9</td><td>79.0</td></tr><tr><th>Mei Sun</th><td>188.9</td><td>89.0</td></tr><tr><th>Gaoli Zhao</th><td>186.5</td><td>83.0</td></tr><tr><th>Freshman</th><th>Qiang Han</th><td>185.3</td><td>87.0</td></tr><tr><th>Senior</th><th>Qiang Zheng</th><td>183.9</td><td>87.0</td></tr></tbody></table></div><p>在排序中，经常遇到多列排序的问题，比如在体重相同的情况下，对身高进行排序，并且保持身高降序排列，体重升序排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.sort_values([<span class="hljs-string">&#x27;Weight&#x27;</span>,<span class="hljs-string">&#x27;Height&#x27;</span>],ascending=[<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>]).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Height</th><th>Weight</th></tr><tr><th>Grade</th><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>Sophomore</th><th>Peng Han</th><td>147.8</td><td>34.0</td></tr><tr><th>Senior</th><th>Gaomei Lv</th><td>147.3</td><td>34.0</td></tr><tr><th>Junior</th><th>Xiaoli Chu</th><td>145.4</td><td>34.0</td></tr><tr><th>Sophomore</th><th>Qiang Zhou</th><td>150.5</td><td>36.0</td></tr><tr><th>Freshman</th><th>Yanqiang Xu</th><td>152.4</td><td>38.0</td></tr></tbody></table></div><p>索引排序的用法和值排序完全一致，只不过元素的值在索引中，此时需要指定索引层的名字或者层号，用参数<code>level</code>表示。另外，需要注意的是字符串的排列顺序由字母顺序决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.sort_index(level=[<span class="hljs-string">&#x27;Grade&#x27;</span>,<span class="hljs-string">&#x27;Name&#x27;</span>],ascending=[<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>]).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Height</th><th>Weight</th></tr><tr><th>Grade</th><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="5" valign="top">Freshman</th><th>Yanquan Wang</th><td>163.5</td><td>55.0</td></tr><tr><th>Yanqiang Xu</th><td>152.4</td><td>38.0</td></tr><tr><th>Yanqiang Feng</th><td>162.3</td><td>51.0</td></tr><tr><th>Yanpeng Lv</th><td>NaN</td><td>65.0</td></tr><tr><th>Yanli Zhang</th><td>165.1</td><td>52.0</td></tr></tbody></table></div><h3 id="apply方法">6. apply方法</h3><p><code>apply</code>方法常用于<code>DataFrame</code>的行迭代或者列迭代，它的<code>axis</code>含义与第2小节中的统计聚合函数一致，<code>apply</code>的参数往往是一个以序列为输入的函数。例如对于<code>.mean()</code>，使用<code>apply</code>可以如下地写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo = df[[<span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>]]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_mean</span>(<span class="hljs-params">x</span>):<br>     res = x.mean()<br>     <span class="hljs-keyword">return</span> res<br>df_demo.apply(my_mean)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Height    163.218033Weight     55.015873dtype: float64</code></pre><p>同样的，可以利用<code>lambda</code>表达式使得书写简洁，这里的<code>x</code>就指代被调用的<code>df_demo</code>表中逐个输入的序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.apply(<span class="hljs-keyword">lambda</span> x:x.mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">Height    163.218033Weight     55.015873dtype: float64</code></pre><p>若指定<code>axis=1</code>，那么每次传入函数的就是行元素组成的<code>Series</code>，其结果与之前的逐行均值结果一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.apply(<span class="hljs-keyword">lambda</span> x:x.mean(), axis=<span class="hljs-number">1</span>).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    102.451    118.252    138.953     41.004    124.00dtype: float64</code></pre><p>这里再举一个例子：<code>mad</code>函数返回的是一个序列中偏离该序列均值的绝对值大小的均值，例如序列1,3,7,10中，均值为5.25，每一个元素偏离的绝对值为4.25,2.25,1.75,4.75，这个偏离序列的均值为3.25。现在利用<code>apply</code>计算升高和体重的<code>mad</code>指标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.apply(<span class="hljs-keyword">lambda</span> x:(x-x.mean()).<span class="hljs-built_in">abs</span>().mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">Height     6.707229Weight    10.391870dtype: float64</code></pre><p>这与使用内置的<code>mad</code>函数计算结果一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.mad()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Height     6.707229Weight    10.391870dtype: float64</code></pre><h4 id="warning谨慎使用apply">【WARNING】谨慎使用<code>apply</code></h4><p>得益于传入自定义函数的处理，<code>apply</code>的自由度很高，但这是以性能为代价的。一般而言，使用<code>pandas</code>的内置函数处理和<code>apply</code>来处理同一个任务，其速度会相差较多，因此只有在确实存在自定义需求的情境下才考虑使用<code>apply</code>。</p><h4 id="end-5">【END】</h4><h2 id="四窗口对象">四、窗口对象</h2><p><code>pandas</code>中有3类窗口，分别是滑动窗口<code>rolling</code>、扩张窗口<code>expanding</code>以及指数加权窗口<code>ewm</code>。需要说明的是，以日期偏置为窗口大小的滑动窗口将在第十章讨论，指数加权窗口见本章练习。</p><h3 id="滑窗对象">1. 滑窗对象</h3><p>要使用滑窗函数，就必须先要对一个序列使用<code>.rolling</code>得到滑窗对象，其最重要的参数为窗口大小<code>window</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>roller = s.rolling(window = <span class="hljs-number">3</span>)<br>roller<br></code></pre></td></tr></table></figure><pre><code class="hljs">Rolling [window=3,center=False,axis=0]</code></pre><p>在得到了滑窗对象后，能够使用相应的聚合函数进行计算，需要注意的是窗口包含当前行所在的元素，例如在第四个位置进行均值运算时，应当计算(2+3+4)/3，而不是(1+2+3)/3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">roller.mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    NaN1    NaN2    2.03    3.04    4.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">roller.<span class="hljs-built_in">sum</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     NaN1     NaN2     6.03     9.04    12.0dtype: float64</code></pre><p>对于滑动相关系数或滑动协方差的计算，可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s2 = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">16</span>,<span class="hljs-number">30</span>])<br>roller.cov(s2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     NaN1     NaN2     2.53     7.04    12.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">roller.corr(s2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0         NaN1         NaN2    0.9449113    0.9707254    0.995402dtype: float64</code></pre><p>此外，还支持使用<code>apply</code>传入自定义函数，其传入值是对应窗口的<code>Series</code>，例如上述的均值函数可以等效表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">roller.apply(<span class="hljs-keyword">lambda</span> x:x.mean())<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    NaN1    NaN2    2.03    3.04    4.0dtype: float64</code></pre><p><code>shift, diff, pct_change</code>是一组类滑窗函数，它们的公共参数为<code>periods=n</code>，默认为1，分别表示取向前第<code>n</code>个元素的值、与向前第<code>n</code>个元素做差（与<code>Numpy</code>中不同，后者表示<code>n</code>阶差分）、与向前第<code>n</code>个元素相比计算增长率。这里的<code>n</code>可以为负，表示反方向的类似操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>])<br>s.shift(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    NaN1    NaN2    1.03    3.04    6.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.diff(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     NaN1     NaN2     NaN3     9.04    12.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.pct_change()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0         NaN1    2.0000002    1.0000003    0.6666674    0.500000dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.shift(-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     3.01     6.02    10.03    15.04     NaNdtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.diff(-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   -5.01   -7.02   -9.03    NaN4    NaNdtype: float64</code></pre><p>将其视作类滑窗函数的原因是，它们的功能可以用窗口大小为<code>n+1</code>的<code>rolling</code>方法等价代替：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.rolling(<span class="hljs-number">3</span>).apply(<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">list</span>(x)[<span class="hljs-number">0</span>]) <span class="hljs-comment"># s.shift(2)</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    NaN1    NaN2    1.03    3.04    6.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.rolling(<span class="hljs-number">4</span>).apply(<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">list</span>(x)[-<span class="hljs-number">1</span>]-<span class="hljs-built_in">list</span>(x)[<span class="hljs-number">0</span>]) <span class="hljs-comment"># s.diff(3)</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0     NaN1     NaN2     NaN3     9.04    12.0dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_pct</span>(<span class="hljs-params">x</span>):<br>     L = <span class="hljs-built_in">list</span>(x)<br>     <span class="hljs-keyword">return</span> L[-<span class="hljs-number">1</span>]/L[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span><br>s.rolling(<span class="hljs-number">2</span>).apply(my_pct) <span class="hljs-comment"># s.pct_change()</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0         NaN1    2.0000002    1.0000003    0.6666674    0.500000dtype: float64</code></pre><h4 id="练一练-1">【练一练】</h4><p><code>rolling</code>对象的默认窗口方向都是向前的，某些情况下用户需要向后的窗口，例如对1,2,3设定向后窗口为2的<code>sum</code>操作，结果为3,5,NaN，此时应该如何实现向后的滑窗操作？</p><h4 id="end-6">【END】</h4><h3 id="扩张窗口">2. 扩张窗口</h3><p>扩张窗口又称累计窗口，可以理解为一个动态长度的窗口，其窗口的大小就是从序列开始处到具体操作的对应位置，其使用的聚合函数会作用于这些逐步扩张的窗口上。具体地说，设序列为a1,a2, a3, a4，则其每个位置对应的窗口即[a1]、[a1, a2]、[a1, a2, a3]、[a1,a2, a3, a4]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>])<br>s.expanding().mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    1.0000001    2.0000002    3.3333333    5.000000dtype: float64</code></pre><h4 id="练一练-2">【练一练】</h4><p><code>cummax, cumsum, cumprod</code>函数是典型的类扩张窗口函数，请使用<code>expanding</code>对象依次实现它们。</p><h4 id="end-7">【END】</h4><h2 id="五练习">五、练习</h2><h3 id="ex1口袋妖怪数据集">Ex1：口袋妖怪数据集</h3><p>现有一份口袋妖怪的数据集，下面进行一些背景说明：</p><ul><li><p><code>#</code>代表全国图鉴编号，不同行存在相同数字则表示为该妖怪的不同状态</p></li><li><p>妖怪具有单属性和双属性两种，对于单属性的妖怪，<code>Type 2</code>为缺失值</p></li><li><p><code>Total, HP, Attack, Defense, Sp. Atk, Sp. Def, Speed</code>分别代表种族值、体力、物攻、防御、特攻、特防、速度，其中种族值为后6项之和</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/pokemon.csv&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>#</th><th>Name</th><th>Type 1</th><th>Type 2</th><th>Total</th><th>HP</th><th>Attack</th><th>Defense</th><th>Sp. Atk</th><th>Sp. Def</th><th>Speed</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>Bulbasaur</td><td>Grass</td><td>Poison</td><td>318</td><td>45</td><td>49</td><td>49</td><td>65</td><td>65</td><td>45</td></tr><tr><th>1</th><td>2</td><td>Ivysaur</td><td>Grass</td><td>Poison</td><td>405</td><td>60</td><td>62</td><td>63</td><td>80</td><td>80</td><td>60</td></tr><tr><th>2</th><td>3</td><td>Venusaur</td><td>Grass</td><td>Poison</td><td>525</td><td>80</td><td>82</td><td>83</td><td>100</td><td>100</td><td>80</td></tr></tbody></table></div><ol type="1"><li><p>对<code>HP, Attack, Defense, Sp. Atk, Sp. Def, Speed</code>进行加总，验证是否为<code>Total</code>值。</p></li><li><p>对于<code>#</code>重复的妖怪只保留第一条记录，解决以下问题：</p></li></ol><ul><li>求第一属性的种类数量和前三多数量对应的种类</li><li>求第一属性和第二属性的组合种类</li><li>求尚未出现过的属性组合</li></ul><ol start="3" type="1"><li>按照下述要求，构造<code>Series</code>：</li></ol><ul><li>取出物攻，超过120的替换为<code>high</code>，不足50的替换为<code>low</code>，否则设为<code>mid</code></li><li>取出第一属性，分别用<code>replace</code>和<code>apply</code>替换所有字母为大写</li><li>求每个妖怪六项能力的离差，即所有能力中偏离中位数最大的值，添加到<code>df</code>并从大到小排序</li></ul><h3 id="ex2指数加权窗口">Ex2：指数加权窗口</h3><ol type="1"><li>作为扩张窗口的<code>ewm</code>窗口</li></ol><p>在扩张窗口中，用户可以使用各类函数进行历史的累计指标统计，但这些内置的统计函数往往把窗口中的所有元素赋予了同样的权重。事实上，可以给出不同的权重来赋给窗口中的元素，指数加权窗口就是这样一种特殊的扩张窗口。</p><p>其中，最重要的参数是<code>alpha</code>，它决定了默认情况下的窗口权重为<spanclass="math inline">\(w_i=(1−\alpha)^i,i\in\{0,1,...,t\}\)</span>，其中<spanclass="math inline">\(i=t\)</span>表示当前元素，<spanclass="math inline">\(i=0\)</span>表示序列的第一个元素。</p><p>从权重公式可以看出，离开当前值越远则权重越小，若记原序列为<spanclass="math inline">\(x\)</span>，更新后的当前元素为<spanclass="math inline">\(y_t\)</span>，此时通过加权公式归一化后可知：</p><p><span class="math display">\[\begin{split}y_t &amp;=\frac{\sum_{i=0}^{t} w_i x_{t-i}}{\sum_{i=0}^{t}w_i} \\&amp;=\frac{x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...+ (1 - \alpha)^{t} x_{0}}{1 + (1 - \alpha) + (1 - \alpha)^2 + ...+ (1 - \alpha)^{t}}\\\end{split}\]</span></p><p>对于<code>Series</code>而言，可以用<code>ewm</code>对象如下计算指数平滑后的序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>s = pd.Series(np.random.randint(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">30</span>).cumsum())<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   -11   -12   -23   -24   -2dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.ewm(alpha=<span class="hljs-number">0.2</span>).mean().head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   -1.0000001   -1.0000002   -1.4098363   -1.6097564   -1.725845dtype: float64</code></pre><p>请用<code>expanding</code>窗口实现。</p><ol start="2" type="1"><li>作为滑动窗口的<code>ewm</code>窗口</li></ol><p>从第1问中可以看到，<code>ewm</code>作为一种扩张窗口的特例，只能从序列的第一个元素开始加权。现在希望给定一个限制窗口<code>n</code>，只对包含自身的最近的<code>n</code>个元素作为窗口进行滑动加权平滑。请根据滑窗函数，给出新的<code>wi</code>与<code>yt</code>的更新公式，并通过<code>rolling</code>窗口实现这一功能。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas索引</title>
    <link href="/2023/10/01/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/10/01/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h1 id="pandas索引">Pandas索引</h1><h2 id="一索引器">一、索引器</h2><h3 id="表的列索引">1. 表的列索引</h3><p>列索引是最常见的索引形式，一般通过<code>[]</code>来实现。通过<code>[列名]</code>可以从<code>DataFrame</code>中取出相应的列，返回值为<code>Series</code>，例如从表中取出姓名一列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>, usecols = [<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>, <span class="hljs-string">&#x27;Transfer&#x27;</span>])<br>df[<span class="hljs-string">&#x27;Name&#x27;</span>].head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      Gaopeng Yang1    Changqiang You2           Mei Sun3      Xiaojuan Sun4       Gaojuan YouName: Name, dtype: object</code></pre><p>如果要取出多个列，则可以通过<code>[列名组成的列表]</code>，其返回值为一个<code>DataFrame</code>，例如从表中取出性别和姓名两列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[[<span class="hljs-string">&#x27;Gender&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>]].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Gender</th><th>Name</th></tr></thead><tbody><tr><th>0</th><td>Female</td><td>Gaopeng Yang</td></tr><tr><th>1</th><td>Male</td><td>Changqiang You</td></tr><tr><th>2</th><td>Male</td><td>Mei Sun</td></tr><tr><th>3</th><td>Female</td><td>Xiaojuan Sun</td></tr><tr><th>4</th><td>Male</td><td>Gaojuan You</td></tr></tbody></table></div><p>此外，若要取出单列，且列名中不包含空格，则可以用<code>.列名</code>取出，这和<code>[列名]</code>是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.Name.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      Gaopeng Yang1    Changqiang You2           Mei Sun3      Xiaojuan Sun4       Gaojuan YouName: Name, dtype: object</code></pre><h3 id="序列的行索引">2. 序列的行索引</h3><p>【a】以字符串为索引的<code>Series</code></p><p>如果取出单个索引的对应元素，则可以使用<code>[item]</code>，若<code>Series</code>只有单个值对应，则返回这个标量值，如果有多个值对应，则返回一个<code>Series</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], index=[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>])<br>s[<span class="hljs-string">&#x27;a&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">a    1a    3a    4a    5dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;b&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">2</code></pre><p>如果取出多个索引的对应元素，则可以使用<code>[items的列表]</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[[<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]]<br></code></pre></td></tr></table></figure><pre><code class="hljs">c    6b    2dtype: int64</code></pre><p>如果想要取出某两个索引之间的元素，并且这两个索引是在整个索引中唯一出现，则可以使用切片,，同时需要注意这里的切片会包含两个端点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>: -<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">c    6a    4b    2dtype: int64</code></pre><p>如果前后端点的值重复出现，那么需要经过排序才能使用切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    s[<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>]<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure><pre><code class="hljs">KeyError(&quot;Cannot get left slice bound for non-unique label: &#39;a&#39;&quot;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.sort_index()[<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">a    1a    3a    4a    5b    2dtype: int64</code></pre><p>【b】以整数为索引的<code>Series</code></p><p>在使用数据的读入函数时，如果不特别指定所对应的列作为索引，那么会生成从0开始的整数索引作为默认索引。当然，任意一组符合长度要求的整数都可以作为索引。</p><p>和字符串一样，如果使用<code>[int]</code>或<code>[int_list]</code>，则可以取出对应索引<strong>元素</strong>的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>], index=[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>])<br>s[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">1    a1    cdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure><pre><code class="hljs">2    d3    bdtype: object</code></pre><p>如果使用整数切片，则会取出对应索引<strong>位置</strong>的值，注意这里的整数切片同<code>Python</code>中的切片一样不包含右端点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">3    b2    ddtype: object</code></pre><h4 id="warning关于索引类型的说明">【WARNING】关于索引类型的说明</h4><p>如果不想陷入麻烦，那么请不要把纯浮点以及任何混合类型（字符串、整数、浮点类型等的混合）作为索引，否则可能会在具体的操作时报错或者返回非预期的结果，并且在实际的数据分析中也不存在这样做的动机。</p><h4 id="end">【END】</h4><h3 id="loc索引器">3. loc索引器</h3><p>前面讲到了对<code>DataFrame</code>的列进行选取，下面要讨论其行的选取。对于表而言，有两种索引器，一种是基于<strong>元素</strong>的<code>loc</code>索引器，另一种是基于<strong>位置</strong>的<code>iloc</code>索引器。</p><p><code>loc</code>索引器的一般形式是<code>loc[*, *]</code>，其中第一个<code>*</code>代表行的选择，第二个<code>*</code>代表列的选择，如果省略第二个位置写作<code>loc[*]</code>，这个<code>*</code>是指行的筛选。其中，<code>*</code>的位置一共有五类合法对象，分别是：单个元素、元素列表、元素切片、布尔列表以及函数，下面将依次说明。</p><p>为了演示相应操作，先利用<code>set_index</code>方法把<code>Name</code>列设为索引，关于该函数的其他用法将在多级索引一章介绍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo = df.set_index(<span class="hljs-string">&#x27;Name&#x27;</span>)<br>df_demo.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Gaopeng Yang</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Female</td><td>46.0</td><td>N</td></tr><tr><th>Changqiang You</th><td>Peking University</td><td>Freshman</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>Mei Sun</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>Xiaojuan Sun</th><td>Fudan University</td><td>Sophomore</td><td>Female</td><td>41.0</td><td>N</td></tr><tr><th>Gaojuan You</th><td>Fudan University</td><td>Sophomore</td><td>Male</td><td>74.0</td><td>N</td></tr></tbody></table></div><p>【a】<code>*</code>为单个元素</p><p>此时，直接取出相应的行或列，如果该元素在索引中重复则结果为<code>DataFrame</code>，否则为<code>Series</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Qiang Sun&#x27;</span>] <span class="hljs-comment"># 多个人叫此名字</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Qiang Sun</th><td>Tsinghua University</td><td>Junior</td><td>Female</td><td>53.0</td><td>N</td></tr><tr><th>Qiang Sun</th><td>Tsinghua University</td><td>Sophomore</td><td>Female</td><td>40.0</td><td>N</td></tr><tr><th>Qiang Sun</th><td>Shanghai Jiao Tong University</td><td>Junior</td><td>Female</td><td>NaN</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Quan Zhao&#x27;</span>] <span class="hljs-comment"># 名字唯一</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">School      Shanghai Jiao Tong UniversityGrade                              JuniorGender                             FemaleWeight                               53.0Transfer                                NName: Quan Zhao, dtype: object</code></pre><p>也可以同时选择行和列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Qiang Sun&#x27;</span>, <span class="hljs-string">&#x27;School&#x27;</span>] <span class="hljs-comment"># 返回Series</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">NameQiang Sun              Tsinghua UniversityQiang Sun              Tsinghua UniversityQiang Sun    Shanghai Jiao Tong UniversityName: School, dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Quan Zhao&#x27;</span>, <span class="hljs-string">&#x27;School&#x27;</span>] <span class="hljs-comment"># 返回单个元素</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;Shanghai Jiao Tong University&#39;</code></pre><p>【b】<code>*</code>为元素列表</p><p>此时，取出列表中所有元素值对应的行或列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[[<span class="hljs-string">&#x27;Qiang Sun&#x27;</span>,<span class="hljs-string">&#x27;Quan Zhao&#x27;</span>], [<span class="hljs-string">&#x27;School&#x27;</span>,<span class="hljs-string">&#x27;Gender&#x27;</span>]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Gender</th></tr><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>Qiang Sun</th><td>Tsinghua University</td><td>Female</td></tr><tr><th>Qiang Sun</th><td>Tsinghua University</td><td>Female</td></tr><tr><th>Qiang Sun</th><td>Shanghai Jiao Tong University</td><td>Female</td></tr><tr><th>Quan Zhao</th><td>Shanghai Jiao Tong University</td><td>Female</td></tr></tbody></table></div><p>【c】<code>*</code>为切片</p><p>之前的<code>Series</code>使用字符串索引时提到，如果是唯一值的起点和终点字符，那么就可以使用切片，并且包含两个端点，如果不唯一则报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-string">&#x27;Gaojuan You&#x27;</span>:<span class="hljs-string">&#x27;Gaoqiang Qian&#x27;</span>, <span class="hljs-string">&#x27;School&#x27;</span>:<span class="hljs-string">&#x27;Gender&#x27;</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th></tr><tr><th>Name</th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Gaojuan You</th><td>Fudan University</td><td>Sophomore</td><td>Male</td></tr><tr><th>Xiaoli Qian</th><td>Tsinghua University</td><td>Freshman</td><td>Female</td></tr><tr><th>Qiang Chu</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Female</td></tr><tr><th>Gaoqiang Qian</th><td>Tsinghua University</td><td>Junior</td><td>Female</td></tr></tbody></table></div><p>需要注意的是，如果<code>DataFrame</code>使用整数索引，其使用整数切片的时候和上面字符串索引的要求一致，都是<strong>元素</strong>切片，包含端点且起点、终点不允许有重复值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df_loc_slice_demo = df_demo.copy()<br>df_loc_slice_demo.index = <span class="hljs-built_in">range</span>(df_demo.shape[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<br>df_loc_slice_demo.loc[<span class="hljs-number">5</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>5</th><td>Fudan University</td><td>Junior</td><td>Female</td><td>46.0</td><td>N</td></tr><tr><th>4</th><td>Tsinghua University</td><td>Senior</td><td>Female</td><td>50.0</td><td>N</td></tr><tr><th>3</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Female</td><td>45.0</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_loc_slice_demo.loc[<span class="hljs-number">3</span>:<span class="hljs-number">5</span>] <span class="hljs-comment"># 没有返回，说明不是整数位置切片</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody></tbody></table></div><p>【d】<code>*</code>为布尔列表</p><p>在实际的数据处理中，根据条件来筛选行是极其常见的，此处传入<code>loc</code>的布尔列表与<code>DataFrame</code>长度相同，且列表为<code>True</code>的位置所对应的行会被选中，<code>False</code>则会被剔除。</p><p>例如，选出体重超过70kg的学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[df_demo.Weight&gt;<span class="hljs-number">70</span>].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Mei Sun</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>Gaojuan You</th><td>Fudan University</td><td>Sophomore</td><td>Male</td><td>74.0</td><td>N</td></tr><tr><th>Xiaopeng Zhou</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Male</td><td>74.0</td><td>N</td></tr><tr><th>Xiaofeng Sun</th><td>Tsinghua University</td><td>Senior</td><td>Male</td><td>71.0</td><td>N</td></tr><tr><th>Qiang Zheng</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Male</td><td>87.0</td><td>N</td></tr></tbody></table></div><p>前面所提到的传入元素列表，也可以通过<code>isin</code>方法返回的布尔列表等价写出，例如选出所有大一和大四的同学信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[df_demo.Grade.isin([<span class="hljs-string">&#x27;Freshman&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>])].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Gaopeng Yang</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Female</td><td>46.0</td><td>N</td></tr><tr><th>Changqiang You</th><td>Peking University</td><td>Freshman</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>Mei Sun</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>Xiaoli Qian</th><td>Tsinghua University</td><td>Freshman</td><td>Female</td><td>51.0</td><td>N</td></tr><tr><th>Qiang Chu</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Female</td><td>52.0</td><td>N</td></tr></tbody></table></div><p>对于复合条件而言，可以用<code>|（或）, &amp;（且）, ~（取反）</code>的组合来实现，例如选出复旦大学中体重超过70kg的大四学生，或者北大男生中体重超过80kg的非大四的学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">condition_1_1 = df_demo.School == <span class="hljs-string">&#x27;Fudan University&#x27;</span><br>condition_1_2 = df_demo.Grade == <span class="hljs-string">&#x27;Senior&#x27;</span><br>condition_1_3 = df_demo.Weight &gt; <span class="hljs-number">70</span><br>condition_1 = condition_1_1 &amp; condition_1_2 &amp; condition_1_3<br>condition_2_1 = df_demo.School == <span class="hljs-string">&#x27;Peking University&#x27;</span><br>condition_2_2 = df_demo.Grade == <span class="hljs-string">&#x27;Senior&#x27;</span><br>condition_2_3 = df_demo.Weight &gt; <span class="hljs-number">80</span><br>condition_2 = condition_2_1 &amp; (~condition_2_2) &amp; condition_2_3<br>df_demo.loc[condition_1 | condition_2]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Qiang Han</th><td>Peking University</td><td>Freshman</td><td>Male</td><td>87.0</td><td>N</td></tr><tr><th>Chengpeng Zhou</th><td>Fudan University</td><td>Senior</td><td>Male</td><td>81.0</td><td>N</td></tr><tr><th>Changpeng Zhao</th><td>Peking University</td><td>Freshman</td><td>Male</td><td>83.0</td><td>N</td></tr><tr><th>Chengpeng Qian</th><td>Fudan University</td><td>Senior</td><td>Male</td><td>73.0</td><td>Y</td></tr></tbody></table></div><h4 id="练一练">【练一练】</h4><p><code>select_dtypes</code>是一个实用函数，它能够从表中选出相应类型的列，若要选出所有数值型的列，只需使用<code>.select_dtypes('number')</code>，请利用布尔列表选择的方法结合<code>DataFrame</code>的<code>dtypes</code>属性在<code>learn_pandas</code>数据集上实现这个功能。</p><h4 id="end-1">【END】</h4><p>【e】<code>*</code>为函数</p><p>这里的函数，必须以前面的四种合法形式之一为返回值，并且函数的输入值为<code>DataFrame</code>本身。假设仍然是上述复合条件筛选的例子，可以把逻辑写入一个函数中再返回，需要注意的是函数的形式参数<code>x</code>本质上即为<code>df_demo</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">condition</span>(<span class="hljs-params">x</span>):<br>    condition_1_1 = x.School == <span class="hljs-string">&#x27;Fudan University&#x27;</span><br>    condition_1_2 = x.Grade == <span class="hljs-string">&#x27;Senior&#x27;</span><br>    condition_1_3 = x.Weight &gt; <span class="hljs-number">70</span><br>    condition_1 = condition_1_1 &amp; condition_1_2 &amp; condition_1_3<br>    condition_2_1 = x.School == <span class="hljs-string">&#x27;Peking University&#x27;</span><br>    condition_2_2 = x.Grade == <span class="hljs-string">&#x27;Senior&#x27;</span><br>    condition_2_3 = x.Weight &gt; <span class="hljs-number">80</span><br>    condition_2 = condition_2_1 &amp; (~condition_2_2) &amp; condition_2_3<br>    result = condition_1 | condition_2<br>    <span class="hljs-keyword">return</span> result<br>df_demo.loc[condition]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Qiang Han</th><td>Peking University</td><td>Freshman</td><td>Male</td><td>87.0</td><td>N</td></tr><tr><th>Chengpeng Zhou</th><td>Fudan University</td><td>Senior</td><td>Male</td><td>81.0</td><td>N</td></tr><tr><th>Changpeng Zhao</th><td>Peking University</td><td>Freshman</td><td>Male</td><td>83.0</td><td>N</td></tr><tr><th>Chengpeng Qian</th><td>Fudan University</td><td>Senior</td><td>Male</td><td>73.0</td><td>Y</td></tr></tbody></table></div><p>此外，还支持使用<code>lambda</code>表达式，其返回值也同样必须是先前提到的四种形式之一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-keyword">lambda</span> x:<span class="hljs-string">&#x27;Quan Zhao&#x27;</span>, <span class="hljs-keyword">lambda</span> x:<span class="hljs-string">&#x27;Gender&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;Female&#39;</code></pre><p>由于函数无法返回如<code>start: end: step</code>的切片形式，故返回切片时要用<code>slice</code>对象进行包装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.loc[<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">slice</span>(<span class="hljs-string">&#x27;Gaojuan You&#x27;</span>, <span class="hljs-string">&#x27;Gaoqiang Qian&#x27;</span>)]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Gaojuan You</th><td>Fudan University</td><td>Sophomore</td><td>Male</td><td>74.0</td><td>N</td></tr><tr><th>Xiaoli Qian</th><td>Tsinghua University</td><td>Freshman</td><td>Female</td><td>51.0</td><td>N</td></tr><tr><th>Qiang Chu</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Female</td><td>52.0</td><td>N</td></tr><tr><th>Gaoqiang Qian</th><td>Tsinghua University</td><td>Junior</td><td>Female</td><td>50.0</td><td>N</td></tr></tbody></table></div><p>最后需要指出的是，对于<code>Series</code>也可以使用<code>loc</code>索引，其遵循的原则与<code>DataFrame</code>中用于行筛选的<code>loc[*]</code>完全一致，此处不再赘述。</p><h4 id="warning不要使用链式赋值">【WARNING】不要使用链式赋值</h4><p>在对表或者序列赋值时，应当在使用一层索引器后直接进行赋值操作，这样做是由于进行多次索引后赋值是赋在临时返回的<code>copy</code>副本上的，而没有真正修改元素从而报出<code>SettingWithCopyWarning</code>警告。例如，下面给出的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">df_chain = pd.DataFrame([[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]], columns=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;AB&#x27;</span>))<br>df_chain<br><span class="hljs-keyword">import</span> warnings<br><span class="hljs-keyword">with</span> warnings.catch_warnings():<br>    warnings.filterwarnings(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        df_chain[df_chain.A!=<span class="hljs-number">0</span>].B = <span class="hljs-number">1</span> <span class="hljs-comment"># 使用方括号列索引后，再使用点的列索引</span><br>    <span class="hljs-keyword">except</span> Warning <span class="hljs-keyword">as</span> w:<br>        Warning_Msg = w<br><span class="hljs-built_in">print</span>(Warning_Msg)<br>df_chain<br></code></pre></td></tr></table></figure><pre><code class="hljs">A value is trying to be set on a copy of a slice from a DataFrame.Try using .loc[row_indexer,col_indexer] = value insteadSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><th>0</th><td>0</td><td>0</td></tr><tr><th>1</th><td>1</td><td>0</td></tr><tr><th>2</th><td>-1</td><td>0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_chain.loc[df_chain.A!=<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;B&#x27;</span>] = <span class="hljs-number">1</span><br>df_chain<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><th>0</th><td>0</td><td>0</td></tr><tr><th>1</th><td>1</td><td>1</td></tr><tr><th>2</th><td>-1</td><td>1</td></tr></tbody></table></div><h4 id="end-2">【END】</h4><h3 id="iloc索引器">4. iloc索引器</h3><p><code>iloc</code>的使用与<code>loc</code>完全类似，只不过是针对位置进行筛选，在相应的<code>*</code>位置处一共也有五类合法对象，分别是：整数、整数列表、整数切片、布尔列表以及函数，函数的返回值必须是前面的四类合法对象中的一个，其输入同样也为<code>DataFrame</code>本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] <span class="hljs-comment"># 第二行第二列</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;Freshman&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]] <span class="hljs-comment"># 前两行前两列</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th></tr><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>Gaopeng Yang</th><td>Shanghai Jiao Tong University</td><td>Freshman</td></tr><tr><th>Changqiang You</th><td>Peking University</td><td>Freshman</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[<span class="hljs-number">1</span>: <span class="hljs-number">4</span>, <span class="hljs-number">2</span>:<span class="hljs-number">4</span>] <span class="hljs-comment"># 切片不包含结束端点</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Gender</th><th>Weight</th></tr><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>Changqiang You</th><td>Male</td><td>70.0</td></tr><tr><th>Mei Sun</th><td>Male</td><td>89.0</td></tr><tr><th>Xiaojuan Sun</th><td>Female</td><td>41.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)] <span class="hljs-comment"># 传入切片为返回值的函数</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Changqiang You</th><td>Peking University</td><td>Freshman</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>Mei Sun</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>Xiaojuan Sun</th><td>Fudan University</td><td>Sophomore</td><td>Female</td><td>41.0</td><td>N</td></tr></tbody></table></div><p>在使用布尔列表的时候要特别注意，不能传入<code>Series</code>而必须传入序列的<code>values</code>，否则会报错。因此，在使用布尔筛选的时候还是应当优先考虑<code>loc</code>的方式。</p><p>例如，选出体重超过80kg的学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.iloc[(df_demo.Weight&gt;<span class="hljs-number">80</span>).values].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>Name</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Mei Sun</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>Qiang Zheng</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Male</td><td>87.0</td><td>N</td></tr><tr><th>Qiang Han</th><td>Peking University</td><td>Freshman</td><td>Male</td><td>87.0</td><td>N</td></tr><tr><th>Chengpeng Zhou</th><td>Fudan University</td><td>Senior</td><td>Male</td><td>81.0</td><td>N</td></tr><tr><th>Feng Han</th><td>Shanghai Jiao Tong University</td><td>Sophomore</td><td>Male</td><td>82.0</td><td>N</td></tr></tbody></table></div><p>对<code>Series</code>而言同样也可以通过<code>iloc</code>返回相应位置的值或子序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.School.iloc[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;Peking University&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_demo.School.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">NameChangqiang You    Peking UniversityXiaojuan Sun       Fudan UniversityName: School, dtype: object</code></pre><h3 id="query方法">5. query方法</h3><p>在<code>pandas</code>中，支持把字符串形式的查询表达式传入<code>query</code>方法来查询数据，其表达式的执行结果必须返回布尔列表。在进行复杂索引时，由于这种检索方式无需像普通方法一样重复使用<code>DataFrame</code>的名字来引用列名，一般而言会使代码长度在不降低可读性的前提下有所减少。</p><p>例如，将<code>loc</code>一节中的复合条件查询例子可以如下改写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&#x27;((School == &quot;Fudan University&quot;)&amp;&#x27;</span><br>         <span class="hljs-string">&#x27; (Grade == &quot;Senior&quot;)&amp;&#x27;</span><br>         <span class="hljs-string">&#x27; (Weight &gt; 70))|&#x27;</span><br>         <span class="hljs-string">&#x27;((School == &quot;Peking University&quot;)&amp;&#x27;</span><br>         <span class="hljs-string">&#x27; (Grade != &quot;Senior&quot;)&amp;&#x27;</span><br>         <span class="hljs-string">&#x27; (Weight &gt; 80))&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>38</th><td>Peking University</td><td>Freshman</td><td>Qiang Han</td><td>Male</td><td>87.0</td><td>N</td></tr><tr><th>66</th><td>Fudan University</td><td>Senior</td><td>Chengpeng Zhou</td><td>Male</td><td>81.0</td><td>N</td></tr><tr><th>99</th><td>Peking University</td><td>Freshman</td><td>Changpeng Zhao</td><td>Male</td><td>83.0</td><td>N</td></tr><tr><th>131</th><td>Fudan University</td><td>Senior</td><td>Chengpeng Qian</td><td>Male</td><td>73.0</td><td>Y</td></tr></tbody></table></div><p>在<code>query</code>表达式中，帮用户注册了所有来自<code>DataFrame</code>的列名，所有属于该<code>Series</code>的方法都可以被调用，和正常的函数调用并没有区别，例如查询体重超过均值的学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&#x27;Weight &gt; Weight.mean()&#x27;</span>).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>1</th><td>Peking University</td><td>Freshman</td><td>Changqiang You</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>2</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Mei Sun</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>4</th><td>Fudan University</td><td>Sophomore</td><td>Gaojuan You</td><td>Male</td><td>74.0</td><td>N</td></tr><tr><th>10</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Xiaopeng Zhou</td><td>Male</td><td>74.0</td><td>N</td></tr><tr><th>14</th><td>Tsinghua University</td><td>Senior</td><td>Xiaomei Zhou</td><td>Female</td><td>57.0</td><td>N</td></tr></tbody></table></div><h4id="notequery中引用带空格的列名">【NOTE】query中引用带空格的列名</h4><p>对于含有空格的列名，需要使用<code>`col name`</code>的方式进行引用。</p><h4 id="end-3">【END】</h4><p>同时，在<code>query</code>中还注册了若干英语的字面用法，帮助提高可读性，例如：<code>or, and, or, in, not in</code>。例如，筛选出男生中不是大一大二的学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&#x27;(Grade not in [&quot;Freshman&quot;, &quot;Sophomore&quot;]) and (Gender == &quot;Male&quot;)&#x27;</span>).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>2</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Mei Sun</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>16</th><td>Tsinghua University</td><td>Junior</td><td>Xiaoqiang Qin</td><td>Male</td><td>68.0</td><td>N</td></tr><tr><th>17</th><td>Tsinghua University</td><td>Junior</td><td>Peng Wang</td><td>Male</td><td>65.0</td><td>N</td></tr><tr><th>18</th><td>Tsinghua University</td><td>Senior</td><td>Xiaofeng Sun</td><td>Male</td><td>71.0</td><td>N</td></tr><tr><th>21</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Xiaopeng Shen</td><td>Male</td><td>62.0</td><td>NaN</td></tr></tbody></table></div><p>此外，在字符串中出现与列表的比较时，<code>==</code>和<code>!=</code>分别表示元素出现在列表和没有出现在列表，等价于<code>in</code>和<code>not in</code>，例如查询所有大三和大四的学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.query(<span class="hljs-string">&#x27;Grade == [&quot;Junior&quot;, &quot;Senior&quot;]&#x27;</span>).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>2</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Mei Sun</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>7</th><td>Tsinghua University</td><td>Junior</td><td>Gaoqiang Qian</td><td>Female</td><td>50.0</td><td>N</td></tr><tr><th>9</th><td>Peking University</td><td>Junior</td><td>Juan Xu</td><td>Female</td><td>NaN</td><td>N</td></tr><tr><th>11</th><td>Tsinghua University</td><td>Junior</td><td>Xiaoquan Lv</td><td>Female</td><td>43.0</td><td>N</td></tr><tr><th>12</th><td>Shanghai Jiao Tong University</td><td>Senior</td><td>Peng You</td><td>Female</td><td>48.0</td><td>NaN</td></tr></tbody></table></div><p>对于<code>query</code>中的字符串，如果要引用外部变量，只需在变量名前加<code>@</code>符号。例如，取出体重位于70kg到80kg之间的学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">low, high =<span class="hljs-number">70</span>, <span class="hljs-number">80</span><br>df.query(<span class="hljs-string">&#x27;(Weight &gt;= @low) &amp; (Weight &lt;= @high)&#x27;</span>).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Grade</th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr></thead><tbody><tr><th>1</th><td>Peking University</td><td>Freshman</td><td>Changqiang You</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>4</th><td>Fudan University</td><td>Sophomore</td><td>Gaojuan You</td><td>Male</td><td>74.0</td><td>N</td></tr><tr><th>10</th><td>Shanghai Jiao Tong University</td><td>Freshman</td><td>Xiaopeng Zhou</td><td>Male</td><td>74.0</td><td>N</td></tr><tr><th>18</th><td>Tsinghua University</td><td>Senior</td><td>Xiaofeng Sun</td><td>Male</td><td>71.0</td><td>N</td></tr><tr><th>35</th><td>Peking University</td><td>Freshman</td><td>Gaoli Zhao</td><td>Male</td><td>78.0</td><td>N</td></tr></tbody></table></div><h3 id="随机抽样">6. 随机抽样</h3><p>如果把<code>DataFrame</code>的每一行看作一个样本，或把每一列看作一个特征，再把整个<code>DataFrame</code>看作总体，想要对样本或特征进行随机抽样就可以用<code>sample</code>函数。有时在拿到大型数据集后，想要对统计特征进行计算来了解数据的大致分布，但是这很费时间。同时，由于许多统计特征在等概率不放回的简单随机抽样条件下，是总体统计特征的无偏估计，比如样本均值和总体均值，那么就可以先从整张表中抽出一部分来做近似估计。</p><p><code>sample</code>函数中的主要参数为<code>n, axis, frac, replace, weights</code>，前三个分别是指抽样数量、抽样的方向（0为行、1为列）和抽样比例（0.3则为从总体中抽出30%的样本）。</p><p><code>replace</code>和<code>weights</code>分别是指是否放回和每个样本的抽样相对概率，当<code>replace = True</code>则表示有放回抽样。例如，对下面构造的<code>df_sample</code>以<code>value</code>值的相对大小为抽样概率进行有放回抽样，抽样数量为3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sample = pd.DataFrame(&#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcde&#x27;</span>), <span class="hljs-string">&#x27;value&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">90</span>]&#125;)<br>df_sample<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>id</th><th>value</th></tr></thead><tbody><tr><th>0</th><td>a</td><td>1</td></tr><tr><th>1</th><td>b</td><td>2</td></tr><tr><th>2</th><td>c</td><td>3</td></tr><tr><th>3</th><td>d</td><td>4</td></tr><tr><th>4</th><td>e</td><td>90</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sample.sample(<span class="hljs-number">3</span>, replace = <span class="hljs-literal">True</span>, weights = df_sample.value)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>id</th><th>value</th></tr></thead><tbody><tr><th>4</th><td>e</td><td>90</td></tr><tr><th>4</th><td>e</td><td>90</td></tr><tr><th>4</th><td>e</td><td>90</td></tr></tbody></table></div><h2 id="二多级索引">二、多级索引</h2><h3 id="多级索引及其表的结构">1. 多级索引及其表的结构</h3><p>为了更加清晰地说明具有多级索引的<code>DataFrame</code>结构，下面新构造一张表，读者可以忽略这里的构造方法，它们将会在第4小节被更详细地讲解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>multi_index = pd.MultiIndex.from_product([<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;ABCD&#x27;</span>), df.Gender.unique()], names=(<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>))<br>multi_column = pd.MultiIndex.from_product([[<span class="hljs-string">&#x27;Height&#x27;</span>, <span class="hljs-string">&#x27;Weight&#x27;</span>], df.Grade.unique()], names=(<span class="hljs-string">&#x27;Indicator&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>))<br>df_multi = pd.DataFrame(np.c_[(np.random.randn(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)*<span class="hljs-number">5</span> + <span class="hljs-number">163</span>).tolist(), (np.random.randn(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)*<span class="hljs-number">5</span> + <span class="hljs-number">65</span>).tolist()],<br>                        index = multi_index, columns = multi_column).<span class="hljs-built_in">round</span>(<span class="hljs-number">1</span>)<br>df_multi<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th>Indicator</th><th colspan="4" halign="left">Height</th><th colspan="4" halign="left">Weight</th></tr><tr><th></th><th>Grade</th><th>Freshman</th><th>Senior</th><th>Sophomore</th><th>Junior</th><th>Freshman</th><th>Senior</th><th>Sophomore</th><th>Junior</th></tr><tr><th>School</th><th>Gender</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">A</th><th>Female</th><td>171.8</td><td>165.0</td><td>167.9</td><td>174.2</td><td>60.6</td><td>55.1</td><td>63.3</td><td>65.8</td></tr><tr><th>Male</th><td>172.3</td><td>158.1</td><td>167.8</td><td>162.2</td><td>71.2</td><td>71.0</td><td>63.1</td><td>63.5</td></tr><tr><th rowspan="2" valign="top">B</th><th>Female</th><td>162.5</td><td>165.1</td><td>163.7</td><td>170.3</td><td>59.8</td><td>57.9</td><td>56.5</td><td>74.8</td></tr><tr><th>Male</th><td>166.8</td><td>163.6</td><td>165.2</td><td>164.7</td><td>62.5</td><td>62.8</td><td>58.7</td><td>68.9</td></tr><tr><th rowspan="2" valign="top">C</th><th>Female</th><td>170.5</td><td>162.0</td><td>164.6</td><td>158.7</td><td>56.9</td><td>63.9</td><td>60.5</td><td>66.9</td></tr><tr><th>Male</th><td>150.2</td><td>166.3</td><td>167.3</td><td>159.3</td><td>62.4</td><td>59.1</td><td>64.9</td><td>67.1</td></tr><tr><th rowspan="2" valign="top">D</th><th>Female</th><td>174.3</td><td>155.7</td><td>163.2</td><td>162.1</td><td>65.3</td><td>66.5</td><td>61.8</td><td>63.2</td></tr><tr><th>Male</th><td>170.7</td><td>170.3</td><td>163.8</td><td>164.9</td><td>61.6</td><td>63.2</td><td>60.9</td><td>56.4</td></tr></tbody></table></div><p>下图通过颜色区分，标记了<code>DataFrame</code>的结构。与单层索引的表一样，具备元素值、行索引和列索引三个部分。其中，这里的行索引和列索引都是<code>MultiIndex</code>类型，只不过<strong>索引中的一个元素是元组</strong>而不是单层索引中的标量。例如，行索引的第四个元素为<code>("B", "Male")</code>，列索引的第二个元素为<code>("Height", "Senior")</code>，这里需要注意，外层连续出现相同的值时，第一次之后出现的会被隐藏显示，使结果的可读性增强。</p><p><img src="../source/_static/multi_index.png" width="50%"></p><p>与单层索引类似，<code>MultiIndex</code>也具有名字属性，图中的<code>School</code>和<code>Gender</code>分别对应了表的第一层和第二层行索引的名字，<code>Indicator</code>和<code>Grade</code>分别对应了第一层和第二层列索引的名字。</p><p>索引的名字和值属性分别可以通过<code>names</code>和<code>values</code>获得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.index.names<br></code></pre></td></tr></table></figure><pre><code class="hljs">FrozenList([&#39;School&#39;, &#39;Gender&#39;])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.columns.names<br></code></pre></td></tr></table></figure><pre><code class="hljs">FrozenList([&#39;Indicator&#39;, &#39;Grade&#39;])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.index.values<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([(&#39;A&#39;, &#39;Female&#39;), (&#39;A&#39;, &#39;Male&#39;), (&#39;B&#39;, &#39;Female&#39;), (&#39;B&#39;, &#39;Male&#39;),       (&#39;C&#39;, &#39;Female&#39;), (&#39;C&#39;, &#39;Male&#39;), (&#39;D&#39;, &#39;Female&#39;), (&#39;D&#39;, &#39;Male&#39;)],      dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.columns.values<br></code></pre></td></tr></table></figure><pre><code class="hljs">array([(&#39;Height&#39;, &#39;Freshman&#39;), (&#39;Height&#39;, &#39;Senior&#39;),       (&#39;Height&#39;, &#39;Sophomore&#39;), (&#39;Height&#39;, &#39;Junior&#39;),       (&#39;Weight&#39;, &#39;Freshman&#39;), (&#39;Weight&#39;, &#39;Senior&#39;),       (&#39;Weight&#39;, &#39;Sophomore&#39;), (&#39;Weight&#39;, &#39;Junior&#39;)], dtype=object)</code></pre><p>如果想要得到某一层的索引，则需要通过<code>get_level_values</code>获得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi.index.get_level_values(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;, &#39;D&#39;, &#39;D&#39;], dtype=&#39;object&#39;, name=&#39;School&#39;)</code></pre><p>但对于索引而言，无论是单层还是多层，用户都无法通过<code>index_obj[0] = item</code>的方式来修改元素，也不能通过<code>index_name[0] = new_name</code>的方式来修改名字，关于如何修改这些属性的话题将在第三节被讨论。</p><h3 id="多级索引中的loc索引器">2. 多级索引中的loc索引器</h3><p>熟悉了结构后，现在回到原表，将学校和年级设为索引，此时的行为多级索引，列为单级索引，由于默认状态的列索引不含名字，因此对应于刚刚图中<code>Indicator</code>和<code>Grade</code>的索引名位置是空缺的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_multi = df.set_index([<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>])<br>df_multi.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Shanghai Jiao Tong University</th><th>Freshman</th><td>Gaopeng Yang</td><td>Female</td><td>46.0</td><td>N</td></tr><tr><th>Peking University</th><th>Freshman</th><td>Changqiang You</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>Shanghai Jiao Tong University</th><th>Senior</th><td>Mei Sun</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th rowspan="2" valign="top">Fudan University</th><th>Sophomore</th><td>Xiaojuan Sun</td><td>Female</td><td>41.0</td><td>N</td></tr><tr><th>Sophomore</th><td>Gaojuan You</td><td>Male</td><td>74.0</td><td>N</td></tr></tbody></table></div><p>由于多级索引中的单个元素以元组为单位，因此之前在第一节介绍的<code>loc</code> 和 <code>iloc</code>方法完全可以照搬，只需把标量的位置替换成对应的元组。</p><p>当传入元组列表或单个元组或返回前二者的函数时，需要先进行索引排序以避免性能警告：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> warnings.catch_warnings():<br>    warnings.filterwarnings(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        df_multi.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>)].head()<br>    <span class="hljs-keyword">except</span> Warning <span class="hljs-keyword">as</span> w:<br>        Warning_Msg = w<br>Warning_Msg<br></code></pre></td></tr></table></figure><pre><code class="hljs">pandas.errors.PerformanceWarning(&#39;indexing past lexsort depth may impact performance.&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted = df_multi.sort_index()<br>df_sorted.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>)].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="5" valign="top">Fudan University</th><th>Junior</th><td>Yanli You</td><td>Female</td><td>48.0</td><td>N</td></tr><tr><th>Junior</th><td>Chunqiang Chu</td><td>Male</td><td>72.0</td><td>N</td></tr><tr><th>Junior</th><td>Changfeng Lv</td><td>Male</td><td>76.0</td><td>N</td></tr><tr><th>Junior</th><td>Yanjuan Lv</td><td>Female</td><td>49.0</td><td>NaN</td></tr><tr><th>Junior</th><td>Gaoqiang Zhou</td><td>Female</td><td>43.0</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted.loc[[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>), (<span class="hljs-string">&#x27;Shanghai Jiao Tong University&#x27;</span>, <span class="hljs-string">&#x27;Freshman&#x27;</span>)]].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="5" valign="top">Fudan University</th><th>Senior</th><td>Chengpeng Zheng</td><td>Female</td><td>38.0</td><td>N</td></tr><tr><th>Senior</th><td>Feng Zhou</td><td>Female</td><td>47.0</td><td>N</td></tr><tr><th>Senior</th><td>Gaomei Lv</td><td>Female</td><td>34.0</td><td>N</td></tr><tr><th>Senior</th><td>Chunli Lv</td><td>Female</td><td>56.0</td><td>N</td></tr><tr><th>Senior</th><td>Chengpeng Zhou</td><td>Male</td><td>81.0</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted.loc[df_sorted.Weight &gt; <span class="hljs-number">70</span>].head() <span class="hljs-comment"># 布尔列表也是可用的</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="5" valign="top">Fudan University</th><th>Freshman</th><td>Feng Wang</td><td>Male</td><td>74.0</td><td>N</td></tr><tr><th>Junior</th><td>Chunqiang Chu</td><td>Male</td><td>72.0</td><td>N</td></tr><tr><th>Junior</th><td>Changfeng Lv</td><td>Male</td><td>76.0</td><td>N</td></tr><tr><th>Senior</th><td>Chengpeng Zhou</td><td>Male</td><td>81.0</td><td>N</td></tr><tr><th>Senior</th><td>Chengpeng Qian</td><td>Male</td><td>73.0</td><td>Y</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted.loc[<span class="hljs-keyword">lambda</span> x:(<span class="hljs-string">&#x27;Fudan University&#x27;</span>,<span class="hljs-string">&#x27;Junior&#x27;</span>)].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="5" valign="top">Fudan University</th><th>Junior</th><td>Yanli You</td><td>Female</td><td>48.0</td><td>N</td></tr><tr><th>Junior</th><td>Chunqiang Chu</td><td>Male</td><td>72.0</td><td>N</td></tr><tr><th>Junior</th><td>Changfeng Lv</td><td>Male</td><td>76.0</td><td>N</td></tr><tr><th>Junior</th><td>Yanjuan Lv</td><td>Female</td><td>49.0</td><td>NaN</td></tr><tr><th>Junior</th><td>Gaoqiang Zhou</td><td>Female</td><td>43.0</td><td>N</td></tr></tbody></table></div><p>当使用切片时需要注意，在单级索引中只要切片端点元素是唯一的，那么就可以进行切片，但在多级索引中，无论元组在索引中是否重复出现，都必须经过排序才能使用切片，否则报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    df_multi.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>):].head()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure><pre><code class="hljs">pandas.errors.UnsortedIndexError(&#39;Key length (2) was greater than MultiIndex lexsort depth (0)&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_sorted.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>):].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="5" valign="top">Fudan University</th><th>Senior</th><td>Chengpeng Zheng</td><td>Female</td><td>38.0</td><td>N</td></tr><tr><th>Senior</th><td>Feng Zhou</td><td>Female</td><td>47.0</td><td>N</td></tr><tr><th>Senior</th><td>Gaomei Lv</td><td>Female</td><td>34.0</td><td>N</td></tr><tr><th>Senior</th><td>Chunli Lv</td><td>Female</td><td>56.0</td><td>N</td></tr><tr><th>Senior</th><td>Chengpeng Zhou</td><td>Male</td><td>81.0</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_unique = df.drop_duplicates(subset=[<span class="hljs-string">&#x27;School&#x27;</span>,<span class="hljs-string">&#x27;Grade&#x27;</span>]).set_index([<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>])<br>df_unique.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>Shanghai Jiao Tong University</th><th>Freshman</th><td>Gaopeng Yang</td><td>Female</td><td>46.0</td><td>N</td></tr><tr><th>Peking University</th><th>Freshman</th><td>Changqiang You</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>Shanghai Jiao Tong University</th><th>Senior</th><td>Mei Sun</td><td>Male</td><td>89.0</td><td>N</td></tr><tr><th>Fudan University</th><th>Sophomore</th><td>Xiaojuan Sun</td><td>Female</td><td>41.0</td><td>N</td></tr><tr><th>Tsinghua University</th><th>Freshman</th><td>Xiaoli Qian</td><td>Female</td><td>51.0</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    df_unique.loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>):].head()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure><pre><code class="hljs">pandas.errors.UnsortedIndexError(&#39;Key length (2) was greater than MultiIndex lexsort depth (0)&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_unique.sort_index().loc[(<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Senior&#x27;</span>):].head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">Fudan University</th><th>Senior</th><td>Chengpeng Zheng</td><td>Female</td><td>38.0</td><td>N</td></tr><tr><th>Sophomore</th><td>Xiaojuan Sun</td><td>Female</td><td>41.0</td><td>N</td></tr><tr><th rowspan="3" valign="top">Peking University</th><th>Freshman</th><td>Changqiang You</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>Junior</th><td>Juan Xu</td><td>Female</td><td>NaN</td><td>N</td></tr><tr><th>Senior</th><td>Changli Lv</td><td>Female</td><td>41.0</td><td>N</td></tr></tbody></table></div><p>此外，在多级索引中的元组有一种特殊的用法，可以对多层的元素进行交叉组合后索引，但同时需要指定<code>loc</code>的列，全选则用<code>:</code>表示。其中，每一层需要选中的元素用列表存放，传入<code>loc</code>的形式为<code>[(level_0_list, level_1_list), cols]</code>。例如，想要得到所有北大和复旦的大二大三学生，可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = df_multi.loc[([<span class="hljs-string">&#x27;Peking University&#x27;</span>, <span class="hljs-string">&#x27;Fudan University&#x27;</span>], [<span class="hljs-string">&#x27;Sophomore&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>]), :]<br>res.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="5" valign="top">Peking University</th><th>Sophomore</th><td>Changmei Xu</td><td>Female</td><td>43.0</td><td>N</td></tr><tr><th>Sophomore</th><td>Xiaopeng Qin</td><td>Male</td><td>NaN</td><td>N</td></tr><tr><th>Sophomore</th><td>Mei Xu</td><td>Female</td><td>39.0</td><td>N</td></tr><tr><th>Sophomore</th><td>Xiaoli Zhou</td><td>Female</td><td>55.0</td><td>N</td></tr><tr><th>Sophomore</th><td>Peng Han</td><td>Female</td><td>34.0</td><td>NaN</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">res.shape<br></code></pre></td></tr></table></figure><pre><code class="hljs">(33, 4)</code></pre><p>下面的语句和上面类似，但仍然传入的是元素（这里为元组）的列表，它们的意义是不同的，表示的是选出北大的大三学生和复旦的大二学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = df_multi.loc[[(<span class="hljs-string">&#x27;Peking University&#x27;</span>, <span class="hljs-string">&#x27;Junior&#x27;</span>), (<span class="hljs-string">&#x27;Fudan University&#x27;</span>, <span class="hljs-string">&#x27;Sophomore&#x27;</span>)]]<br>res.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Gender</th><th>Weight</th><th>Transfer</th></tr><tr><th>School</th><th>Grade</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="5" valign="top">Peking University</th><th>Junior</th><td>Juan Xu</td><td>Female</td><td>NaN</td><td>N</td></tr><tr><th>Junior</th><td>Changjuan You</td><td>Female</td><td>47.0</td><td>N</td></tr><tr><th>Junior</th><td>Gaoli Xu</td><td>Female</td><td>48.0</td><td>N</td></tr><tr><th>Junior</th><td>Gaoquan Zhou</td><td>Male</td><td>70.0</td><td>N</td></tr><tr><th>Junior</th><td>Qiang You</td><td>Female</td><td>56.0</td><td>N</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">res.shape<br></code></pre></td></tr></table></figure><pre><code class="hljs">(16, 4)</code></pre><h3 id="indexslice对象">3. IndexSlice对象</h3><p>前面介绍的方法，即使在索引不重复的时候，也只能对元组整体进行切片，而不能对每层进行切片，也不允许将切片和布尔列表混合使用，引入<code>IndexSlice</code>对象就能解决这个问题。<code>Slice</code>对象一共有两种形式，第一种为<code>loc[idx[*,*]]</code>型，第二种为<code>loc[idx[*,*],idx[*,*]]</code>型，下面将进行介绍。为了方便演示，下面构造一个<strong>索引不重复的</strong><code>DataFrame</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>L1,L2 = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>],[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br>mul_index1 = pd.MultiIndex.from_product([L1,L2],names=(<span class="hljs-string">&#x27;Upper&#x27;</span>, <span class="hljs-string">&#x27;Lower&#x27;</span>))<br>L3,L4 = [<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>],[<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>]<br>mul_index2 = pd.MultiIndex.from_product([L3,L4],names=(<span class="hljs-string">&#x27;Big&#x27;</span>, <span class="hljs-string">&#x27;Small&#x27;</span>))<br>df_ex = pd.DataFrame(np.random.randint(-<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,(<span class="hljs-number">9</span>,<span class="hljs-number">9</span>)), index=mul_index1, columns=mul_index2)<br>df_ex<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th>Big</th><th colspan="3" halign="left">D</th><th colspan="3" halign="left">E</th><th colspan="3" halign="left">F</th></tr><tr><th></th><th>Small</th><th>d</th><th>e</th><th>f</th><th>d</th><th>e</th><th>f</th><th>d</th><th>e</th><th>f</th></tr><tr><th>Upper</th><th>Lower</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="3" valign="top">A</th><th>a</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td><td>-5</td></tr><tr><th>b</th><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td><td>-4</td><td>4</td></tr><tr><th>c</th><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td><td>-9</td><td>9</td><td>-6</td></tr><tr><th rowspan="3" valign="top">B</th><th>a</th><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td><td>0</td><td>-9</td><td>1</td><td>-6</td></tr><tr><th>b</th><td>2</td><td>9</td><td>-7</td><td>-9</td><td>-9</td><td>-5</td><td>-4</td><td>-3</td><td>-1</td></tr><tr><th>c</th><td>8</td><td>6</td><td>-5</td><td>0</td><td>1</td><td>-8</td><td>-8</td><td>-2</td><td>0</td></tr><tr><th rowspan="3" valign="top">C</th><th>a</th><td>-6</td><td>-3</td><td>2</td><td>5</td><td>9</td><td>-9</td><td>5</td><td>-6</td><td>3</td></tr><tr><th>b</th><td>1</td><td>2</td><td>-5</td><td>-3</td><td>-5</td><td>6</td><td>-6</td><td>3</td><td>-5</td></tr><tr><th>c</th><td>-1</td><td>5</td><td>6</td><td>-6</td><td>6</td><td>4</td><td>7</td><td>8</td><td>-4</td></tr></tbody></table></div><p>为了使用<code>silce</code>对象，先要进行定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idx = pd.IndexSlice<br></code></pre></td></tr></table></figure><p>【a】<code>loc[idx[*,*]]</code>型</p><p>这种情况并不能进行多层分别切片，前一个<code>*</code>表示行的选择，后一个<code>*</code>表示列的选择，与单纯的<code>loc</code>是类似的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.loc[idx[<span class="hljs-string">&#x27;C&#x27;</span>:, (<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>):]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th>Big</th><th>D</th><th colspan="3" halign="left">E</th><th colspan="3" halign="left">F</th></tr><tr><th></th><th>Small</th><th>f</th><th>d</th><th>e</th><th>f</th><th>d</th><th>e</th><th>f</th></tr><tr><th>Upper</th><th>Lower</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="3" valign="top">C</th><th>a</th><td>2</td><td>5</td><td>9</td><td>-9</td><td>5</td><td>-6</td><td>3</td></tr><tr><th>b</th><td>-5</td><td>-3</td><td>-5</td><td>6</td><td>-6</td><td>3</td><td>-5</td></tr><tr><th>c</th><td>6</td><td>-6</td><td>6</td><td>4</td><td>7</td><td>8</td><td>-4</td></tr></tbody></table></div><p>另外，也支持布尔序列的索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.loc[idx[:<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">lambda</span> x:x.<span class="hljs-built_in">sum</span>()&gt;<span class="hljs-number">0</span>]] <span class="hljs-comment"># 列和大于0</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th>Big</th><th colspan="2" halign="left">D</th><th>F</th></tr><tr><th></th><th>Small</th><th>d</th><th>e</th><th>e</th></tr><tr><th>Upper</th><th>Lower</th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="3" valign="top">A</th><th>a</th><td>3</td><td>6</td><td>9</td></tr><tr><th>b</th><td>-3</td><td>3</td><td>-4</td></tr><tr><th>c</th><td>-1</td><td>0</td><td>9</td></tr></tbody></table></div><p>【b】<code>loc[idx[*,*],idx[*,*]]</code>型</p><p>这种情况能够分层进行切片，前一个<code>idx</code>指代的是行索引，后一个是列索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.loc[idx[:<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>:], idx[<span class="hljs-string">&#x27;E&#x27;</span>:, <span class="hljs-string">&#x27;e&#x27;</span>:]]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th>Big</th><th colspan="2" halign="left">E</th><th colspan="2" halign="left">F</th></tr><tr><th></th><th>Small</th><th>e</th><th>f</th><th>e</th><th>f</th></tr><tr><th>Upper</th><th>Lower</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">A</th><th>b</th><td>-2</td><td>5</td><td>-4</td><td>4</td></tr><tr><th>c</th><td>6</td><td>6</td><td>9</td><td>-6</td></tr></tbody></table></div><p>但需要注意的是，此时不支持使用函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    df_ex.loc[idx[:<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">lambda</span> x: <span class="hljs-string">&#x27;b&#x27;</span>], idx[<span class="hljs-string">&#x27;E&#x27;</span>:, <span class="hljs-string">&#x27;e&#x27;</span>:]]<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure><pre><code class="hljs">KeyError(&lt;function __main__.&lt;lambda&gt;(x)&gt;)</code></pre><h3 id="多级索引的构造">4. 多级索引的构造</h3><p>前面提到了多级索引表的结构和切片，那么除了使用<code>set_index</code>之外，如何自己构造多级索引呢？常用的有<code>from_tuples, from_arrays, from_product</code>三种方法，它们都是<code>pd.MultiIndex</code>对象下的函数。</p><p><code>from_tuples</code>指根据传入由元组组成的列表进行构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = [(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;cat&#x27;</span>),(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>),(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;cat&#x27;</span>),(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>)]<br>pd.MultiIndex.from_tuples(my_tuple, names=[<span class="hljs-string">&#x27;First&#x27;</span>,<span class="hljs-string">&#x27;Second&#x27;</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">MultiIndex([(&#39;a&#39;, &#39;cat&#39;),            (&#39;a&#39;, &#39;dog&#39;),            (&#39;b&#39;, &#39;cat&#39;),            (&#39;b&#39;, &#39;dog&#39;)],           names=[&#39;First&#39;, &#39;Second&#39;])</code></pre><p><code>from_arrays</code>指根据传入列表中，对应层的列表进行构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_array = [<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;aabb&#x27;</span>), [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>]*<span class="hljs-number">2</span>]<br>pd.MultiIndex.from_arrays(my_array, names=[<span class="hljs-string">&#x27;First&#x27;</span>,<span class="hljs-string">&#x27;Second&#x27;</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">MultiIndex([(&#39;a&#39;, &#39;cat&#39;),            (&#39;a&#39;, &#39;dog&#39;),            (&#39;b&#39;, &#39;cat&#39;),            (&#39;b&#39;, &#39;dog&#39;)],           names=[&#39;First&#39;, &#39;Second&#39;])</code></pre><p><code>from_product</code>指根据给定多个列表的笛卡尔积进行构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list1 = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>]<br>my_list2 = [<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>]<br>pd.MultiIndex.from_product([my_list1, my_list2], names=[<span class="hljs-string">&#x27;First&#x27;</span>,<span class="hljs-string">&#x27;Second&#x27;</span>])<br></code></pre></td></tr></table></figure><pre><code class="hljs">MultiIndex([(&#39;a&#39;, &#39;cat&#39;),            (&#39;a&#39;, &#39;dog&#39;),            (&#39;b&#39;, &#39;cat&#39;),            (&#39;b&#39;, &#39;dog&#39;)],           names=[&#39;First&#39;, &#39;Second&#39;])</code></pre><h2 id="三索引的常用方法">三、索引的常用方法</h2><h3 id="索引层的交换和删除">1. 索引层的交换和删除</h3><p>为了方便理解交换的过程，这里构造一个三级索引的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>L1,L2,L3 = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>],[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>],[<span class="hljs-string">&#x27;alpha&#x27;</span>,<span class="hljs-string">&#x27;beta&#x27;</span>]<br>mul_index1 = pd.MultiIndex.from_product([L1,L2,L3], names=(<span class="hljs-string">&#x27;Upper&#x27;</span>, <span class="hljs-string">&#x27;Lower&#x27;</span>,<span class="hljs-string">&#x27;Extra&#x27;</span>))<br>L4,L5,L6 = [<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>],[<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>],[<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>]<br>mul_index2 = pd.MultiIndex.from_product([L4,L5,L6], names=(<span class="hljs-string">&#x27;Big&#x27;</span>, <span class="hljs-string">&#x27;Small&#x27;</span>, <span class="hljs-string">&#x27;Other&#x27;</span>))<br>df_ex = pd.DataFrame(np.random.randint(-<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>)), index=mul_index1,  columns=mul_index2)<br>df_ex<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th></th><th></th><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th>Upper</th><th>Lower</th><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>alpha</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>beta</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>alpha</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>beta</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th rowspan="4" valign="top">B</th><th rowspan="2" valign="top">a</th><th>alpha</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr><tr><th>beta</th><td>-9</td><td>-5</td><td>-4</td><td>-3</td><td>-1</td><td>8</td><td>6</td><td>-5</td></tr><tr><th rowspan="2" valign="top">b</th><th>alpha</th><td>0</td><td>1</td><td>-8</td><td>-8</td><td>-2</td><td>0</td><td>-6</td><td>-3</td></tr><tr><th>beta</th><td>2</td><td>5</td><td>9</td><td>-9</td><td>5</td><td>-6</td><td>3</td><td>1</td></tr></tbody></table></div><p>索引层的交换由<code>swaplevel</code>和<code>reorder_levels</code>完成，前者只能交换两个层，而后者可以交换任意层，两者都可以指定交换的是轴是哪一个，即行索引或列索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.swaplevel(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,axis=<span class="hljs-number">1</span>).head() <span class="hljs-comment"># 列索引的第一层和第三层交换</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th></th><th></th><th>Small</th><th>c</th><th>c</th><th>d</th><th>d</th><th>c</th><th>c</th><th>d</th><th>d</th></tr><tr><th></th><th></th><th>Big</th><th>C</th><th>C</th><th>C</th><th>C</th><th>D</th><th>D</th><th>D</th><th>D</th></tr><tr><th>Upper</th><th>Lower</th><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>alpha</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>beta</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>alpha</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>beta</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>B</th><th>a</th><th>alpha</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.reorder_levels([<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],axis=<span class="hljs-number">0</span>).head() <span class="hljs-comment"># 列表数字指代原来索引中的层</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th></th><th></th><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th>Extra</th><th>Upper</th><th>Lower</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>alpha</th><th>A</th><th>a</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>beta</th><th>A</th><th>a</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th>alpha</th><th>A</th><th>b</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>beta</th><th>A</th><th>b</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>alpha</th><th>B</th><th>a</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr></tbody></table></div><h4 id="note轴之间的索引交换">【NOTE】轴之间的索引交换</h4><p>这里只涉及行或列索引内部的交换，不同方向索引之间的交换将在第五章中被讨论。#### 【END】若想要删除某一层的索引，可以使用<code>droplevel</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.droplevel(<span class="hljs-number">1</span>,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th>Upper</th><th>Lower</th><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>alpha</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>beta</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>alpha</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>beta</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th rowspan="4" valign="top">B</th><th rowspan="2" valign="top">a</th><th>alpha</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr><tr><th>beta</th><td>-9</td><td>-5</td><td>-4</td><td>-3</td><td>-1</td><td>8</td><td>6</td><td>-5</td></tr><tr><th rowspan="2" valign="top">b</th><th>alpha</th><td>0</td><td>1</td><td>-8</td><td>-8</td><td>-2</td><td>0</td><td>-6</td><td>-3</td></tr><tr><th>beta</th><td>2</td><td>5</td><td>9</td><td>-9</td><td>5</td><td>-6</td><td>3</td><td>1</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.droplevel([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>alpha</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>beta</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th>alpha</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>beta</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>alpha</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr><tr><th>beta</th><td>-9</td><td>-5</td><td>-4</td><td>-3</td><td>-1</td><td>8</td><td>6</td><td>-5</td></tr><tr><th>alpha</th><td>0</td><td>1</td><td>-8</td><td>-8</td><td>-2</td><td>0</td><td>-6</td><td>-3</td></tr><tr><th>beta</th><td>2</td><td>5</td><td>9</td><td>-9</td><td>5</td><td>-6</td><td>3</td><td>1</td></tr></tbody></table></div><h3 id="索引属性的修改">2. 索引属性的修改</h3><p>通过<code>rename_axis</code>可以对索引层的名字进行修改，常用的修改方式是传入字典的映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.rename_axis(index=&#123;<span class="hljs-string">&#x27;Upper&#x27;</span>:<span class="hljs-string">&#x27;Changed_row&#x27;</span>&#125;, columns=&#123;<span class="hljs-string">&#x27;Other&#x27;</span>:<span class="hljs-string">&#x27;Changed_Col&#x27;</span>&#125;).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th></th><th></th><th>Changed_Col</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th>Changed_row</th><th>Lower</th><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>alpha</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>beta</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>alpha</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>beta</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>B</th><th>a</th><th>alpha</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr></tbody></table></div><p>通过<code>rename</code>可以对索引的值进行修改，如果是多级索引需要指定修改的层号<code>level</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.rename(columns=&#123;<span class="hljs-string">&#x27;cat&#x27;</span>:<span class="hljs-string">&#x27;not_cat&#x27;</span>&#125;, level=<span class="hljs-number">2</span>).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th></th><th></th><th>Other</th><th>not_cat</th><th>dog</th><th>not_cat</th><th>dog</th><th>not_cat</th><th>dog</th><th>not_cat</th><th>dog</th></tr><tr><th>Upper</th><th>Lower</th><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>alpha</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>beta</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>alpha</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>beta</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>B</th><th>a</th><th>alpha</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr></tbody></table></div><p>传入参数也可以是函数，其输入值就是索引元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.rename(index=<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">str</span>.upper(x), level=<span class="hljs-number">2</span>).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th></th><th></th><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th>Upper</th><th>Lower</th><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>ALPHA</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>BETA</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>ALPHA</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>BETA</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>B</th><th>a</th><th>ALPHA</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr></tbody></table></div><h4 id="练一练-1">【练一练】</h4><p>尝试在<code>rename_axis</code>中使用函数完成与例子中一样的功能，即把<code>Upper</code>和<code>Other</code>分别替换为<code>Changed_row</code>和<code>Changed_col</code>。#### 【END】 对于整个索引的元素替换，可以利用迭代器实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">new_values = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcdefgh&#x27;</span>))<br>df_ex.rename(index=<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">next</span>(new_values), level=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th></th><th></th><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th>Upper</th><th>Lower</th><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>a</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>b</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>c</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>d</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th rowspan="4" valign="top">B</th><th rowspan="2" valign="top">a</th><th>e</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr><tr><th>f</th><td>-9</td><td>-5</td><td>-4</td><td>-3</td><td>-1</td><td>8</td><td>6</td><td>-5</td></tr><tr><th rowspan="2" valign="top">b</th><th>g</th><td>0</td><td>1</td><td>-8</td><td>-8</td><td>-2</td><td>0</td><td>-6</td><td>-3</td></tr><tr><th>h</th><td>2</td><td>5</td><td>9</td><td>-9</td><td>5</td><td>-6</td><td>3</td><td>1</td></tr></tbody></table></div><p>若想要对某个位置的元素进行修改，在单层索引时容易实现，即先取出索引的<code>values</code>属性，再给对得到的列表进行修改，最后再对<code>index</code>对象重新赋值。但是如果是多级索引的话就有些麻烦，一个解决的方案是先把某一层索引临时转为表的元素，然后再进行修改，最后重新设定为索引，下面一节将介绍这些操作。</p><p>另外一个需要介绍的函数是<code>map</code>，它是定义在<code>Index</code>上的方法，与前面<code>rename</code>方法中层的函数式用法是类似的，只不过它传入的不是层的标量值，而是直接传入索引的元组，这为用户进行跨层的修改提供了遍历。例如，可以等价地写出上面的字符串转大写的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df_temp = df_ex.copy()<br>new_idx = df_temp.index.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>], <span class="hljs-built_in">str</span>.upper(x[<span class="hljs-number">2</span>])))<br>df_temp.index = new_idx<br>df_temp.head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th></th><th></th><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th>Upper</th><th>Lower</th><th>Extra</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>ALPHA</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>BETA</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>ALPHA</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>BETA</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>B</th><th>a</th><th>ALPHA</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr></tbody></table></div><p>关于<code>map</code>的另一个使用方法是对多级索引的压缩，这在第四章和第五章的一些操作中是有用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df_temp = df_ex.copy()<br>new_idx = df_temp.index.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>]+<span class="hljs-string">&#x27;-&#x27;</span>+x[<span class="hljs-number">1</span>]+<span class="hljs-string">&#x27;-&#x27;</span>+x[<span class="hljs-number">2</span>]))<br>df_temp.index = new_idx<br>df_temp.head() <span class="hljs-comment"># 单层索引</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr></thead><tbody><tr><th>A-a-alpha</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>A-a-beta</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th>A-b-alpha</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>A-b-beta</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>B-a-alpha</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr></tbody></table></div><p>同时，也可以反向地展开：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">new_idx = df_temp.index.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">tuple</span>(x.split(<span class="hljs-string">&#x27;-&#x27;</span>)))<br>df_temp.index = new_idx<br>df_temp.head() <span class="hljs-comment"># 三层索引</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th>Big</th><th colspan="4" halign="left">C</th><th colspan="4" halign="left">D</th></tr><tr><th></th><th></th><th>Small</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th><th colspan="2" halign="left">c</th><th colspan="2" halign="left">d</th></tr><tr><th></th><th></th><th>Other</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr></thead><tbody><tr><th rowspan="4" valign="top">A</th><th rowspan="2" valign="top">a</th><th>alpha</th><td>3</td><td>6</td><td>-9</td><td>-6</td><td>-6</td><td>-2</td><td>0</td><td>9</td></tr><tr><th>beta</th><td>-5</td><td>-3</td><td>3</td><td>-8</td><td>-3</td><td>-2</td><td>5</td><td>8</td></tr><tr><th rowspan="2" valign="top">b</th><th>alpha</th><td>-4</td><td>4</td><td>-1</td><td>0</td><td>7</td><td>-4</td><td>6</td><td>6</td></tr><tr><th>beta</th><td>-9</td><td>9</td><td>-6</td><td>8</td><td>5</td><td>-2</td><td>-9</td><td>-8</td></tr><tr><th>B</th><th>a</th><th>alpha</th><td>0</td><td>-9</td><td>1</td><td>-6</td><td>2</td><td>9</td><td>-7</td><td>-9</td></tr></tbody></table></div><h3 id="索引的设置与重置">3. 索引的设置与重置</h3><p>为了说明本节的函数，下面构造一个新表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new = pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;aacd&#x27;</span>), <span class="hljs-string">&#x27;B&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;PQRT&#x27;</span>), <span class="hljs-string">&#x27;C&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]&#125;)<br>df_new<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><th>0</th><td>a</td><td>P</td><td>1</td></tr><tr><th>1</th><td>a</td><td>Q</td><td>2</td></tr><tr><th>2</th><td>c</td><td>R</td><td>3</td></tr><tr><th>3</th><td>d</td><td>T</td><td>4</td></tr></tbody></table></div><p>索引的设置可以使用<code>set_index</code>完成，这里的主要参数是<code>append</code>，表示是否来保留原来的索引，直接把新设定的添加到原索引的内层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.set_index(<span class="hljs-string">&#x27;A&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>B</th><th>C</th></tr><tr><th>A</th><th></th><th></th></tr></thead><tbody><tr><th>a</th><td>P</td><td>1</td></tr><tr><th>a</th><td>Q</td><td>2</td></tr><tr><th>c</th><td>R</td><td>3</td></tr><tr><th>d</th><td>T</td><td>4</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.set_index(<span class="hljs-string">&#x27;A&#x27;</span>, append=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>B</th><th>C</th></tr><tr><th></th><th>A</th><th></th><th></th></tr></thead><tbody><tr><th>0</th><th>a</th><td>P</td><td>1</td></tr><tr><th>1</th><th>a</th><td>Q</td><td>2</td></tr><tr><th>2</th><th>c</th><td>R</td><td>3</td></tr><tr><th>3</th><th>d</th><td>T</td><td>4</td></tr></tbody></table></div><p>可以同时指定多个列作为索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.set_index([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>C</th></tr><tr><th>A</th><th>B</th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">a</th><th>P</th><td>1</td></tr><tr><th>Q</th><td>2</td></tr><tr><th>c</th><th>R</th><td>3</td></tr><tr><th>d</th><th>T</th><td>4</td></tr></tbody></table></div><p>如果想要添加索引的列没有出现在其中，那么可以直接在参数中传入相应的<code>Series</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_index = pd.Series(<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;WXYZ&#x27;</span>), name=<span class="hljs-string">&#x27;D&#x27;</span>)<br>df_new = df_new.set_index([<span class="hljs-string">&#x27;A&#x27;</span>, my_index])<br>df_new<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>B</th><th>C</th></tr><tr><th>A</th><th>D</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">a</th><th>W</th><td>P</td><td>1</td></tr><tr><th>X</th><td>Q</td><td>2</td></tr><tr><th>c</th><th>Y</th><td>R</td><td>3</td></tr><tr><th>d</th><th>Z</th><td>T</td><td>4</td></tr></tbody></table></div><p><code>reset_index</code>是<code>set_index</code>的逆函数，其主要参数是<code>drop</code>，表示是否要把去掉的索引层丢弃，而不是添加到列中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.reset_index([<span class="hljs-string">&#x27;D&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>D</th><th>B</th><th>C</th></tr><tr><th>A</th><th></th><th></th><th></th></tr></thead><tbody><tr><th>a</th><td>W</td><td>P</td><td>1</td></tr><tr><th>a</th><td>X</td><td>Q</td><td>2</td></tr><tr><th>c</th><td>Y</td><td>R</td><td>3</td></tr><tr><th>d</th><td>Z</td><td>T</td><td>4</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.reset_index([<span class="hljs-string">&#x27;D&#x27;</span>], drop=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>B</th><th>C</th></tr><tr><th>A</th><th></th><th></th></tr></thead><tbody><tr><th>a</th><td>P</td><td>1</td></tr><tr><th>a</th><td>Q</td><td>2</td></tr><tr><th>c</th><td>R</td><td>3</td></tr><tr><th>d</th><td>T</td><td>4</td></tr></tbody></table></div><p>如果重置了所有的索引，那么<code>pandas</code>会直接重新生成一个默认索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_new.reset_index()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>D</th><th>B</th><th>C</th></tr></thead><tbody><tr><th>0</th><td>a</td><td>W</td><td>P</td><td>1</td></tr><tr><th>1</th><td>a</td><td>X</td><td>Q</td><td>2</td></tr><tr><th>2</th><td>c</td><td>Y</td><td>R</td><td>3</td></tr><tr><th>3</th><td>d</td><td>Z</td><td>T</td><td>4</td></tr></tbody></table></div><h3 id="索引的变形">4. 索引的变形</h3><p>在某些场合下，需要对索引做一些扩充或者剔除，更具体地要求是给定一个新的索引，把原表中相应的索引对应元素填充到新索引构成的表中。例如，下面的表中给出了员工信息，需要重新制作一张新的表，要求增加一名员工的同时去掉身高列并增加性别列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_reindex = pd.DataFrame(&#123;<span class="hljs-string">&quot;Weight&quot;</span>:[<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>], <span class="hljs-string">&quot;Height&quot;</span>:[<span class="hljs-number">176</span>,<span class="hljs-number">180</span>,<span class="hljs-number">179</span>]&#125;, index=[<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;1003&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>])<br>df_reindex<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Weight</th><th>Height</th></tr></thead><tbody><tr><th>1001</th><td>60</td><td>176</td></tr><tr><th>1003</th><td>70</td><td>180</td></tr><tr><th>1002</th><td>80</td><td>179</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_reindex.reindex(index=[<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>,<span class="hljs-string">&#x27;1003&#x27;</span>,<span class="hljs-string">&#x27;1004&#x27;</span>], columns=[<span class="hljs-string">&#x27;Weight&#x27;</span>,<span class="hljs-string">&#x27;Gender&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Weight</th><th>Gender</th></tr></thead><tbody><tr><th>1001</th><td>60.0</td><td>NaN</td></tr><tr><th>1002</th><td>80.0</td><td>NaN</td></tr><tr><th>1003</th><td>70.0</td><td>NaN</td></tr><tr><th>1004</th><td>NaN</td><td>NaN</td></tr></tbody></table></div><p>这种需求常出现在时间序列索引的时间点填充以及<code>ID</code>编号的扩充。另外，需要注意的是原来表中的数据和新表中会根据索引自动对齐，例如原先的1002号位置在1003号之后，而新表中相反，那么<code>reindex</code>中会根据元素对齐，与位置无关。</p><p>还有一个与<code>reindex</code>功能类似的函数是<code>reindex_like</code>，其功能是仿照传入的表索引来进行被调用表索引的变形。例如，现在已经存在一张表具备了目标索引的条件，那么上述功能可采用下述代码得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_existed = pd.DataFrame(index=[<span class="hljs-string">&#x27;1001&#x27;</span>,<span class="hljs-string">&#x27;1002&#x27;</span>,<span class="hljs-string">&#x27;1003&#x27;</span>,<span class="hljs-string">&#x27;1004&#x27;</span>], columns=[<span class="hljs-string">&#x27;Weight&#x27;</span>,<span class="hljs-string">&#x27;Gender&#x27;</span>])<br>df_reindex.reindex_like(df_existed)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Weight</th><th>Gender</th></tr></thead><tbody><tr><th>1001</th><td>60.0</td><td>NaN</td></tr><tr><th>1002</th><td>80.0</td><td>NaN</td></tr><tr><th>1003</th><td>70.0</td><td>NaN</td></tr><tr><th>1004</th><td>NaN</td><td>NaN</td></tr></tbody></table></div><h2 id="四索引运算">四、索引运算</h2><h3 id="集合的运算法则">1. 集合的运算法则</h3><p>经常会有一种利用集合运算来取出符合条件行的需求，例如有两张表<code>A</code>和<code>B</code>，它们的索引都是员工编号，现在需要筛选出两表索引交集的所有员工信息，此时通过<code>Index</code>上的运算操作就很容易实现。</p><p>不过在此之前，不妨先复习一下常见的四种集合运算：</p><p><span class="math display">\[\rm S_A.intersection(S_B) = \rm S_A \capS_B \Leftrightarrow \rm \{x|x\in S_A\, and\, x\in S_B\}\]</span> <spanclass="math display">\[\rm S_A.union(S_B) = \rm S_A \cup S_B\Leftrightarrow \rm \{x|x\in S_A\, or\, x\in S_B\}\]</span> <spanclass="math display">\[\rm S_A.difference(S_B) = \rm S_A - S_B\Leftrightarrow \rm \{x|x\in S_A\, and\, x\notin S_B\}\]</span> <spanclass="math display">\[\rm S_A.symmetric\_difference(S_B) = \rmS_A\triangle S_B\Leftrightarrow \rm \{x|x\in S_A\cup S_B - S_A\capS_B\}\]</span></p><h3 id="一般的索引运算">2. 一般的索引运算</h3><p>由于集合的元素是互异的，但是索引中可能有相同的元素，先用<code>unique</code>去重后再进行运算。下面构造两张最为简单的示例表进行演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df_set_1 = pd.DataFrame([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]], index = pd.Index([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>],name=<span class="hljs-string">&#x27;id1&#x27;</span>))<br>df_set_2 = pd.DataFrame([[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">1</span>]], index = pd.Index([<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>],name=<span class="hljs-string">&#x27;id2&#x27;</span>))<br>id1, id2 = df_set_1.index.unique(), df_set_2.index.unique()<br>id1.intersection(id2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;b&#39;], dtype=&#39;object&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id1.union(id2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id1.difference(id2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;a&#39;], dtype=&#39;object&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">id1.symmetric_difference(id2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Index([&#39;a&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</code></pre><p>若两张表需要做集合运算的列并没有被设置索引，一种办法是先转成索引，运算后再恢复，另一种方法是利用<code>isin</code>函数，例如在重置索引的第一张表中选出id列交集的所在行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df_set_in_col_1 = df_set_1.reset_index()<br>df_set_in_col_2 = df_set_2.reset_index()<br>df_set_in_col_1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>id1</th><th>0</th><th>1</th></tr></thead><tbody><tr><th>0</th><td>a</td><td>0</td><td>1</td></tr><tr><th>1</th><td>b</td><td>1</td><td>2</td></tr><tr><th>2</th><td>a</td><td>3</td><td>4</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_set_in_col_2<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>id2</th><th>0</th><th>1</th></tr></thead><tbody><tr><th>0</th><td>b</td><td>4</td><td>5</td></tr><tr><th>1</th><td>b</td><td>2</td><td>6</td></tr><tr><th>2</th><td>c</td><td>7</td><td>1</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_set_in_col_1[df_set_in_col_1.id1.isin(df_set_in_col_2.id2)]<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>id1</th><th>0</th><th>1</th></tr></thead><tbody><tr><th>1</th><td>b</td><td>1</td><td>2</td></tr></tbody></table></div><h2 id="五练习">五、练习</h2><h3 id="ex1公司员工数据集">Ex1：公司员工数据集</h3><p>现有一份公司员工数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/company.csv&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>EmployeeID</th><th>birthdate_key</th><th>age</th><th>city_name</th><th>department</th><th>job_title</th><th>gender</th></tr></thead><tbody><tr><th>0</th><td>1318</td><td>1/3/1954</td><td>61</td><td>Vancouver</td><td>Executive</td><td>CEO</td><td>M</td></tr><tr><th>1</th><td>1319</td><td>1/3/1957</td><td>58</td><td>Vancouver</td><td>Executive</td><td>VP Stores</td><td>F</td></tr><tr><th>2</th><td>1320</td><td>1/2/1955</td><td>60</td><td>Vancouver</td><td>Executive</td><td>Legal Counsel</td><td>F</td></tr></tbody></table></div><ol type="1"><li>分别只使用<code>query</code>和<code>loc</code>选出年龄不超过四十岁且工作部门为<code>Dairy</code>或<code>Bakery</code>的男性。</li><li>选出员工<code>ID</code>号 为奇数所在行的第1、第3和倒数第2列。</li><li>按照以下步骤进行索引操作：</li></ol><ul><li>把后三列设为索引后交换内外两层</li><li>恢复中间层索引</li><li>修改外层索引名为<code>Gender</code></li><li>用下划线合并两层行索引</li><li>把行索引拆分为原状态</li><li>修改索引名为原表名称</li><li>恢复默认索引并将列保持为原表的相对位置</li></ul><h3 id="ex2巧克力数据集">Ex2：巧克力数据集</h3><p>现有一份关于巧克力评价的数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/chocolate.csv&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Company</th><th>Review</th><th>Cocoa</th><th>Company</th><th>Rating</th></tr></thead><tbody><tr><th>0</th><td>A. Morin</td><td>2016</td><td>63%</td><td>France</td><td>3.75</td></tr><tr><th>1</th><td>A. Morin</td><td>2015</td><td>70%</td><td>France</td><td>2.75</td></tr><tr><th>2</th><td>A. Morin</td><td>2015</td><td>70%</td><td>France</td><td>3.00</td></tr></tbody></table></div><ol type="1"><li>把列索引名中的<code>\n</code>替换为空格。</li><li>巧克力<code>Rating</code>评分为1至5，每0.25分一档，请选出2.75分及以下且可可含量<code>Cocoa Percent</code>高于中位数的样本。</li><li>将<code>Review Date</code>和<code>Company Location</code>设为索引后，选出<code>Review Date</code>在2012年之后且<code>Company Location</code>不属于<code>France, Canada, Amsterdam, Belgium</code>的样本。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas处理文本数据</title>
    <link href="/2023/10/01/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE/"/>
    <url>/2023/10/01/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas处理文本数据">Pandas处理文本数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="一str对象">一、str对象</h2><h3 id="str对象的设计意图">1. str对象的设计意图</h3><p><code>str</code>对象是定义在<code>Index</code>或<code>Series</code>上的属性，专门用于处理每个元素的文本内容，其内部定义了大量方法，因此对一个序列进行文本处理，首先需要获取其<code>str</code>对象。在Python标准库中也有<code>str</code>模块，为了使用上的便利，有许多函数的用法<code>pandas</code>照搬了它的设计，例如字母转为大写的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">var = <span class="hljs-string">&#x27;abcd&#x27;</span><br><span class="hljs-built_in">str</span>.upper(var) <span class="hljs-comment"># Python内置str模块</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;ABCD&#39;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-string">&#x27;efg&#x27;</span>, <span class="hljs-string">&#x27;hi&#x27;</span>])<br>s.<span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.strings.accessor.StringMethods at 0x1488ea6db08&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.upper() <span class="hljs-comment"># pandas中str对象上的upper方法</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    ABCD1     EFG2      HIdtype: object</code></pre><p>根据文档<code>API</code>材料，在<code>pandas</code>的50个<code>str</code>对象方法中，有31个是和标准库中的<code>str</code>模块方法同名且功能一致，这为批量处理序列提供了有力的工具。</p><h3 id="索引器">2. []索引器</h3><p>对于<code>str</code>对象而言，可理解为其对字符串进行了序列化的操作，例如在一般的字符串中，通过<code>[]</code>可以取出某个位置的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">var[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;a&#39;</code></pre><p>同时也能通过切片得到子串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">var[-<span class="hljs-number">1</span>: <span class="hljs-number">0</span>: -<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">&#39;db&#39;</code></pre><p>通过对<code>str</code>对象使用<code>[]</code>索引器，可以完成完全一致的功能，并且如果超出范围则返回缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    a1    e2    hdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>[-<span class="hljs-number">1</span>: <span class="hljs-number">0</span>: -<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    db1     g2     idtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      c1      g2    NaNdtype: object</code></pre><h3 id="string类型">3. string类型</h3><p>在上一章提到，从<code>pandas</code>的<code>1.0.0</code>版本开始，引入了<code>string</code>类型，其引入的动机在于：原来所有的字符串类型都会以<code>object</code>类型的<code>Series</code>进行存储，但<code>object</code>类型只应当存储混合类型，例如同时存储浮点、字符串、字典、列表、自定义类型等，因此字符串有必要同数值型或<code>category</code>一样，具有自己的数据存储类型，从而引入了<code>string</code>类型。</p><p>总体上说，绝大多数对于<code>object</code>和<code>string</code>类型的序列使用<code>str</code>对象方法产生的结果是一致，但是在下面提到的两点上有较大差异：</p><p>首先，应当尽量保证每一个序列中的值都是字符串的情况下才使用<code>str</code>属性，但这并不是必须的，其必要条件是序列中至少有一个可迭代（Iterable）对象，包括但不限于字符串、字典、列表。对于一个可迭代对象，<code>string</code>类型的<code>str</code>对象和<code>object</code>类型的<code>str</code>对象返回结果可能是不同的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;temp_1&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;temp_2&#x27;</span>&#125;, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], <span class="hljs-number">0.5</span>, <span class="hljs-string">&#x27;my_string&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    temp_11         b2       NaN3         ydtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.astype(<span class="hljs-string">&#x27;string&#x27;</span>).<span class="hljs-built_in">str</span>[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    11    &#39;2    .3    ydtype: string</code></pre><p>除了最后一个字符串元素，前三个元素返回的值都不同，其原因在于当序列类型为<code>object</code>时，是对于每一个元素进行<code>[]</code>索引，因此对于字典而言，返回temp_1字符串，对于列表则返回第二个值，而第三个为不可迭代对象，返回缺失值，第四个是对字符串进行<code>[]</code>索引。而<code>string</code>类型的<code>str</code>对象先把整个元素转为字面意义的字符串，例如对于列表而言，第一个元素即"{"，而对于最后一个字符串元素而言，恰好转化前后的表示方法一致，因此结果和<code>object</code>类型一致。</p><p>除了对于某些对象的<code>str</code>序列化方法不同之外，两者另外的一个差别在于，<code>string</code>类型是<code>Nullable</code>类型，但<code>object</code>不是。这意味着<code>string</code>类型的序列，如果调用的<code>str</code>方法返回值为整数<code>Series</code>和布尔<code>Series</code>时，其分别对应的<code>dtype</code>是<code>Int</code>和<code>boolean</code>的<code>Nullable</code>类型，而<code>object</code>类型则会分别返回<code>int/float</code>和<code>bool/object</code>，取决于缺失值的存在与否。同时，字符串的比较操作，也具有相似的特性，<code>string</code>返回<code>Nullable</code>类型，但<code>object</code>不会。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;a&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>.<span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    1dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.astype(<span class="hljs-string">&#x27;string&#x27;</span>).<span class="hljs-built_in">str</span>.<span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    1dtype: Int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s == <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    Truedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.astype(<span class="hljs-string">&#x27;string&#x27;</span>) == <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    Truedtype: boolean</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;a&#x27;</span>, np.nan]) <span class="hljs-comment"># 带有缺失值</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.<span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    1.01    NaNdtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.astype(<span class="hljs-string">&#x27;string&#x27;</span>).<span class="hljs-built_in">str</span>.<span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0       11    &lt;NA&gt;dtype: Int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s == <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1    Falsedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.astype(<span class="hljs-string">&#x27;string&#x27;</span>) == <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    True1    &lt;NA&gt;dtype: boolean</code></pre><p>最后需要注意的是，对于全体元素为数值类型的序列，即使其类型为<code>object</code>或者<code>category</code>也不允许直接使用<code>str</code>属性。如果需要把数字当成<code>string</code>类型处理，可以使用<code>astype</code>强制转换为<code>string</code>类型的<code>Series</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">12</span>, <span class="hljs-number">345</span>, <span class="hljs-number">6789</span>])<br>s.astype(<span class="hljs-string">&#x27;string&#x27;</span>).<span class="hljs-built_in">str</span>[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    21    42    7dtype: string</code></pre><h2 id="二正则表达式基础">二、正则表达式基础</h2><p>这一节的两个表格来自于<ahref="https://github.com/cdoco/learn-regex-zh">learn-regex-zh</a>这个关于正则表达式项目，其使用<code>MIT</code>开源许可协议。这里只是介绍正则表达式的基本用法，需要系统学习的读者可参考<ahref="https://book.douban.com/subject/26285406/">正则表达式必知必会</a>一书。</p><h3 id="一般字符的匹配">1. 一般字符的匹配</h3><p>正则表达式是一种按照某种正则模式，从左到右匹配字符串中内容的一种工具。对于一般的字符而言，它可以找到其所在的位置，这里为了演示便利，使用了<code>python</code>中<code>re</code>模块的<code>findall</code>函数来匹配所有出现过但不重叠的模式，第一个参数是正则表达式，第二个参数是待匹配的字符串。例如，在下面的字符串中找出<code>apple</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>re.findall(<span class="hljs-string">r&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Apple! This Is an Apple!&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;Apple&#39;, &#39;Apple&#39;]</code></pre><h3 id="元字符基础">2. 元字符基础</h3><table><thead><tr class="header"><th style="text-align: left;">元字符</th><th style="text-align: right;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">.</td><td style="text-align: right;">匹配除换行符以外的任意字符</td></tr><tr class="even"><td style="text-align: left;">[ ]</td><td style="text-align: right;">字符类，匹配方括号中包含的任意字符</td></tr><tr class="odd"><td style="text-align: left;">[^ ]</td><tdstyle="text-align: right;">否定字符类，匹配方括号中不包含的任意字符</td></tr><tr class="even"><td style="text-align: left;">*</td><td style="text-align: right;">匹配前面的子表达式零次或多次</td></tr><tr class="odd"><td style="text-align: left;">+</td><td style="text-align: right;">匹配前面的子表达式一次或多次</td></tr><tr class="even"><td style="text-align: left;">?</td><td style="text-align: right;">匹配前面的子表达式零次或一次</td></tr><tr class="odd"><td style="text-align: left;">{n,m}</td><td style="text-align: right;">花括号，匹配前面字符至少 n 次，但是不超过m 次</td></tr><tr class="even"><td style="text-align: left;">(xyz)</td><td style="text-align: right;">字符组，按照确切的顺序匹配字符xyz</td></tr><tr class="odd"><td style="text-align: left;">|</td><tdstyle="text-align: right;">分支结构，匹配符号之前的字符或后面的字符</td></tr><tr class="even"><td style="text-align: left;">\</td><td style="text-align: right;">转义符，它可以还原元字符原来的含义</td></tr><tr class="odd"><td style="text-align: left;">^</td><td style="text-align: right;">匹配行的开始</td></tr><tr class="even"><td style="text-align: left;">$</td><td style="text-align: right;">匹配行的结束</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;[ac]&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;a&#39;, &#39;c&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;[^ac]&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;b&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;[ab]&#123;2&#125;&#x27;</span>, <span class="hljs-string">&#x27;aaaabbbb&#x27;</span>) <span class="hljs-comment"># &#123;n&#125;指匹配n次</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;aa&#39;, &#39;aa&#39;, &#39;bb&#39;, &#39;bb&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;aaa|bbb&#x27;</span>, <span class="hljs-string">&#x27;aaaabbbb&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;aaa&#39;, &#39;bbb&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;a\\?|a\*&#x27;</span>, <span class="hljs-string">&#x27;aa?a*a&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;a?.&#x27;</span>, <span class="hljs-string">&#x27;abaacadaae&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;ab&#39;, &#39;aa&#39;, &#39;c&#39;, &#39;ad&#39;, &#39;aa&#39;, &#39;e&#39;]</code></pre><h3 id="简写字符集">3. 简写字符集</h3><p>此外，正则表达式中还有一类简写字符集，其等价于一组字符的集合：</p><table><thead><tr class="header"><th style="text-align: left;">简写</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">\w</td><td style="text-align: left;">匹配所有字母、数字、下划线:[a-zA-Z0-9_]</td></tr><tr class="even"><td style="text-align: left;">\W</td><td style="text-align: left;">匹配非字母和数字的字符: [^\w]</td></tr><tr class="odd"><td style="text-align: left;">\d</td><td style="text-align: left;">匹配数字: [0-9]</td></tr><tr class="even"><td style="text-align: left;">\D</td><td style="text-align: left;">匹配非数字: [^\d]</td></tr><tr class="odd"><td style="text-align: left;">\s</td><td style="text-align: left;">匹配空格符: [\t\n\f\r\p{Z}]</td></tr><tr class="even"><td style="text-align: left;">\S</td><td style="text-align: left;">匹配非空格符: [^\s]</td></tr><tr class="odd"><td style="text-align: left;">\B</td><tdstyle="text-align: left;">匹配一组非空字符开头或结尾的位置，不代表具体字符</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;.s&#x27;</span>, <span class="hljs-string">&#x27;Apple! This Is an Apple!&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;is&#39;, &#39;Is&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;\w&#123;2&#125;&#x27;</span>, <span class="hljs-string">&#x27;09 8? 7w c_ 9q p@&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;09&#39;, &#39;7w&#39;, &#39;c_&#39;, &#39;9q&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;\w\W\B&#x27;</span>, <span class="hljs-string">&#x27;09 8? 7w c_ 9q p@&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;8?&#39;, &#39;p@&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;.\s.&#x27;</span>, <span class="hljs-string">&#x27;Constant dropping wears the stone.&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;t d&#39;, &#39;g w&#39;, &#39;s t&#39;, &#39;e s&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(<span class="hljs-string">r&#x27;上海市(.&#123;2,3&#125;区)(.&#123;2,3&#125;路)(\d+号)&#x27;</span>, <span class="hljs-string">&#x27;上海市黄浦区方浜中路249号 上海市宝山区密山路5号&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[(&#39;黄浦区&#39;, &#39;方浜中路&#39;, &#39;249号&#39;), (&#39;宝山区&#39;, &#39;密山路&#39;, &#39;5号&#39;)]</code></pre><h2 id="三文本处理的五类操作">三、文本处理的五类操作</h2><h3 id="拆分">1. 拆分</h3><p><code>str.split</code>能够把字符串的列进行拆分，其中第一个参数为正则表达式，可选参数包括从左到右的最大拆分次数<code>n</code>，是否展开为多个列<code>expand</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;上海市黄浦区方浜中路249号&#x27;</span>, <span class="hljs-string">&#x27;上海市宝山区密山路5号&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27;[市区路]&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    [上海, 黄浦, 方浜中, 249号]1       [上海, 宝山, 密山, 5号]dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27;[市区路]&#x27;</span>, n=<span class="hljs-number">2</span>, expand=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><th>0</th><td>上海</td><td>黄浦</td><td>方浜中路249号</td></tr><tr><th>1</th><td>上海</td><td>宝山</td><td>密山路5号</td></tr></tbody></table></div><p>与其类似的函数是<code>str.rsplit</code>，其区别在于使用<code>n</code>参数的时候是从右到左限制最大拆分次数。但是当前版本下<code>rsplit</code>因为<code>bug</code>而无法使用正则表达式进行分割：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.rsplit(<span class="hljs-string">&#x27;[市区路]&#x27;</span>, n=<span class="hljs-number">2</span>, expand=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th></tr></thead><tbody><tr><th>0</th><td>上海市黄浦区方浜中路249号</td></tr><tr><th>1</th><td>上海市宝山区密山路5号</td></tr></tbody></table></div><h3 id="合并">2. 合并</h3><p>关于合并一共有两个函数，分别是<code>str.join</code>和<code>str.cat</code>。<code>str.join</code>表示用某个连接符把<code>Series</code>中的字符串列表连接起来，如果列表中出现了非字符串元素则返回缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>], [[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], <span class="hljs-string">&#x27;c&#x27;</span>]])<br>s.<span class="hljs-built_in">str</span>.join(<span class="hljs-string">&#x27;-&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    a-b1    NaN2    NaNdtype: object</code></pre><p><code>str.cat</code>用于合并两个序列，主要参数为连接符<code>sep</code>、连接形式<code>join</code>以及缺失值替代符号<code>na_rep</code>，其中连接形式默认为以索引为键的左连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = pd.Series([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>])<br>s2 = pd.Series([<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>])<br>s1.<span class="hljs-built_in">str</span>.cat(s2,sep=<span class="hljs-string">&#x27;-&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    a-cat1    b-dogdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s2.index = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>s1.<span class="hljs-built_in">str</span>.cat(s2, sep=<span class="hljs-string">&#x27;-&#x27;</span>, na_rep=<span class="hljs-string">&#x27;?&#x27;</span>, join=<span class="hljs-string">&#x27;outer&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      a-?1    b-cat2    ?-dogdtype: object</code></pre><h3 id="匹配">3. 匹配</h3><p><code>str.contains</code>返回了每个字符串是否包含正则模式的布尔序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;my cat&#x27;</span>, <span class="hljs-string">&#x27;he is fat&#x27;</span>, <span class="hljs-string">&#x27;railway station&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>.contains(<span class="hljs-string">&#x27;\s\wat&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1     True2    Falsedtype: bool</code></pre><p><code>str.startswith</code>和<code>str.endswith</code>返回了每个字符串以给定模式为开始和结束的布尔序列，它们都不支持正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.startswith(<span class="hljs-string">&#x27;my&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1    False2    Falsedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.endswith(<span class="hljs-string">&#x27;t&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1     True2    Falsedtype: bool</code></pre><p>如果需要用正则表达式来检测开始或结束字符串的模式，可以使用<code>str.match</code>，其返回了每个字符串起始处是否符合给定正则模式的布尔序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;m|h&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1     True2    Falsedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>[::-<span class="hljs-number">1</span>].<span class="hljs-built_in">str</span>.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;ta[f|g]|n&#x27;</span>) <span class="hljs-comment"># 反转后匹配</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1     True2     Truedtype: bool</code></pre><p>当然，这些也能通过在<code>str.contains</code>的正则中使用<code>^</code>和<code>$</code>来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.contains(<span class="hljs-string">&#x27;^[m|h]&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1     True2    Falsedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.contains(<span class="hljs-string">&#x27;[f|g]at|n$&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1     True2     Truedtype: bool</code></pre><p>除了上述返回值为布尔的匹配之外，还有一种返回索引的匹配函数，即<code>str.find</code>与<code>str.rfind</code>，其分别返回从左到右和从右到左第一次匹配的位置的索引，未找到则返回-1。需要注意的是这两个函数不支持正则匹配，只能用于字符子串的匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;This is an apple. That is not an apple.&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>.find(<span class="hljs-string">&#x27;apple&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    11dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.rfind(<span class="hljs-string">&#x27;apple&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    33dtype: int64</code></pre><h3 id="替换">4. 替换</h3><p><code>str.replace</code>和<code>replace</code>并不是一个函数，在使用字符串替换时应当使用前者。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;a_1_b&#x27;</span>,<span class="hljs-string">&#x27;c_?&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;\d|\?&#x27;</span>, <span class="hljs-string">&#x27;new&#x27;</span>, regex=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    a_new_b1      c_newdtype: object</code></pre><p>当需要对不同部分进行有差别的替换时，可以利用<code>子组</code>的方法，并且此时可以通过传入自定义的替换函数来分别进行处理，注意<code>group(k)</code>代表匹配到的第<code>k</code>个子组（圆括号之间的内容）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;上海市黄浦区方浜中路249号&#x27;</span>,<br>                <span class="hljs-string">&#x27;上海市宝山区密山路5号&#x27;</span>,<br>                <span class="hljs-string">&#x27;北京市昌平区北农路2号&#x27;</span>])<br>pat = <span class="hljs-string">&#x27;(\w+市)(\w+区)(\w+路)(\d+号)&#x27;</span><br>city = &#123;<span class="hljs-string">&#x27;上海市&#x27;</span>: <span class="hljs-string">&#x27;Shanghai&#x27;</span>, <span class="hljs-string">&#x27;北京市&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br>district = &#123;<span class="hljs-string">&#x27;昌平区&#x27;</span>: <span class="hljs-string">&#x27;CP District&#x27;</span>,<br>            <span class="hljs-string">&#x27;黄浦区&#x27;</span>: <span class="hljs-string">&#x27;HP District&#x27;</span>,<br>            <span class="hljs-string">&#x27;宝山区&#x27;</span>: <span class="hljs-string">&#x27;BS District&#x27;</span>&#125;<br>road = &#123;<span class="hljs-string">&#x27;方浜中路&#x27;</span>: <span class="hljs-string">&#x27;Mid Fangbin Road&#x27;</span>,<br>        <span class="hljs-string">&#x27;密山路&#x27;</span>: <span class="hljs-string">&#x27;Mishan Road&#x27;</span>,<br>        <span class="hljs-string">&#x27;北农路&#x27;</span>: <span class="hljs-string">&#x27;Beinong Road&#x27;</span>&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>(<span class="hljs-params">m</span>):<br>    str_city = city[m.group(<span class="hljs-number">1</span>)]<br>    str_district = district[m.group(<span class="hljs-number">2</span>)]<br>    str_road = road[m.group(<span class="hljs-number">3</span>)]<br>    str_no = <span class="hljs-string">&#x27;No. &#x27;</span> + m.group(<span class="hljs-number">4</span>)[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join([str_city,<br>                     str_district,<br>                     str_road,<br>                     str_no])<br>s.<span class="hljs-built_in">str</span>.replace(pat, my_func, regex=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    Shanghai HP District Mid Fangbin Road No. 2491           Shanghai BS District Mishan Road No. 52           Beijing CP District Beinong Road No. 2dtype: object</code></pre><p>这里的数字标识并不直观，可以使用<code>命名子组</code>更加清晰地写出子组代表的含义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">pat = <span class="hljs-string">&#x27;(?P&lt;市名&gt;\w+市)(?P&lt;区名&gt;\w+区)(?P&lt;路名&gt;\w+路)(?P&lt;编号&gt;\d+号)&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>(<span class="hljs-params">m</span>):<br>    str_city = city[m.group(<span class="hljs-string">&#x27;市名&#x27;</span>)]<br>    str_district = district[m.group(<span class="hljs-string">&#x27;区名&#x27;</span>)]<br>    str_road = road[m.group(<span class="hljs-string">&#x27;路名&#x27;</span>)]<br>    str_no = <span class="hljs-string">&#x27;No. &#x27;</span> + m.group(<span class="hljs-string">&#x27;编号&#x27;</span>)[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join([str_city,<br>                     str_district,<br>                     str_road,<br>                     str_no])<br>s.<span class="hljs-built_in">str</span>.replace(pat, my_func, regex=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    Shanghai HP District Mid Fangbin Road No. 2491           Shanghai BS District Mishan Road No. 52           Beijing CP District Beinong Road No. 2dtype: object</code></pre><p>这里虽然看起来有些繁杂，但是实际数据处理中对应的替换，一般都会通过代码来获取数据从而构造字典映射，在具体写法上会简洁的多。</p><h3 id="提取">5. 提取</h3><p>提取既可以认为是一种返回具体元素（而不是布尔值或元素对应的索引位置）的匹配操作，也可以认为是一种特殊的拆分操作。前面提到的<code>str.split</code>例子中会把分隔符去除，这并不是用户想要的效果，这时候就可以用<code>str.extract</code>进行提取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pat = <span class="hljs-string">&#x27;(\w+市)(\w+区)(\w+路)(\d+号)&#x27;</span><br>s.<span class="hljs-built_in">str</span>.extract(pat)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><th>0</th><td>上海市</td><td>黄浦区</td><td>方浜中路</td><td>249号</td></tr><tr><th>1</th><td>上海市</td><td>宝山区</td><td>密山路</td><td>5号</td></tr><tr><th>2</th><td>北京市</td><td>昌平区</td><td>北农路</td><td>2号</td></tr></tbody></table></div><p>通过子组的命名，可以直接对新生成<code>DataFrame</code>的列命名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pat = <span class="hljs-string">&#x27;(?P&lt;市名&gt;\w+市)(?P&lt;区名&gt;\w+区)(?P&lt;路名&gt;\w+路)(?P&lt;编号&gt;\d+号)&#x27;</span><br>s.<span class="hljs-built_in">str</span>.extract(pat)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>市名</th><th>区名</th><th>路名</th><th>编号</th></tr></thead><tbody><tr><th>0</th><td>上海市</td><td>黄浦区</td><td>方浜中路</td><td>249号</td></tr><tr><th>1</th><td>上海市</td><td>宝山区</td><td>密山路</td><td>5号</td></tr><tr><th>2</th><td>北京市</td><td>昌平区</td><td>北农路</td><td>2号</td></tr></tbody></table></div><p><code>str.extractall</code>不同于<code>str.extract</code>只匹配一次，它会把所有符合条件的模式全部匹配出来，如果存在多个结果，则以多级索引的方式存储：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;A135T15,A26S5&#x27;</span>,<span class="hljs-string">&#x27;B674S2,B25T6&#x27;</span>], index = [<span class="hljs-string">&#x27;my_A&#x27;</span>,<span class="hljs-string">&#x27;my_B&#x27;</span>])<br>pat = <span class="hljs-string">&#x27;[A|B](\d+)[T|S](\d+)&#x27;</span><br>s.<span class="hljs-built_in">str</span>.extractall(pat)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>0</th><th>1</th></tr><tr><th></th><th>match</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">my_A</th><th>0</th><td>135</td><td>15</td></tr><tr><th>1</th><td>26</td><td>5</td></tr><tr><th rowspan="2" valign="top">my_B</th><th>0</th><td>674</td><td>2</td></tr><tr><th>1</th><td>25</td><td>6</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pat_with_name = <span class="hljs-string">&#x27;[A|B](?P&lt;name1&gt;\d+)[T|S](?P&lt;name2&gt;\d+)&#x27;</span><br>s.<span class="hljs-built_in">str</span>.extractall(pat_with_name)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>name1</th><th>name2</th></tr><tr><th></th><th>match</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">my_A</th><th>0</th><td>135</td><td>15</td></tr><tr><th>1</th><td>26</td><td>5</td></tr><tr><th rowspan="2" valign="top">my_B</th><th>0</th><td>674</td><td>2</td></tr><tr><th>1</th><td>25</td><td>6</td></tr></tbody></table></div><p><code>str.findall</code>的功能类似于<code>str.extractall</code>，区别在于前者把结果存入列表中，而后者处理为多级索引，每个行只对应一组匹配，而不是把所有匹配组合构成列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.findall(pat)<br></code></pre></td></tr></table></figure><pre><code class="hljs">my_A    [(135, 15), (26, 5)]my_B     [(674, 2), (25, 6)]dtype: object</code></pre><h2 id="四常用字符串函数">四、常用字符串函数</h2><p>除了上述介绍的五类字符串操作有关的函数之外，<code>str</code>对象上还定义了一些实用的其他方法，在此进行介绍：</p><h3 id="字母型函数">1. 字母型函数</h3><p><code>upper, lower, title, capitalize, swapcase</code>这五个函数主要用于字母的大小写转化，从下面的例子中就容易领会其功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;lower&#x27;</span>, <span class="hljs-string">&#x27;CAPITALS&#x27;</span>, <span class="hljs-string">&#x27;this is a sentence&#x27;</span>, <span class="hljs-string">&#x27;SwApCaSe&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>.upper()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0                 LOWER1              CAPITALS2    THIS IS A SENTENCE3              SWAPCASEdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.lower()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0                 lower1              capitals2    this is a sentence3              swapcasedtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.title()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0                 Lower1              Capitals2    This Is A Sentence3              Swapcasedtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.capitalize()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0                 Lower1              Capitals2    This is a sentence3              Swapcasedtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.swapcase()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0                 LOWER1              capitals2    THIS IS A SENTENCE3              sWaPcAsEdtype: object</code></pre><h3 id="数值型函数">2. 数值型函数</h3><p>这里着重需要介绍的是<code>pd.to_numeric</code>方法，它虽然不是<code>str</code>对象上的方法，但是能够对字符格式的数值进行快速转换和筛选。其主要参数包括<code>errors</code>和<code>downcast</code>分别代表了非数值的处理模式和转换类型。其中，对于不能转换为数值的有三种<code>errors</code>选项，<code>raise, coerce, ignore</code>分别表示直接报错、设为缺失以及保持原来的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2.2&#x27;</span>, <span class="hljs-string">&#x27;2e&#x27;</span>, <span class="hljs-string">&#x27;??&#x27;</span>, <span class="hljs-string">&#x27;-2.1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>])<br>pd.to_numeric(s, errors=<span class="hljs-string">&#x27;ignore&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0       11     2.22      2e3      ??4    -2.15       0dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.to_numeric(s, errors=<span class="hljs-string">&#x27;coerce&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    1.01    2.22    NaN3    NaN4   -2.15    0.0dtype: float64</code></pre><p>在数据清洗时，可以利用<code>coerce</code>的设定，快速查看非数值型的行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[pd.to_numeric(s, errors=<span class="hljs-string">&#x27;coerce&#x27;</span>).isna()]<br></code></pre></td></tr></table></figure><pre><code class="hljs">2    2e3    ??dtype: object</code></pre><h3 id="统计型函数">3. 统计型函数</h3><p><code>count</code>和<code>len</code>的作用分别是返回出现正则模式的次数和字符串的长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;cat rat fat at&#x27;</span>, <span class="hljs-string">&#x27;get feed sheet heat&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>.count(<span class="hljs-string">&#x27;[r|f]at|ee&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    21    2dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.<span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    141    19dtype: int64</code></pre><h3 id="格式型函数">4. 格式型函数</h3><p>格式型函数主要分为两类，第一种是除空型，第二种是填充型。其中，第一类函数一共有三种，它们分别是<code>strip, rstrip, lstrip</code>，分别代表去除两侧空格、右侧空格和左侧空格。这些函数在数据清洗时是有用的，特别是列名含有非法空格的时候。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_index = pd.Index([<span class="hljs-string">&#x27; col1&#x27;</span>, <span class="hljs-string">&#x27;col2 &#x27;</span>, <span class="hljs-string">&#x27; col3 &#x27;</span>])<br>my_index.<span class="hljs-built_in">str</span>.strip().<span class="hljs-built_in">str</span>.<span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Int64Index([4, 4, 4], dtype=&#39;int64&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_index.<span class="hljs-built_in">str</span>.rstrip().<span class="hljs-built_in">str</span>.<span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Int64Index([5, 4, 5], dtype=&#39;int64&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_index.<span class="hljs-built_in">str</span>.lstrip().<span class="hljs-built_in">str</span>.<span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Int64Index([4, 5, 5], dtype=&#39;int64&#39;)</code></pre><p>对于填充型函数而言，<code>pad</code>是最灵活的，它可以选定字符串长度、填充的方向和填充内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>])<br>s.<span class="hljs-built_in">str</span>.pad(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;left&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    ****a1    ****b2    ****cdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.pad(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;right&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    a****1    b****2    c****dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.pad(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;both&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    **a**1    **b**2    **c**dtype: object</code></pre><p>上述的三种情况可以分别用<code>rjust, ljust, center</code>来等效完成，需要注意<code>ljust</code>是指右侧填充而不是左侧填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.rjust(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    ****a1    ****b2    ****cdtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.ljust(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    a****1    b****2    c****dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.center(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    **a**1    **b**2    **c**dtype: object</code></pre><p>在读取<code>excel</code>文件时，经常会出现数字前补0的需求，例如证券代码读入的时候会把"000007"作为数值7来处理，<code>pandas</code>中除了可以使用上面的左侧填充函数进行操作之外，还可用<code>zfill</code>来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">7</span>, <span class="hljs-number">155</span>, <span class="hljs-number">303000</span>]).astype(<span class="hljs-string">&#x27;string&#x27;</span>)<br>s.<span class="hljs-built_in">str</span>.pad(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;left&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    0000071    0001552    303000dtype: string</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.rjust(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;0&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    0000071    0001552    303000dtype: string</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.<span class="hljs-built_in">str</span>.zfill(<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    0000071    0001552    303000dtype: string</code></pre><h2 id="五练习">五、练习</h2><h3 id="ex1房屋信息数据集">Ex1：房屋信息数据集</h3><p>现有一份房屋信息数据集如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_excel(<span class="hljs-string">&#x27;../data/house_info.xls&#x27;</span>, usecols=[<span class="hljs-string">&#x27;floor&#x27;</span>,<span class="hljs-string">&#x27;year&#x27;</span>,<span class="hljs-string">&#x27;area&#x27;</span>,<span class="hljs-string">&#x27;price&#x27;</span>])<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>floor</th><th>year</th><th>area</th><th>price</th></tr></thead><tbody><tr><th>0</th><td>高层（共6层）</td><td>1986年建</td><td>58.23㎡</td><td>155万</td></tr><tr><th>1</th><td>中层（共20层）</td><td>2020年建</td><td>88㎡</td><td>155万</td></tr><tr><th>2</th><td>低层（共28层）</td><td>2010年建</td><td>89.33㎡</td><td>365万</td></tr></tbody></table></div><ol type="1"><li>将<code>year</code>列改为整数年份存储。</li><li>将<code>floor</code>列替换为<code>Level, Highest</code>两列，其中的元素分别为<code>string</code>类型的层类别（高层、中层、低层）与整数类型的最高层数。</li><li>计算房屋每平米的均价<code>avg_price</code>，以<code>***元/平米</code>的格式存储到表中，其中<code>***</code>为整数。### Ex2：《权力的游戏》剧本数据集现有一份权力的游戏剧本数据集如下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/script.csv&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Release Date</th><th>Season</th><th>Episode</th><th>Episode Title</th><th>Name</th><th>Sentence</th></tr></thead><tbody><tr><th>0</th><td>2011-04-17</td><td>Season 1</td><td>Episode 1</td><td>Winter is Coming</td><td>waymar royce</td><td>What do you expect? They're savages. One lot s...</td></tr><tr><th>1</th><td>2011-04-17</td><td>Season 1</td><td>Episode 1</td><td>Winter is Coming</td><td>will</td><td>I've never seen wildlings do a thing like this...</td></tr><tr><th>2</th><td>2011-04-17</td><td>Season 1</td><td>Episode 1</td><td>Winter is Coming</td><td>waymar royce</td><td>How close did you get?</td></tr></tbody></table></div><ol type="1"><li>计算每一个<code>Episode</code>的台词条数。</li><li>以空格为单词的分割符号，请求出单句台词平均单词量最多的前五个人。</li><li>若某人的台词中含有问号，那么下一个说台词的人即为回答者。若上一人台词中含有<spanclass="math inline">\(n\)</span>个问号，则认为回答者回答了<spanclass="math inline">\(n\)</span>个问题，请求出回答最多问题的前五个人。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas变形</title>
    <link href="/2023/10/01/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%8F%98%E5%BD%A2/"/>
    <url>/2023/10/01/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%8F%98%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas变形">Pandas变形</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="一长宽表的变形">一、长宽表的变形</h2><p>什么是长表？什么是宽表？这个概念是对于某一个特征而言的。例如：一个表中把性别存储在某一个列中，那么它就是关于性别的长表；如果把性别作为列名，列中的元素是某一其他的相关特征数值，那么这个表是关于性别的宽表。下面的两张表就分别是关于性别的长表和宽表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.DataFrame(&#123;<span class="hljs-string">&#x27;Gender&#x27;</span>:[<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>], <span class="hljs-string">&#x27;Height&#x27;</span>:[<span class="hljs-number">163</span>, <span class="hljs-number">160</span>, <span class="hljs-number">175</span>, <span class="hljs-number">180</span>]&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Gender</th><th>Height</th></tr></thead><tbody><tr><th>0</th><td>F</td><td>163</td></tr><tr><th>1</th><td>F</td><td>160</td></tr><tr><th>2</th><td>M</td><td>175</td></tr><tr><th>3</th><td>M</td><td>180</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.DataFrame(&#123;<span class="hljs-string">&#x27;Height: F&#x27;</span>:[<span class="hljs-number">163</span>, <span class="hljs-number">160</span>], <span class="hljs-string">&#x27;Height: M&#x27;</span>:[<span class="hljs-number">175</span>, <span class="hljs-number">180</span>]&#125;)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Height: F</th><th>Height: M</th></tr></thead><tbody><tr><th>0</th><td>163</td><td>175</td></tr><tr><th>1</th><td>160</td><td>180</td></tr></tbody></table></div><p>显然这两张表从信息上是完全等价的，它们包含相同的身高统计数值，只是这些数值的呈现方式不同，而其呈现方式主要又与性别一列选择的布局模式有关，即到底是以<spanclass="math inline">\(\color{red}{long}\)</span>的状态存储还是以<spanclass="math inline">\(\color{red}{wide}\)</span>的状态存储。因此，<code>pandas</code>针对此类长宽表的变形操作设计了一些有关的变形函数。</p><h3 id="pivot">1. pivot</h3><p><code>pivot</code>是一种典型的长表变宽表的函数，首先来看一个例子：下表存储了张三和李四的语文和数学分数，现在想要把语文和数学分数作为列来展示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],<br>                   <span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>,<span class="hljs-string">&#x27;San Zhang&#x27;</span>,<span class="hljs-string">&#x27;Si Li&#x27;</span>,<span class="hljs-string">&#x27;Si Li&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Subject&#x27;</span>:[<span class="hljs-string">&#x27;Chinese&#x27;</span>,<span class="hljs-string">&#x27;Math&#x27;</span>,<span class="hljs-string">&#x27;Chinese&#x27;</span>,<span class="hljs-string">&#x27;Math&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">80</span>,<span class="hljs-number">75</span>,<span class="hljs-number">90</span>,<span class="hljs-number">85</span>]&#125;)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Class</th><th>Name</th><th>Subject</th><th>Grade</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>San Zhang</td><td>Chinese</td><td>80</td></tr><tr><th>1</th><td>1</td><td>San Zhang</td><td>Math</td><td>75</td></tr><tr><th>2</th><td>2</td><td>Si Li</td><td>Chinese</td><td>90</td></tr><tr><th>3</th><td>2</td><td>Si Li</td><td>Math</td><td>85</td></tr></tbody></table></div><p>对于一个基本的长变宽操作而言，最重要的有三个要素，分别是变形后的行索引、需要转到列索引的列，以及这些列和行索引对应的数值，它们分别对应了<code>pivot</code>方法中的<code>index, columns, values</code>参数。新生成表的列索引是<code>columns</code>对应列的<code>unique</code>值，而新表的行索引是<code>index</code>对应列的<code>unique</code>值，而<code>values</code>对应了想要展示的数值列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.pivot(index=<span class="hljs-string">&#x27;Name&#x27;</span>, columns=<span class="hljs-string">&#x27;Subject&#x27;</span>, values=<span class="hljs-string">&#x27;Grade&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>Subject</th><th>Chinese</th><th>Math</th></tr><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>San Zhang</th><td>80</td><td>75</td></tr><tr><th>Si Li</th><td>90</td><td>85</td></tr></tbody></table></div><p>通过颜色的标记，更容易地能够理解其变形的过程：</p><p><img src="../source/_static/ch5_pivot.png" width="20%"></p><p>利用<code>pivot</code>进行变形操作需要满足唯一性的要求，即由于在新表中的行列索引对应了唯一的<code>value</code>，因此原表中的<code>index</code>和<code>columns</code>对应两个列的行组合必须唯一。例如，现在把原表中第二行张三的数学改为语文就会报错，这是由于<code>Name</code>与<code>Subject</code>的组合中两次出现<code>("San Zhang", "Chinese")</code>，从而最后不能够确定到底变形后应该是填写80分还是75分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Subject&#x27;</span>] = <span class="hljs-string">&#x27;Chinese&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    df.pivot(index=<span class="hljs-string">&#x27;Name&#x27;</span>, columns=<span class="hljs-string">&#x27;Subject&#x27;</span>, values=<span class="hljs-string">&#x27;Grade&#x27;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure><pre><code class="hljs">ValueError(&#39;Index contains duplicate entries, cannot reshape&#39;)</code></pre><p><code>pandas</code>从<code>1.1.0</code>开始，<code>pivot</code>相关的三个参数允许被设置为列表，这也意味着会返回多级索引。这里构造一个相应的例子来说明如何使用：下表中六列分别为班级、姓名、测试类型（期中考试和期末考试）、科目、成绩、排名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>],<br>                   <span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>,<br>                              <span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Examination&#x27;</span>: [<span class="hljs-string">&#x27;Mid&#x27;</span>, <span class="hljs-string">&#x27;Final&#x27;</span>, <span class="hljs-string">&#x27;Mid&#x27;</span>, <span class="hljs-string">&#x27;Final&#x27;</span>,<br>                                    <span class="hljs-string">&#x27;Mid&#x27;</span>, <span class="hljs-string">&#x27;Final&#x27;</span>, <span class="hljs-string">&#x27;Mid&#x27;</span>, <span class="hljs-string">&#x27;Final&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Subject&#x27;</span>:[<span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>,<br>                                 <span class="hljs-string">&#x27;Math&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">75</span>, <span class="hljs-number">85</span>, <span class="hljs-number">65</span>, <span class="hljs-number">90</span>, <span class="hljs-number">85</span>, <span class="hljs-number">92</span>, <span class="hljs-number">88</span>],<br>                   <span class="hljs-string">&#x27;rank&#x27;</span>:[<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>]&#125;)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Class</th><th>Name</th><th>Examination</th><th>Subject</th><th>Grade</th><th>rank</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>San Zhang</td><td>Mid</td><td>Chinese</td><td>80</td><td>10</td></tr><tr><th>1</th><td>1</td><td>San Zhang</td><td>Final</td><td>Chinese</td><td>75</td><td>15</td></tr><tr><th>2</th><td>2</td><td>Si Li</td><td>Mid</td><td>Chinese</td><td>85</td><td>21</td></tr><tr><th>3</th><td>2</td><td>Si Li</td><td>Final</td><td>Chinese</td><td>65</td><td>15</td></tr><tr><th>4</th><td>1</td><td>San Zhang</td><td>Mid</td><td>Math</td><td>90</td><td>20</td></tr><tr><th>5</th><td>1</td><td>San Zhang</td><td>Final</td><td>Math</td><td>85</td><td>7</td></tr><tr><th>6</th><td>2</td><td>Si Li</td><td>Mid</td><td>Math</td><td>92</td><td>6</td></tr><tr><th>7</th><td>2</td><td>Si Li</td><td>Final</td><td>Math</td><td>88</td><td>2</td></tr></tbody></table></div><p>现在想要把测试类型和科目联合组成的四个类别（期中语文、期末语文、期中数学、期末数学）转到列索引，并且同时统计成绩和排名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">pivot_multi = df.pivot(index = [<span class="hljs-string">&#x27;Class&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>],<br>                       columns = [<span class="hljs-string">&#x27;Subject&#x27;</span>,<span class="hljs-string">&#x27;Examination&#x27;</span>],<br>                       values = [<span class="hljs-string">&#x27;Grade&#x27;</span>,<span class="hljs-string">&#x27;rank&#x27;</span>])<br>pivot_multi<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }    .dataframe thead tr:last-of-type th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th colspan="4" halign="left">Grade</th><th colspan="4" halign="left">rank</th></tr><tr><th></th><th>Subject</th><th colspan="2" halign="left">Chinese</th><th colspan="2" halign="left">Math</th><th colspan="2" halign="left">Chinese</th><th colspan="2" halign="left">Math</th></tr><tr><th></th><th>Examination</th><th>Mid</th><th>Final</th><th>Mid</th><th>Final</th><th>Mid</th><th>Final</th><th>Mid</th><th>Final</th></tr><tr><th>Class</th><th>Name</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><th>1</th><th>San Zhang</th><td>80</td><td>75</td><td>90</td><td>85</td><td>10</td><td>15</td><td>20</td><td>7</td></tr><tr><th>2</th><th>Si Li</th><td>85</td><td>65</td><td>92</td><td>88</td><td>21</td><td>15</td><td>6</td><td>2</td></tr></tbody></table></div><p>根据唯一性原则，新表的行索引等价于对<code>index</code>中的多列使用<code>drop_duplicates</code>，而列索引的长度为<code>values</code>中的元素个数乘以<code>columns</code>的唯一组合数量（与<code>index</code>类似）。从下面的示意图中能够比较容易地理解相应的操作：</p><p><img src="../source/_static/ch5_mulpivot.png" width="35%"></p><h3 id="pivot_table">2. pivot_table</h3><p><code>pivot</code>的使用依赖于唯一性条件，那如果不满足唯一性条件，那么必须通过聚合操作使得相同行列组合对应的多个值变为一个值。例如，张三和李四都参加了两次语文考试和数学考试，按照学院规定，最后的成绩是两次考试分数的平均值，此时就无法通过<code>pivot</code>函数来完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;San Zhang&#x27;</span>, <br>                              <span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;San Zhang&#x27;</span>,<br>                              <span class="hljs-string">&#x27;Si Li&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Subject&#x27;</span>:[<span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>,<br>                                 <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">85</span>, <span class="hljs-number">95</span>]&#125;)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Subject</th><th>Grade</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>Chinese</td><td>80</td></tr><tr><th>1</th><td>San Zhang</td><td>Chinese</td><td>90</td></tr><tr><th>2</th><td>San Zhang</td><td>Math</td><td>100</td></tr><tr><th>3</th><td>San Zhang</td><td>Math</td><td>90</td></tr><tr><th>4</th><td>Si Li</td><td>Chinese</td><td>70</td></tr><tr><th>5</th><td>Si Li</td><td>Chinese</td><td>80</td></tr><tr><th>6</th><td>Si Li</td><td>Math</td><td>85</td></tr><tr><th>7</th><td>Si Li</td><td>Math</td><td>95</td></tr></tbody></table></div><p><code>pandas</code>中提供了<code>pivot_table</code>来实现，其中的<code>aggfunc</code>参数就是使用的聚合函数。上述场景可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df.pivot_table(index = <span class="hljs-string">&#x27;Name&#x27;</span>,<br>               columns = <span class="hljs-string">&#x27;Subject&#x27;</span>,<br>               values = <span class="hljs-string">&#x27;Grade&#x27;</span>,<br>               aggfunc = <span class="hljs-string">&#x27;mean&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>Subject</th><th>Chinese</th><th>Math</th></tr><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>San Zhang</th><td>85</td><td>95</td></tr><tr><th>Si Li</th><td>75</td><td>90</td></tr></tbody></table></div><p>这里传入<code>aggfunc</code>包含了上一章中介绍的所有合法聚合字符串，此外还可以传入以序列为输入标量为输出的聚合函数来实现自定义操作，上述功能可以等价写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df.pivot_table(index = <span class="hljs-string">&#x27;Name&#x27;</span>,<br>               columns = <span class="hljs-string">&#x27;Subject&#x27;</span>,<br>               values = <span class="hljs-string">&#x27;Grade&#x27;</span>,<br>               aggfunc = <span class="hljs-keyword">lambda</span> x:x.mean())<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>Subject</th><th>Chinese</th><th>Math</th></tr><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>San Zhang</th><td>85</td><td>95</td></tr><tr><th>Si Li</th><td>75</td><td>90</td></tr></tbody></table></div><p>此外，<code>pivot_table</code>具有边际汇总的功能，可以通过设置<code>margins=True</code>来实现，其中边际的聚合方式与<code>aggfunc</code>中给出的聚合方法一致。下面就分别统计了语文均分和数学均分、张三均分和李四均分，以及总体所有分数的均分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df.pivot_table(index = <span class="hljs-string">&#x27;Name&#x27;</span>,<br>               columns = <span class="hljs-string">&#x27;Subject&#x27;</span>,<br>               values = <span class="hljs-string">&#x27;Grade&#x27;</span>,<br>               aggfunc=<span class="hljs-string">&#x27;mean&#x27;</span>,<br>               margins=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>Subject</th><th>Chinese</th><th>Math</th><th>All</th></tr><tr><th>Name</th><th></th><th></th><th></th></tr></thead><tbody><tr><th>San Zhang</th><td>85</td><td>95.0</td><td>90.00</td></tr><tr><th>Si Li</th><td>75</td><td>90.0</td><td>82.50</td></tr><tr><th>All</th><td>80</td><td>92.5</td><td>86.25</td></tr></tbody></table></div><h4 id="练一练">【练一练】</h4><p>在上面的边际汇总例子中，行或列的汇总为新表中行元素或者列元素的平均值，而总体的汇总为新表中四个元素的平均值。这种关系一定成立吗？若不成立，请给出一个例子来说明。#### 【END】 ### 3. melt</p><p>长宽表只是数据呈现方式的差异，但其包含的信息量是等价的，前面提到了利用<code>pivot</code>把长表转为宽表，那么就可以通过相应的逆操作把宽表转为长表，<code>melt</code>函数就起到了这样的作用。在下面的例子中，<code>Subject</code>以列索引的形式存储，现在想要将其压缩到一个列中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],<br>                   <span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Chinese&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">90</span>],<br>                   <span class="hljs-string">&#x27;Math&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">75</span>]&#125;)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Class</th><th>Name</th><th>Chinese</th><th>Math</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>San Zhang</td><td>80</td><td>80</td></tr><tr><th>1</th><td>2</td><td>Si Li</td><td>90</td><td>75</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df_melted = df.melt(id_vars = [<span class="hljs-string">&#x27;Class&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>],<br>                    value_vars = [<span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>],<br>                    var_name = <span class="hljs-string">&#x27;Subject&#x27;</span>,<br>                    value_name = <span class="hljs-string">&#x27;Grade&#x27;</span>)<br>df_melted<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Class</th><th>Name</th><th>Subject</th><th>Grade</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>San Zhang</td><td>Chinese</td><td>80</td></tr><tr><th>1</th><td>2</td><td>Si Li</td><td>Chinese</td><td>90</td></tr><tr><th>2</th><td>1</td><td>San Zhang</td><td>Math</td><td>80</td></tr><tr><th>3</th><td>2</td><td>Si Li</td><td>Math</td><td>75</td></tr></tbody></table></div><p><code>melt</code>的主要参数和压缩的过程如下图所示：</p><p><img src="../source/_static/ch5_melt.png" width="35%"></p><p>前面提到了<code>melt</code>和<code>pivot</code>是一组互逆过程，那么就一定可以通过<code>pivot</code>操作把<code>df_melted</code>转回<code>df</code>的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df_unmelted = df_melted.pivot(index = [<span class="hljs-string">&#x27;Class&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>],<br>                              columns=<span class="hljs-string">&#x27;Subject&#x27;</span>,<br>                              values=<span class="hljs-string">&#x27;Grade&#x27;</span>)<br>df_unmelted <span class="hljs-comment"># 下面需要恢复索引，并且重命名列索引名称</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Subject</th><th>Chinese</th><th>Math</th></tr><tr><th>Class</th><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>1</th><th>San Zhang</th><td>80</td><td>80</td></tr><tr><th>2</th><th>Si Li</th><td>90</td><td>75</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df_unmelted = df_unmelted.reset_index().rename_axis(columns=&#123;<span class="hljs-string">&#x27;Subject&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;)<br>df_unmelted.equals(df)<br></code></pre></td></tr></table></figure><pre><code class="hljs">True</code></pre><h3 id="wide_to_long">4. wide_to_long</h3><p><code>melt</code>方法中，在列索引中被压缩的一组值对应的列元素只能代表同一层次的含义，即<code>values_name</code>。现在如果列中包含了交叉类别，比如期中期末的类别和语文数学的类别，那么想要把<code>values_name</code>对应的<code>Grade</code>扩充为两列分别对应语文分数和数学分数，只把期中期末的信息压缩，这种需求下就要使用<code>wide_to_long</code>函数来完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Chinese_Mid&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">75</span>], <span class="hljs-string">&#x27;Math_Mid&#x27;</span>:[<span class="hljs-number">90</span>, <span class="hljs-number">85</span>],<br>                   <span class="hljs-string">&#x27;Chinese_Final&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">75</span>], <span class="hljs-string">&#x27;Math_Final&#x27;</span>:[<span class="hljs-number">90</span>, <span class="hljs-number">85</span>]&#125;)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Class</th><th>Name</th><th>Chinese_Mid</th><th>Math_Mid</th><th>Chinese_Final</th><th>Math_Final</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>San Zhang</td><td>80</td><td>90</td><td>80</td><td>90</td></tr><tr><th>1</th><td>2</td><td>Si Li</td><td>75</td><td>85</td><td>75</td><td>85</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.wide_to_long(df,<br>                stubnames=[<span class="hljs-string">&#x27;Chinese&#x27;</span>, <span class="hljs-string">&#x27;Math&#x27;</span>],<br>                i = [<span class="hljs-string">&#x27;Class&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>],<br>                j=<span class="hljs-string">&#x27;Examination&#x27;</span>,<br>                sep=<span class="hljs-string">&#x27;_&#x27;</span>,<br>                suffix=<span class="hljs-string">&#x27;.+&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th></th><th>Chinese</th><th>Math</th></tr><tr><th>Class</th><th>Name</th><th>Examination</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">1</th><th rowspan="2" valign="top">San Zhang</th><th>Mid</th><td>80</td><td>90</td></tr><tr><th>Final</th><td>80</td><td>90</td></tr><tr><th rowspan="2" valign="top">2</th><th rowspan="2" valign="top">Si Li</th><th>Mid</th><td>75</td><td>85</td></tr><tr><th>Final</th><td>75</td><td>85</td></tr></tbody></table></div><p>具体的变换过程由下图进行展示，属相同概念的元素使用了一致的颜色标出：</p><p><img src="../source/_static/ch5_wtl.png" width="35%"></p><p>下面给出一个比较复杂的案例，把之前在<code>pivot</code>一节中多列操作的结果（产生了多级索引），利用<code>wide_to_long</code>函数，将其转为原来的形态。其中，使用了第八章的<code>str.split</code>函数，目前暂时只需将其理解为对序列按照某个分隔符进行拆分即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">res = pivot_multi.copy()<br>res.columns = res.columns.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-string">&#x27;_&#x27;</span>.join(x))<br>res = res.reset_index()<br>res = pd.wide_to_long(res, stubnames=[<span class="hljs-string">&#x27;Grade&#x27;</span>, <span class="hljs-string">&#x27;rank&#x27;</span>],<br>                           i = [<span class="hljs-string">&#x27;Class&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>],<br>                           j = <span class="hljs-string">&#x27;Subject_Examination&#x27;</span>,<br>                           sep = <span class="hljs-string">&#x27;_&#x27;</span>,<br>                           suffix = <span class="hljs-string">&#x27;.+&#x27;</span>)<br>res<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th></th><th>Grade</th><th>rank</th></tr><tr><th>Class</th><th>Name</th><th>Subject_Examination</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="4" valign="top">1</th><th rowspan="4" valign="top">San Zhang</th><th>Chinese_Mid</th><td>80</td><td>10</td></tr><tr><th>Chinese_Final</th><td>75</td><td>15</td></tr><tr><th>Math_Mid</th><td>90</td><td>20</td></tr><tr><th>Math_Final</th><td>85</td><td>7</td></tr><tr><th rowspan="4" valign="top">2</th><th rowspan="4" valign="top">Si Li</th><th>Chinese_Mid</th><td>85</td><td>21</td></tr><tr><th>Chinese_Final</th><td>65</td><td>15</td></tr><tr><th>Math_Mid</th><td>92</td><td>6</td></tr><tr><th>Math_Final</th><td>88</td><td>2</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = res.reset_index()<br>res[[<span class="hljs-string">&#x27;Subject&#x27;</span>, <span class="hljs-string">&#x27;Examination&#x27;</span>]] = res[<span class="hljs-string">&#x27;Subject_Examination&#x27;</span>].<span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27;_&#x27;</span>, expand=<span class="hljs-literal">True</span>)<br>res = res[[<span class="hljs-string">&#x27;Class&#x27;</span>, <span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Examination&#x27;</span>, <span class="hljs-string">&#x27;Subject&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>, <span class="hljs-string">&#x27;rank&#x27;</span>]].sort_values(<span class="hljs-string">&#x27;Subject&#x27;</span>)<br>res = res.reset_index(drop=<span class="hljs-literal">True</span>)<br>res<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Class</th><th>Name</th><th>Examination</th><th>Subject</th><th>Grade</th><th>rank</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>San Zhang</td><td>Mid</td><td>Chinese</td><td>80</td><td>10</td></tr><tr><th>1</th><td>1</td><td>San Zhang</td><td>Final</td><td>Chinese</td><td>75</td><td>15</td></tr><tr><th>2</th><td>2</td><td>Si Li</td><td>Mid</td><td>Chinese</td><td>85</td><td>21</td></tr><tr><th>3</th><td>2</td><td>Si Li</td><td>Final</td><td>Chinese</td><td>65</td><td>15</td></tr><tr><th>4</th><td>1</td><td>San Zhang</td><td>Mid</td><td>Math</td><td>90</td><td>20</td></tr><tr><th>5</th><td>1</td><td>San Zhang</td><td>Final</td><td>Math</td><td>85</td><td>7</td></tr><tr><th>6</th><td>2</td><td>Si Li</td><td>Mid</td><td>Math</td><td>92</td><td>6</td></tr><tr><th>7</th><td>2</td><td>Si Li</td><td>Final</td><td>Math</td><td>88</td><td>2</td></tr></tbody></table></div><h2 id="二索引的变形">二、索引的变形</h2><h3 id="stack与unstack">1. stack与unstack</h3><p>在第二章中提到了利用<code>swaplevel</code>或者<code>reorder_levels</code>进行索引内部的层交换，下面就要讨论<spanclass="math inline">\(\color{red}{行列索引之间}\)</span>的交换，由于这种交换带来了<code>DataFrame</code>维度上的变化，因此属于变形操作。在第一节中提到的4种变形函数与其不同之处在于，它们都属于某一列或几列<spanclass="math inline">\(\color{red}{元素}\)</span>和<spanclass="math inline">\(\color{red}{列索引}\)</span>之间的转换，而不是索引之间的转换。</p><p><code>unstack</code>函数的作用是把行索引转为列索引，例如下面这个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(np.ones((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)),<br>                  index = pd.Index([(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;big&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;big&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>)]),<br>                  columns=[<span class="hljs-string">&#x27;col_1&#x27;</span>, <span class="hljs-string">&#x27;col_2&#x27;</span>])<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th></th><th>col_1</th><th>col_2</th></tr></thead><tbody><tr><th rowspan="2" valign="top">A</th><th>cat</th><th>big</th><td>1.0</td><td>1.0</td></tr><tr><th>dog</th><th>small</th><td>1.0</td><td>1.0</td></tr><tr><th rowspan="2" valign="top">B</th><th>cat</th><th>big</th><td>1.0</td><td>1.0</td></tr><tr><th>dog</th><th>small</th><td>1.0</td><td>1.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.unstack()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th colspan="2" halign="left">col_1</th><th colspan="2" halign="left">col_2</th></tr><tr><th></th><th></th><th>big</th><th>small</th><th>big</th><th>small</th></tr></thead><tbody><tr><th rowspan="2" valign="top">A</th><th>cat</th><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td></tr><tr><th>dog</th><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td></tr><tr><th rowspan="2" valign="top">B</th><th>cat</th><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td></tr><tr><th>dog</th><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td></tr></tbody></table></div><p><code>unstack</code>的主要参数是移动的层号，默认转化最内层，移动到列索引的最内层，同时支持同时转化多个层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.unstack(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th colspan="2" halign="left">col_1</th><th colspan="2" halign="left">col_2</th></tr><tr><th></th><th></th><th>big</th><th>small</th><th>big</th><th>small</th></tr></thead><tbody><tr><th rowspan="2" valign="top">A</th><th>cat</th><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td></tr><tr><th>dog</th><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td></tr><tr><th rowspan="2" valign="top">B</th><th>cat</th><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td></tr><tr><th>dog</th><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.unstack([<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th colspan="4" halign="left">col_1</th><th colspan="4" halign="left">col_2</th></tr><tr><th></th><th colspan="2" halign="left">A</th><th colspan="2" halign="left">B</th><th colspan="2" halign="left">A</th><th colspan="2" halign="left">B</th></tr><tr><th></th><th>big</th><th>small</th><th>big</th><th>small</th><th>big</th><th>small</th><th>big</th><th>small</th></tr></thead><tbody><tr><th>cat</th><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td></tr><tr><th>dog</th><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td></tr></tbody></table></div><p>类似于<code>pivot</code>中的唯一性要求，在<code>unstack</code>中必须保证<spanclass="math inline">\(\color{red}{被转为列索引的行索引层}\)</span>和<spanclass="math inline">\(\color{red}{被保留的行索引层}\)</span>构成的组合是唯一的，例如把前两个列索引改成相同的破坏唯一性，那么就会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_index = df.index.to_list()<br>my_index[<span class="hljs-number">1</span>] = my_index[<span class="hljs-number">0</span>]<br>df.index = pd.Index(my_index)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th></th><th>col_1</th><th>col_2</th></tr></thead><tbody><tr><th rowspan="2" valign="top">A</th><th rowspan="2" valign="top">cat</th><th>big</th><td>1.0</td><td>1.0</td></tr><tr><th>big</th><td>1.0</td><td>1.0</td></tr><tr><th rowspan="2" valign="top">B</th><th>cat</th><th>big</th><td>1.0</td><td>1.0</td></tr><tr><th>dog</th><th>small</th><td>1.0</td><td>1.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    df.unstack()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg = e<br>Err_Msg<br></code></pre></td></tr></table></figure><pre><code class="hljs">ValueError(&#39;Index contains duplicate entries, cannot reshape&#39;)</code></pre><p>与<code>unstack</code>相反，<code>stack</code>的作用就是把列索引的层压入行索引，其用法完全类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(np.ones((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)),<br>                  index = pd.Index([(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;big&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;big&#x27;</span>),<br>                                    (<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>)]),<br>                  columns=[<span class="hljs-string">&#x27;index_1&#x27;</span>, <span class="hljs-string">&#x27;index_2&#x27;</span>]).T<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th colspan="2" halign="left">A</th><th colspan="2" halign="left">B</th></tr><tr><th></th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr><tr><th></th><th>big</th><th>small</th><th>big</th><th>small</th></tr></thead><tbody><tr><th>index_1</th><td>1.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><th>index_2</th><td>1.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.stack()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th></th><th colspan="2" halign="left">A</th><th colspan="2" halign="left">B</th></tr><tr><th></th><th></th><th>cat</th><th>dog</th><th>cat</th><th>dog</th></tr></thead><tbody><tr><th rowspan="2" valign="top">index_1</th><th>big</th><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td></tr><tr><th>small</th><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td></tr><tr><th rowspan="2" valign="top">index_2</th><th>big</th><td>1.0</td><td>NaN</td><td>1.0</td><td>NaN</td></tr><tr><th>small</th><td>NaN</td><td>1.0</td><td>NaN</td><td>1.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.stack([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><th rowspan="2" valign="top">index_1</th><th>cat</th><th>big</th><td>1.0</td><td>1.0</td></tr><tr><th>dog</th><th>small</th><td>1.0</td><td>1.0</td></tr><tr><th rowspan="2" valign="top">index_2</th><th>cat</th><th>big</th><td>1.0</td><td>1.0</td></tr><tr><th>dog</th><th>small</th><td>1.0</td><td>1.0</td></tr></tbody></table></div><h3 id="聚合与变形的关系">2. 聚合与变形的关系</h3><p>在上面介绍的所有函数中，除了带有聚合效果的<code>pivot_table</code>以外，所有的函数在变形前后并不会带来<code>values</code>个数的改变，只是这些值在呈现的形式上发生了变化。在上一章讨论的分组聚合操作，由于生成了新的行列索引，因此必然也属于某种特殊的变形操作，但由于聚合之后把原来的多个值变为了一个值，因此<code>values</code>的个数产生了变化，这也是分组聚合与变形函数的最大区别。</p><h2 id="三其他变形函数">三、其他变形函数</h2><h3 id="crosstab">1. crosstab</h3><p><code>crosstab</code>是一个地位尴尬的函数，因为它能实现的所有功能<code>pivot_table</code>都能完成。在默认状态下，<code>crosstab</code>可以统计元素组合出现的频数，即<code>count</code>操作。例如统计<code>learn_pandas</code>数据集中学校和转系情况对应的频数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>)<br>pd.crosstab(index = df.School, columns = df.Transfer)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>Transfer</th><th>N</th><th>Y</th></tr><tr><th>School</th><th></th><th></th></tr></thead><tbody><tr><th>Fudan University</th><td>38</td><td>1</td></tr><tr><th>Peking University</th><td>28</td><td>2</td></tr><tr><th>Shanghai Jiao Tong University</th><td>53</td><td>0</td></tr><tr><th>Tsinghua University</th><td>62</td><td>4</td></tr></tbody></table></div><p>这等价于如下<code>crosstab</code>的如下写法，这里的<code>aggfunc</code>即聚合参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(index = df.School, columns = df.Transfer, values = [<span class="hljs-number">0</span>]*df.shape[<span class="hljs-number">0</span>], aggfunc = <span class="hljs-string">&#x27;count&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>Transfer</th><th>N</th><th>Y</th></tr><tr><th>School</th><th></th><th></th></tr></thead><tbody><tr><th>Fudan University</th><td>38.0</td><td>1.0</td></tr><tr><th>Peking University</th><td>28.0</td><td>2.0</td></tr><tr><th>Shanghai Jiao Tong University</th><td>53.0</td><td>NaN</td></tr><tr><th>Tsinghua University</th><td>62.0</td><td>4.0</td></tr></tbody></table></div><p>同样，可以利用<code>pivot_table</code>进行等价操作，由于这里统计的是组合的频数，因此<code>values</code>参数无论传入哪一个列都不会影响最后的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">df.pivot_table(index = <span class="hljs-string">&#x27;School&#x27;</span>,<br>               columns = <span class="hljs-string">&#x27;Transfer&#x27;</span>,<br>               values = <span class="hljs-string">&#x27;Name&#x27;</span>,<br>               aggfunc = <span class="hljs-string">&#x27;count&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>Transfer</th><th>N</th><th>Y</th></tr><tr><th>School</th><th></th><th></th></tr></thead><tbody><tr><th>Fudan University</th><td>38.0</td><td>1.0</td></tr><tr><th>Peking University</th><td>28.0</td><td>2.0</td></tr><tr><th>Shanghai Jiao Tong University</th><td>53.0</td><td>NaN</td></tr><tr><th>Tsinghua University</th><td>62.0</td><td>4.0</td></tr></tbody></table></div><p>从上面可以看出这两个函数的区别在于，<code>crosstab</code>的对应位置传入的是具体的序列，而<code>pivot_table</code>传入的是被调用表对应的名字，若传入序列对应的值则会报错。</p><p>除了默认状态下的<code>count</code>统计，所有的聚合字符串和返回标量的自定义函数都是可用的，例如统计对应组合的身高均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(index = df.School, columns = df.Transfer, values = df.Height, aggfunc = <span class="hljs-string">&#x27;mean&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th>Transfer</th><th>N</th><th>Y</th></tr><tr><th>School</th><th></th><th></th></tr></thead><tbody><tr><th>Fudan University</th><td>162.043750</td><td>177.20</td></tr><tr><th>Peking University</th><td>163.429630</td><td>162.40</td></tr><tr><th>Shanghai Jiao Tong University</th><td>163.953846</td><td>NaN</td></tr><tr><th>Tsinghua University</th><td>163.253571</td><td>164.55</td></tr></tbody></table></div><h3 id="explode">2. explode</h3><p><code>explode</code>参数能够对某一列的元素进行纵向的展开，被展开的单元格必须存储<code>list, tuple, Series, np.ndarray</code>中的一种类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex = pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>: [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&#x27;my_str&#x27;</span>, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, pd.Series([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])],<br>                      <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br>df_ex<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><th>0</th><td>[1, 2]</td><td>1</td></tr><tr><th>1</th><td>my_str</td><td>1</td></tr><tr><th>2</th><td>{1, 2}</td><td>1</td></tr><tr><th>3</th><td>0 3 1 4 dtype: int64</td><td>1</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df_ex.explode(<span class="hljs-string">&#x27;A&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>1</td></tr><tr><th>0</th><td>2</td><td>1</td></tr><tr><th>1</th><td>my_str</td><td>1</td></tr><tr><th>2</th><td>1</td><td>1</td></tr><tr><th>2</th><td>2</td><td>1</td></tr><tr><th>3</th><td>3</td><td>1</td></tr><tr><th>3</th><td>4</td><td>1</td></tr></tbody></table></div><h3 id="get_dummies">3. get_dummies</h3><p><code>get_dummies</code>是用于特征构建的重要函数之一，其作用是把类别特征转为指示变量。例如，对年级一列转为指示变量，属于某一个年级的对应列标记为1，否则为0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.get_dummies(df.Grade).head()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Freshman</th><th>Junior</th><th>Senior</th><th>Sophomore</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><th>1</th><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><th>2</th><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><th>3</th><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><th>4</th><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div><h2 id="四练习">四、练习</h2><h3 id="ex1美国非法药物数据集">Ex1：美国非法药物数据集</h3><p>现有一份关于美国非法药物的数据集，其中<code>SubstanceName, DrugReports</code>分别指药物名称和报告数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/drugs.csv&#x27;</span>).sort_values([<span class="hljs-string">&#x27;State&#x27;</span>,<span class="hljs-string">&#x27;COUNTY&#x27;</span>,<span class="hljs-string">&#x27;SubstanceName&#x27;</span>],ignore_index=<span class="hljs-literal">True</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>YYYY</th><th>State</th><th>COUNTY</th><th>SubstanceName</th><th>DrugReports</th></tr></thead><tbody><tr><th>0</th><td>2011</td><td>KY</td><td>ADAIR</td><td>Buprenorphine</td><td>3</td></tr><tr><th>1</th><td>2012</td><td>KY</td><td>ADAIR</td><td>Buprenorphine</td><td>5</td></tr><tr><th>2</th><td>2013</td><td>KY</td><td>ADAIR</td><td>Buprenorphine</td><td>4</td></tr></tbody></table></div><ol type="1"><li>将数据转为如下的形式：</li></ol><p><img src="../source/_static/Ex5_1.png" width="35%"></p><ol start="2" type="1"><li>将第1问中的结果恢复为原表。</li><li>按<code>State</code>分别统计每年的报告数量总和，其中<code>State, YYYY</code>分别为列索引和行索引，要求分别使用<code>pivot_table</code>函数与<code>groupby+unstack</code>两种不同的策略实现，并体会它们之间的联系。</li></ol><h3 id="ex2特殊的wide_to_long方法">Ex2：特殊的wide_to_long方法</h3><p>从功能上看，<code>melt</code>方法应当属于<code>wide_to_long</code>的一种特殊情况，即<code>stubnames</code>只有一类。请使用<code>wide_to_long</code>生成<code>melt</code>一节中的<code>df_melted</code>。（提示：对列名增加适当的前缀）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],<br>                   <span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>],<br>                   <span class="hljs-string">&#x27;Chinese&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">90</span>],<br>                   <span class="hljs-string">&#x27;Math&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">75</span>]&#125;)<br>df<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Class</th><th>Name</th><th>Chinese</th><th>Math</th></tr></thead><tbody><tr><th>0</th><td>1</td><td>San Zhang</td><td>80</td><td>80</td></tr><tr><th>1</th><td>2</td><td>Si Li</td><td>90</td><td>75</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas连接</title>
    <link href="/2023/10/01/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/10/01/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas连接">Pandas连接</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="一关系型连接">一、关系型连接</h2><h3 id="连接的基本概念">1. 连接的基本概念</h3><p>把两张相关的表按照某一个或某一组键连接起来是一种常见操作，例如学生期末考试各个科目的成绩表按照<spanclass="math inline">\(\color{red}{姓名}\)</span>和<spanclass="math inline">\(\color{red}{班级}\)</span>连接成总的成绩表，又例如对企业员工的各类信息表按照<spanclass="math inline">\(\color{red}{员工ID号}\)</span>进行连接汇总。由此可以看出，在关系型连接中，<spanclass="math inline">\(\color{red}{键}\)</span>是十分重要的，往往用<code>on</code>参数表示。</p><p>另一个重要的要素是连接的形式。在<code>pandas</code>中的关系型连接函数<code>merge</code>和<code>join</code>中提供了<code>how</code>参数来代表连接形式，分为左连接<code>left</code>、右连接<code>right</code>、内连接<code>inner</code>、外连接<code>outer</code>，它们的区别可以用如下示意图表示：</p><p><img src="../source/_static/ch6_1.png" width="50%"></p><p>从图中可以看到，所谓左连接即以左表的键为准，如果右表中的键于左表存在，那么就添加到左表，否则则处理为缺失值，右连接类似处理。内连接只负责合并两边同时出现的键，而外连接则会在内连接的基础上包含只在左边出现以及只在右边出现的值，因此外连接又叫全连接。</p><p>上面这个简单的例子中，同一个表中的键没有出现重复的情况，那么如果出现重复的键应该如何处理？只需把握一个原则，即只要两边同时出现的值，就以笛卡尔积的方式加入，如果单边出现则根据连接形式进行处理。其中，关于笛卡尔积可用如下例子说明：设左表中键<code>张三</code>出现两次，右表中的<code>张三</code>也出现两次，那么逐个进行匹配，最后产生的表必然包含<code>2*2</code>个姓名为<code>张三</code>的行。下面是一个对应例子的示意图：</p><p><img src="../source/_static/ch6_2.png" width="60%"></p><p>显然在不同的场合应该使用不同的连接形式。其中左连接和右连接是等价的，由于它们的结果中的键是被一侧的表确定的，因此常常用于有方向性地添加到目标表。内外连接两侧的表，经常是地位类似的（左右表位置的交换不引起结果的变化），想取出键的交集或者并集，具体的操作还需要根据业务的需求来判断。</p><h3 id="值连接">2. 值连接</h3><p>在上面示意图中的例子中，两张表根据某一列的值来连接，事实上还可以通过几列值的组合进行连接，这种基于值的连接在<code>pandas</code>中可以由<code>merge</code>函数实现，例如第一张图的左连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>,<span class="hljs-string">&#x27;Si Li&#x27;</span>], <span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;Si Li&#x27;</span>,<span class="hljs-string">&#x27;Wu Wang&#x27;</span>], <span class="hljs-string">&#x27;Gender&#x27;</span>:[<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>]&#125;)<br>df1.merge(df2, on=<span class="hljs-string">&#x27;Name&#x27;</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Gender</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td><td>NaN</td></tr><tr><th>1</th><td>Si Li</td><td>30</td><td>F</td></tr></tbody></table></div><p>如果两个表中想要连接的列不具备相同的列名，可以通过<code>left_on</code>和<code>right_on</code>指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;df1_name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>,<span class="hljs-string">&#x27;Si Li&#x27;</span>], <span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;df2_name&#x27;</span>:[<span class="hljs-string">&#x27;Si Li&#x27;</span>,<span class="hljs-string">&#x27;Wu Wang&#x27;</span>], <span class="hljs-string">&#x27;Gender&#x27;</span>:[<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>]&#125;)<br>df1.merge(df2, left_on=<span class="hljs-string">&#x27;df1_name&#x27;</span>, right_on=<span class="hljs-string">&#x27;df2_name&#x27;</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>df1_name</th><th>Age</th><th>df2_name</th><th>Gender</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>Si Li</td><td>30</td><td>Si Li</td><td>F</td></tr></tbody></table></div><p>如果两个表中的列出现了重复的列名，那么可以通过<code>suffixes</code>参数指定。例如合并考试成绩的时候，第一个表记录了语文成绩，第二个是数学成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>],<span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">70</span>]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>],<span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">80</span>]&#125;)<br>df1.merge(df2, on=<span class="hljs-string">&#x27;Name&#x27;</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>, suffixes=[<span class="hljs-string">&#x27;_Chinese&#x27;</span>,<span class="hljs-string">&#x27;_Math&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Grade_Chinese</th><th>Grade_Math</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>70</td><td>80</td></tr></tbody></table></div><p>在某些时候出现重复元素是麻烦的，例如两位同学来自不同的班级，但是姓名相同，这种时候就要指定<code>on</code>参数为多个列使得正确连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;San Zhang&#x27;</span>],<br>                    <span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>, <span class="hljs-number">21</span>],<br>                    <span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;San Zhang&#x27;</span>],<br>                    <span class="hljs-string">&#x27;Gender&#x27;</span>:[<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>],<br>                    <span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>]&#125;)<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Class</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td><td>one</td></tr><tr><th>1</th><td>San Zhang</td><td>21</td><td>two</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df2<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Gender</th><th>Class</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>F</td><td>two</td></tr><tr><th>1</th><td>San Zhang</td><td>M</td><td>one</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.merge(df2, on=<span class="hljs-string">&#x27;Name&#x27;</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>) <span class="hljs-comment"># 错误的结果</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Class_x</th><th>Gender</th><th>Class_y</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td><td>one</td><td>F</td><td>two</td></tr><tr><th>1</th><td>San Zhang</td><td>20</td><td>one</td><td>M</td><td>one</td></tr><tr><th>2</th><td>San Zhang</td><td>21</td><td>two</td><td>F</td><td>two</td></tr><tr><th>3</th><td>San Zhang</td><td>21</td><td>two</td><td>M</td><td>one</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.merge(df2, on=[<span class="hljs-string">&#x27;Name&#x27;</span>, <span class="hljs-string">&#x27;Class&#x27;</span>], how=<span class="hljs-string">&#x27;left&#x27;</span>) <span class="hljs-comment"># 正确的结果</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Class</th><th>Gender</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td><td>one</td><td>M</td></tr><tr><th>1</th><td>San Zhang</td><td>21</td><td>two</td><td>F</td></tr></tbody></table></div><p>从上面的例子来看，在进行基于唯一性的连接下，如果键不是唯一的，那么结果就会产生问题。举例中的行数很少，但如果实际数据中有几十万到上百万行的进行合并时，如果想要保证唯一性，除了用<code>duplicated</code>检查是否重复外，<code>merge</code>中也提供了<code>validate</code>参数来检查连接的唯一性模式。这里共有三种模式，即一对一连接<code>1:1</code>，一对多连接<code>1:m</code>，多对一连接<code>m:1</code>连接，第一个是指左右表的键都是唯一的，后面两个分别指左表键唯一和右表键唯一。</p><h4 id="练一练">【练一练】</h4><p>上面以多列为键的例子中，错误写法显然是一种多对多连接，而正确写法是一对一连接，请修改原表，使得以多列为键的正确写法能够通过<code>validate='1:m'</code>的检验，但不能通过<code>validate='m:1'</code>的检验。#### 【END】</p><h3 id="索引连接">3. 索引连接</h3><p>所谓索引连接，就是把索引当作键，因此这和值连接本质上没有区别，<code>pandas</code>中利用<code>join</code>函数来处理索引连接，它的参数选择要少于<code>merge</code>，除了必须的<code>on</code>和<code>how</code>之外，可以对重复的列指定左右后缀<code>lsuffix</code>和<code>rsuffix</code>。其中，<code>on</code>参数指索引名，单层索引时省略参数表示按照当前索引连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]&#125;, index=pd.Series([<span class="hljs-string">&#x27;San Zhang&#x27;</span>,<span class="hljs-string">&#x27;Si Li&#x27;</span>],name=<span class="hljs-string">&#x27;Name&#x27;</span>))<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Gender&#x27;</span>:[<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>]&#125;, index=pd.Series([<span class="hljs-string">&#x27;Si Li&#x27;</span>,<span class="hljs-string">&#x27;Wu Wang&#x27;</span>],name=<span class="hljs-string">&#x27;Name&#x27;</span>))<br>df1.join(df2, how=<span class="hljs-string">&#x27;left&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Age</th><th>Gender</th></tr><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>San Zhang</th><td>20</td><td>NaN</td></tr><tr><th>Si Li</th><td>30</td><td>F</td></tr></tbody></table></div><p>仿照第2小节的例子，写出语文和数学分数合并的<code>join</code>版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">70</span>]&#125;, index=pd.Series([<span class="hljs-string">&#x27;San Zhang&#x27;</span>], name=<span class="hljs-string">&#x27;Name&#x27;</span>))<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">80</span>]&#125;, index=pd.Series([<span class="hljs-string">&#x27;San Zhang&#x27;</span>], name=<span class="hljs-string">&#x27;Name&#x27;</span>))<br>df1.join(df2, how=<span class="hljs-string">&#x27;left&#x27;</span>, lsuffix=<span class="hljs-string">&#x27;_Chinese&#x27;</span>, rsuffix=<span class="hljs-string">&#x27;_Math&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Grade_Chinese</th><th>Grade_Math</th></tr><tr><th>Name</th><th></th><th></th></tr></thead><tbody><tr><th>San Zhang</th><td>70</td><td>80</td></tr></tbody></table></div><p>如果想要进行类似于<code>merge</code>中以多列为键的操作的时候，<code>join</code>需要使用多级索引，例如在<code>merge</code>中的最后一个例子可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>,<span class="hljs-number">21</span>]&#125;, index=pd.MultiIndex.from_arrays([[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;San Zhang&#x27;</span>],[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>]], names=(<span class="hljs-string">&#x27;Name&#x27;</span>,<span class="hljs-string">&#x27;Class&#x27;</span>)))<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Gender&#x27;</span>:[<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>]&#125;, index=pd.MultiIndex.from_arrays([[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;San Zhang&#x27;</span>],[<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>]], names=(<span class="hljs-string">&#x27;Name&#x27;</span>,<span class="hljs-string">&#x27;Class&#x27;</span>)))<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Age</th></tr><tr><th>Name</th><th>Class</th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">San Zhang</th><th>one</th><td>20</td></tr><tr><th>two</th><td>21</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df2<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Gender</th></tr><tr><th>Name</th><th>Class</th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">San Zhang</th><th>two</th><td>F</td></tr><tr><th>one</th><td>M</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.join(df2)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Age</th><th>Gender</th></tr><tr><th>Name</th><th>Class</th><th></th><th></th></tr></thead><tbody><tr><th rowspan="2" valign="top">San Zhang</th><th>one</th><td>20</td><td>M</td></tr><tr><th>two</th><td>21</td><td>F</td></tr></tbody></table></div><h2 id="二方向连接">二、方向连接</h2><h3 id="concat">1. concat</h3><p>前面介绍了关系型连接，其中最重要的参数是<code>on</code>和<code>how</code>，但有时候用户并不关心以哪一列为键来合并，只是希望把两个表或者多个表按照纵向或者横向拼接，为这种需求，<code>pandas</code>中提供了<code>concat</code>函数来实现。</p><p>在<code>concat</code>中，最常用的有三个参数，它们是<code>axis, join, keys</code>，分别表示拼接方向，连接形式，以及在新表中指示来自于哪一张旧表的名字。这里需要特别注意，<code>join</code>和<code>keys</code>与之前提到的<code>join</code>函数和键的概念没有任何关系。</p><p>在默认状态下的<code>axis=0</code>，表示纵向拼接多个表，常常用于多个样本的拼接；而<code>axis=1</code>表示横向拼接多个表，常用于多个字段或特征的拼接。</p><p>例如，纵向合并各表中人的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>,<span class="hljs-string">&#x27;Si Li&#x27;</span>], <span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;Wu Wang&#x27;</span>], <span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">40</span>]&#125;)<br>pd.concat([df1, df2])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td></tr><tr><th>1</th><td>Si Li</td><td>30</td></tr><tr><th>0</th><td>Wu Wang</td><td>40</td></tr></tbody></table></div><p>横向合并各表中的字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">90</span>]&#125;)<br>df3 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Gender&#x27;</span>:[<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>]&#125;)<br>pd.concat([df1, df2, df3], <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Grade</th><th>Gender</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td><td>80</td><td>M</td></tr><tr><th>1</th><td>Si Li</td><td>30</td><td>90</td><td>F</td></tr></tbody></table></div><p>虽然说<code>concat</code>是处理关系型合并的函数，但是它仍然是关于索引进行连接的。纵向拼接会根据列索引对其，默认状态下<code>join=outer</code>，表示保留所有的列，并将不存在的值设为缺失；<code>join=inner</code>，表示保留两个表都出现过的列。横向拼接则根据行索引对齐，<code>join</code>参数可以类似设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;Wu Wang&#x27;</span>], <span class="hljs-string">&#x27;Gender&#x27;</span>:[<span class="hljs-string">&#x27;M&#x27;</span>]&#125;)<br>pd.concat([df1, df2])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Gender</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20.0</td><td>NaN</td></tr><tr><th>1</th><td>Si Li</td><td>30.0</td><td>NaN</td></tr><tr><th>0</th><td>Wu Wang</td><td>NaN</td><td>M</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Grade&#x27;</span>:[<span class="hljs-number">80</span>, <span class="hljs-number">90</span>]&#125;, index=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>pd.concat([df1, df2], <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Grade</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20.0</td><td>NaN</td></tr><tr><th>1</th><td>Si Li</td><td>30.0</td><td>80.0</td></tr><tr><th>2</th><td>NaN</td><td>NaN</td><td>90.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([df1, df2], axis=<span class="hljs-number">1</span>, join=<span class="hljs-string">&#x27;inner&#x27;</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Grade</th></tr></thead><tbody><tr><th>1</th><td>Si Li</td><td>30</td><td>80</td></tr></tbody></table></div><p>因此，当确认要使用多表直接的方向合并时，尤其是横向的合并，可以先用<code>reset_index</code>方法恢复默认整数索引再进行合并，防止出现由索引的误对齐和重复索引的笛卡尔积带来的错误结果。</p><p>最后，<code>keys</code>参数的使用场景在于多个表合并后，用户仍然想要知道新表中的数据来自于哪个原表，这时可以通过<code>keys</code>参数产生多级索引进行标记。例如，第一个表中都是一班的同学，而第二个表中都是二班的同学，可以使用如下方式合并：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>,<span class="hljs-string">&#x27;Si Li&#x27;</span>], <span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>,<span class="hljs-number">21</span>]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;Wu Wang&#x27;</span>],<span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">21</span>]&#125;)<br>pd.concat([df1, df2], keys=[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>])<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th></th><th>Name</th><th>Age</th></tr></thead><tbody><tr><th rowspan="2" valign="top">one</th><th>0</th><td>San Zhang</td><td>20</td></tr><tr><th>1</th><td>Si Li</td><td>21</td></tr><tr><th>two</th><th>0</th><td>Wu Wang</td><td>21</td></tr></tbody></table></div><h3 id="序列与表的合并">2. 序列与表的合并</h3><p>利用<code>concat</code>可以实现多个表之间的方向拼接，如果想要把一个序列追加到表的行末或者列末，则可以分别使用<code>append</code>和<code>assign</code>方法。</p><p>在<code>append</code>中，如果原表是默认整数序列的索引，那么可以使用<code>ignore_index=True</code>对新序列对应的索引自动标号，否则必须对<code>Series</code>指定<code>name</code>属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-string">&#x27;Wu Wang&#x27;</span>, <span class="hljs-number">21</span>], index = df1.columns)<br>df1.append(s, ignore_index=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td></tr><tr><th>1</th><td>Si Li</td><td>21</td></tr><tr><th>2</th><td>Wu Wang</td><td>21</td></tr></tbody></table></div><p>对于<code>assign</code>而言，虽然可以利用其添加新的列，但一般通过<code>df['new_col'] = ...</code>的形式就可以等价地添加新列。同时，使用<code>[]</code>修改的缺点是它会直接在原表上进行改动，而<code>assign</code>返回的是一个临时副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">80</span>, <span class="hljs-number">90</span>])<br>df1.assign(Grade=s)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Grade</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td><td>80</td></tr><tr><th>1</th><td>Si Li</td><td>21</td><td>90</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;Grade&#x27;</span>] = s<br>df1<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Name</th><th>Age</th><th>Grade</th></tr></thead><tbody><tr><th>0</th><td>San Zhang</td><td>20</td><td>80</td></tr><tr><th>1</th><td>Si Li</td><td>21</td><td>90</td></tr></tbody></table></div><h2 id="三类连接操作">三、类连接操作</h2><p>除了上述介绍的若干连接函数之外，<code>pandas</code>中还设计了一些函数能够对两个表进行某些操作，这里把它们统称为类连接操作。</p><h3 id="比较">1. 比较</h3><p><code>compare</code>是在<code>1.1.0</code>后引入的新函数，它能够比较两个表或者序列的不同处并将其汇总展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;Si Li&#x27;</span>, <span class="hljs-string">&#x27;Wu Wang&#x27;</span>],<br>                    <span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>, <span class="hljs-number">21</span> ,<span class="hljs-number">21</span>],<br>                    <span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Name&#x27;</span>:[<span class="hljs-string">&#x27;San Zhang&#x27;</span>, <span class="hljs-string">&#x27;Li Si&#x27;</span>, <span class="hljs-string">&#x27;Wu Wang&#x27;</span>],<br>                    <span class="hljs-string">&#x27;Age&#x27;</span>:[<span class="hljs-number">20</span>, <span class="hljs-number">21</span> ,<span class="hljs-number">21</span>],<br>                    <span class="hljs-string">&#x27;Class&#x27;</span>:[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;Three&#x27;</span>]&#125;)<br>df1.compare(df2)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th colspan="2" halign="left">Name</th><th colspan="2" halign="left">Class</th></tr><tr><th></th><th>self</th><th>other</th><th>self</th><th>other</th></tr></thead><tbody><tr><th>1</th><td>Si Li</td><td>Li Si</td><td>NaN</td><td>NaN</td></tr><tr><th>2</th><td>NaN</td><td>NaN</td><td>three</td><td>Three</td></tr></tbody></table></div><p>结果中返回了不同值所在的行列，如果相同则会被填充为缺失值<code>NaN</code>，其中<code>other</code>和<code>self</code>分别指代传入的参数表和被调用的表自身。</p><p>如果想要完整显示表中所有元素的比较情况，可以设置<code>keep_shape=True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.compare(df2, keep_shape=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead tr th {        text-align: left;    }</style><table border="1" class="dataframe"><thead><tr><th></th><th colspan="2" halign="left">Name</th><th colspan="2" halign="left">Age</th><th colspan="2" halign="left">Class</th></tr><tr><th></th><th>self</th><th>other</th><th>self</th><th>other</th><th>self</th><th>other</th></tr></thead><tbody><tr><th>0</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>Si Li</td><td>Li Si</td><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>2</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td><td>three</td><td>Three</td></tr></tbody></table></div><h3 id="组合">2. 组合</h3><p><code>combine</code>函数能够让两张表按照一定的规则进行组合，在进行规则比较时会自动进行列索引的对齐。对于传入的函数而言，每一次操作中输入的参数是来自两个表的同名<code>Series</code>，依次传入的列是两个表列名的并集，例如下面这个例子会依次传入<code>A,B,C,D</code>四组序列，每组为左右表的两个序列。同时，进行<code>A</code>列比较的时候，<code>s2</code>指代的就是一个全空的序列，因为它在被调用的表中并不存在，并且来自第一个表的序列索引会被<code>reindex</code>成两个索引的并集。具体的过程可以通过在传入的函数中插入适当的<code>print</code>方法查看。</p><p>下面的例子表示选出对应索引位置较小的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">choose_min</span>(<span class="hljs-params">s1, s2</span>):<br>    s2 = s2.reindex_like(s1)<br>    res = s1.where(s1&lt;s2, s2)<br>    res = res.mask(s1.isna()) <span class="hljs-comment"># isna表示是否为缺失值，返回布尔序列</span><br>    <span class="hljs-keyword">return</span> res<br>df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;B&#x27;</span>:[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-string">&#x27;C&#x27;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;B&#x27;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-string">&#x27;C&#x27;</span>:[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>], <span class="hljs-string">&#x27;D&#x27;</span>:[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]&#125;, index=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>df1.combine(df2, choose_min)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><th>0</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>NaN</td><td>4.0</td><td>6.0</td><td>NaN</td></tr><tr><th>2</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><h4 id="练一练-1">【练一练】</h4><p>请在上述代码的基础上修改，保留<code>df2</code>中4个未被<code>df1</code>替换的相应位置原始值。#### 【END】此外，设置<code>overtwrite</code>参数为<code>False</code>可以保留<spanclass="math inline">\(\color{red}{被调用表}\)</span>中未出现在传入的参数表中的列，而不会设置未缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.combine(df2, choose_min, overwrite=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><th>0</th><td>1.0</td><td>NaN</td><td>NaN</td><td>NaN</td></tr><tr><th>1</th><td>2.0</td><td>4.0</td><td>6.0</td><td>NaN</td></tr><tr><th>2</th><td>NaN</td><td>NaN</td><td>NaN</td><td>NaN</td></tr></tbody></table></div><h4 id="练一练-2">【练一练】</h4><p>除了<code>combine</code>之外，<code>pandas</code>中还有一个<code>combine_first</code>方法，其功能是在对两张表组合时，若第二张表中的值在第一张表中对应索引位置的值不是缺失状态，那么就使用第一张表的值填充。下面给出一个例子，请用<code>combine</code>函数完成相同的功能。#### 【END】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;B&#x27;</span>:[<span class="hljs-number">3</span>,np.nan]&#125;)<br>df2 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-string">&#x27;B&#x27;</span>:[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]&#125;, index=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>df1.combine_first(df2)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><th>0</th><td>1.0</td><td>3.0</td></tr><tr><th>1</th><td>2.0</td><td>7.0</td></tr><tr><th>2</th><td>6.0</td><td>8.0</td></tr></tbody></table></div><h2 id="四练习">四、练习</h2><h3 id="ex1美国疫情数据集">Ex1：美国疫情数据集</h3><p>现有美国4月12日至11月16日的疫情报表（在<code>/data/us_report</code>文件夹下），请将<code>New York</code>的<code>Confirmed, Deaths, Recovered, Active</code>合并为一张表，索引为按如下方法生成的日期字符串序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">date = pd.date_range(<span class="hljs-string">&#x27;20200412&#x27;</span>, <span class="hljs-string">&#x27;20201116&#x27;</span>).to_series()<br>date = date.dt.month.astype(<span class="hljs-string">&#x27;string&#x27;</span>).<span class="hljs-built_in">str</span>.zfill(<span class="hljs-number">2</span>) +<span class="hljs-string">&#x27;-&#x27;</span>+ date.dt.day.astype(<span class="hljs-string">&#x27;string&#x27;</span>).<span class="hljs-built_in">str</span>.zfill(<span class="hljs-number">2</span>) +<span class="hljs-string">&#x27;-&#x27;</span>+ <span class="hljs-string">&#x27;2020&#x27;</span><br>date = date.tolist()<br>date[:<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&#39;04-12-2020&#39;, &#39;04-13-2020&#39;, &#39;04-14-2020&#39;, &#39;04-15-2020&#39;, &#39;04-16-2020&#39;]</code></pre><h3 id="ex2实现join函数">Ex2：实现join函数</h3><p>请实现带有<code>how</code>参数的<code>join</code>函数</p><ul><li>假设连接的两表无公共列</li><li>调用方式为 <code>join(df1, df2, how="left")</code></li><li>给出测试样例</li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas时序数据</title>
    <link href="/2023/10/01/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE/"/>
    <url>/2023/10/01/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas时序数据">Pandas时序数据</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="一时序中的基本对象">一、时序中的基本对象</h2><p>时间序列的概念在日常生活中十分常见，但对于一个具体的时序事件而言，可以从多个时间对象的角度来描述。例如2020年9月7日周一早上8点整需要到教室上课，这个课会在当天早上10点结束，其中包含了哪些时间概念？</p><ul><li><p>第一，会出现时间戳（Date times）的概念，即'2020-9-708:00:00'和'2020-9-710:00:00'这两个时间点分别代表了上课和下课的时刻，在<code>pandas</code>中称为<code>Timestamp</code>。同时，一系列的时间戳可以组成<code>DatetimeIndex</code>，而将它放到<code>Series</code>中后，<code>Series</code>的类型就变为了<code>datetime64[ns]</code>，如果有涉及时区则为<code>datetime64[ns, tz]</code>，其中tz是timezone的简写。</p></li><li><p>第二，会出现时间差（Timedeltas）的概念，即上课需要的时间，两个<code>Timestamp</code>做差就得到了时间差，pandas中利用<code>Timedelta</code>来表示。类似的，一系列的时间差就组成了<code>TimedeltaIndex</code>，而将它放到<code>Series</code>中后，<code>Series</code>的类型就变为了<code>timedelta64[ns]</code>。</p></li><li><p>第三，会出现时间段（Timespans）的概念，即在8点到10点这个区间都会持续地在上课，在<code>pandas</code>利用<code>Period</code>来表示。类似的，一系列的时间段就组成了<code>PeriodIndex</code>，而将它放到<code>Series</code>中后，<code>Series</code>的类型就变为了<code>Period</code>。</p></li><li><p>第四，会出现日期偏置（Dateoffsets）的概念，假设你只知道9月的第一个周一早上8点要去上课，但不知道具体的日期，那么就需要一个类型来处理此类需求。再例如，想要知道2020年9月7日后的第30个工作日是哪一天，那么时间差就解决不了你的问题，从而<code>pandas</code>中的<code>DateOffset</code>就出现了。同时，<code>pandas</code>中没有为一列时间偏置专门设计存储类型，理由也很简单，因为需求比较奇怪，一般来说我们只需要对一批时间特征做一个统一的特殊日期偏置。</p></li></ul><p>通过这个简单的例子，就能够容易地总结出官方文档中的这个<ahref="https://pandas.pydata.org/docs/user_guide/timeseries.html#overview">表格</a>：</p><table><thead><tr class="header"><th style="text-align: left;">概念</th><th style="text-align: left;">单元素类型</th><th style="text-align: left;">数组类型</th><th style="text-align: left;">pandas数据类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Date times</td><td style="text-align: left;"><code>Timestamp</code></td><td style="text-align: left;"><code>DatetimeIndex</code></td><td style="text-align: left;"><code>datetime64[ns]</code></td></tr><tr class="even"><td style="text-align: left;">Time deltas</td><td style="text-align: left;"><code>Timedelta</code></td><td style="text-align: left;"><code>TimedeltaIndex</code></td><td style="text-align: left;"><code>timedelta64[ns]</code></td></tr><tr class="odd"><td style="text-align: left;">Time spans</td><td style="text-align: left;"><code>Period</code></td><td style="text-align: left;"><code>PeriodIndex</code></td><td style="text-align: left;"><code>period[freq]</code></td></tr><tr class="even"><td style="text-align: left;">Date offsets</td><td style="text-align: left;"><code>DateOffset</code></td><td style="text-align: left;"><code>None</code></td><td style="text-align: left;"><code>None</code></td></tr></tbody></table><p>由于时间段对象<code>Period/PeriodIndex</code>的使用频率并不高，因此将不进行讲解，而只涉及时间戳序列、时间差序列和日期偏置的相关内容。</p><h2 id="二时间戳">二、时间戳</h2><h3 id="timestamp的构造与属性">1. Timestamp的构造与属性</h3><p>单个时间戳的生成利用<code>pd.Timestamp</code>实现，一般而言的常见日期格式都能被成功地转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ts = pd.Timestamp(<span class="hljs-string">&#x27;2020/1/1&#x27;</span>)<br>ts<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2020-01-01 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ts = pd.Timestamp(<span class="hljs-string">&#x27;2020-1-1 08:10:30&#x27;</span>)<br>ts<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2020-01-01 08:10:30&#39;)</code></pre><p>通过<code>year, month, day, hour, min, second</code>可以获取具体的数值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ts.year<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ts.month<br></code></pre></td></tr></table></figure><pre><code class="hljs">1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ts.day<br></code></pre></td></tr></table></figure><pre><code class="hljs">1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ts.hour<br></code></pre></td></tr></table></figure><pre><code class="hljs">8</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ts.minute<br></code></pre></td></tr></table></figure><pre><code class="hljs">10</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ts.second<br></code></pre></td></tr></table></figure><pre><code class="hljs">30</code></pre><p>在<code>pandas</code>中，时间戳的最小精度为纳秒<code>ns</code>，由于使用了64位存储，可以表示的时间范围大约可以如下计算：<span class="math display">\[\rm Time\,Range = \frac{2^{64}}{10^9\times60\times 60\times 24\times 365} \approx 585 (Years)\]</span>通过<code>pd.Timestamp.max</code>和<code>pd.Timestamp.min</code>可以获取时间戳表示的范围，可以看到确实表示的区间年数大小正如上述计算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp.<span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2262-04-11 23:47:16.854775807&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp.<span class="hljs-built_in">min</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;1677-09-21 00:12:43.145225&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp.<span class="hljs-built_in">max</span>.year - pd.Timestamp.<span class="hljs-built_in">min</span>.year<br></code></pre></td></tr></table></figure><pre><code class="hljs">585</code></pre><h3 id="datetime序列的生成">2. Datetime序列的生成</h3><p>一组时间戳可以组成时间序列，可以用<code>to_datetime</code>和<code>date_range</code>来生成。其中，<code>to_datetime</code>能够把一列时间戳格式的对象转换成为<code>datetime64[ns]</code>类型的时间序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.to_datetime([<span class="hljs-string">&#x27;2020-1-1&#x27;</span>, <span class="hljs-string">&#x27;2020-1-3&#x27;</span>, <span class="hljs-string">&#x27;2020-1-6&#x27;</span>])<br>df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>)<br>s = pd.to_datetime(df.Test_Date)<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   2019-10-051   2019-09-042   2019-09-123   2020-01-034   2019-11-06Name: Test_Date, dtype: datetime64[ns]</code></pre><p>在极少数情况，时间戳的格式不满足转换时，可以强制使用<code>format</code>进行匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">temp = pd.to_datetime([<span class="hljs-string">&#x27;2020\\1\\1&#x27;</span>,<span class="hljs-string">&#x27;2020\\1\\3&#x27;</span>],<span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%Y\\%m\\%d&#x27;</span>)<br>temp<br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01&#39;, &#39;2020-01-03&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>注意上面由于传入的是列表，而非<code>pandas</code>内部的<code>Series</code>，因此返回的是<code>DatetimeIndex</code>，如果想要转为<code>datetime64[ns]</code>的序列，需要显式用<code>Series</code>转化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Series(temp).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   2020-01-011   2020-01-03dtype: datetime64[ns]</code></pre><p>另外，还存在一种把表的多列时间属性拼接转为时间序列的<code>to_datetime</code>操作，此时的列名必须和以下给定的时间关键词列名一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">df_date_cols = pd.DataFrame(&#123;<span class="hljs-string">&#x27;year&#x27;</span>: [<span class="hljs-number">2020</span>, <span class="hljs-number">2020</span>],<br>                             <span class="hljs-string">&#x27;month&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>                             <span class="hljs-string">&#x27;day&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>                             <span class="hljs-string">&#x27;hour&#x27;</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>],<br>                             <span class="hljs-string">&#x27;minute&#x27;</span>: [<span class="hljs-number">30</span>, <span class="hljs-number">50</span>],<br>                             <span class="hljs-string">&#x27;second&#x27;</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">40</span>]&#125;)<br>pd.to_datetime(df_date_cols)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   2020-01-01 10:30:201   2020-01-02 20:50:40dtype: datetime64[ns]</code></pre><p><code>date_range</code>是一种生成连续间隔时间的一种方法，其重要的参数为<code>start, end, freq, periods</code>，它们分别表示开始时间，结束时间，时间间隔，时间戳个数。其中，四个中的三个参数决定了，那么剩下的一个就随之确定了。这里要注意，开始或结束日期如果作为端点则它会被包含：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;2020-1-1&#x27;</span>,<span class="hljs-string">&#x27;2020-1-21&#x27;</span>, freq=<span class="hljs-string">&#x27;10D&#x27;</span>) <span class="hljs-comment"># 包含</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01&#39;, &#39;2020-01-11&#39;, &#39;2020-01-21&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;10D&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;2020-1-1&#x27;</span>,<span class="hljs-string">&#x27;2020-2-28&#x27;</span>, freq=<span class="hljs-string">&#x27;10D&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01&#39;, &#39;2020-01-11&#39;, &#39;2020-01-21&#39;, &#39;2020-01-31&#39;,               &#39;2020-02-10&#39;, &#39;2020-02-20&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;10D&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;2020-1-1&#x27;</span>, <span class="hljs-string">&#x27;2020-2-28&#x27;</span>, periods=<span class="hljs-number">6</span>) <span class="hljs-comment"># 由于结束日期无法取到，freq不为10天</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01 00:00:00&#39;, &#39;2020-01-12 14:24:00&#39;,               &#39;2020-01-24 04:48:00&#39;, &#39;2020-02-04 19:12:00&#39;,               &#39;2020-02-16 09:36:00&#39;, &#39;2020-02-28 00:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>这里的<code>freq</code>参数与<code>DateOffset</code>对象紧密相关，将在第四节介绍其具体的用法。#### 【练一练】<code>Timestamp</code>上定义了一个<code>value</code>属性，其返回的整数值代表了从1970年1月1日零点到给定时间戳相差的纳秒数，请利用这个属性构造一个随机生成给定日期区间内日期序列的函数。#### 【END】最后，要介绍一种改变序列采样频率的方法<code>asfreq</code>，它能够根据给定的<code>freq</code>对序列进行类似于<code>reindex</code>的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series(np.random.rand(<span class="hljs-number">5</span>), index=pd.to_datetime([<span class="hljs-string">&#x27;2020-1-%d&#x27;</span>%i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)]))<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01    0.3939112020-01-03    0.7036502020-01-05    0.6500462020-01-07    0.7262032020-01-09    0.126783dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.asfreq(<span class="hljs-string">&#x27;D&#x27;</span>).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01    0.3939112020-01-02         NaN2020-01-03    0.7036502020-01-04         NaN2020-01-05    0.650046Freq: D, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.asfreq(<span class="hljs-string">&#x27;12H&#x27;</span>).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01 00:00:00    0.3939112020-01-01 12:00:00         NaN2020-01-02 00:00:00         NaN2020-01-02 12:00:00         NaN2020-01-03 00:00:00    0.703650Freq: 12H, dtype: float64</code></pre><h4 id="note">【NOTE】</h4><p>前面提到了<code>datetime64[ns]</code>本质上可以理解为一个大整数，对于一个该类型的序列，可以使用<code>max, min, mean</code>，来取得最大时间戳、最小时间戳和“平均”时间戳。#### 【END】 ### 3. dt对象</p><p>如同<code>category, string</code>的序列上定义了<code>cat, str</code>来完成分类数据和文本数据的操作，在时序类型的序列上定义了<code>dt</code>对象来完成许多时间序列的相关操作。这里对于<code>datetime64[ns]</code>类型而言，可以大致分为三类操作：取出时间相关的属性、判断时间戳是否满足条件、取整操作。</p><p>第一类操作的常用属性包括：<code>date, time, year, month, day, hour, minute, second, microsecond, nanosecond, dayofweek, dayofyear, weekofyear, daysinmonth, quarter</code>，其中<code>daysinmonth, quarter</code>分别表示该月一共有几天和季度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series(pd.date_range(<span class="hljs-string">&#x27;2020-1-1&#x27;</span>,<span class="hljs-string">&#x27;2020-1-3&#x27;</span>, freq=<span class="hljs-string">&#x27;D&#x27;</span>))<br>s.dt.date<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    2020-01-011    2020-01-022    2020-01-03dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.time<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    00:00:001    00:00:002    00:00:00dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.day<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    11    22    3dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.daysinmonth<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    311    312    31dtype: int64</code></pre><p>在这些属性中，经常使用的是<code>dayofweek</code>，它返回了周中的星期情况，周一为0、周二为1，以此类推：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.dayofweek<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    21    32    4dtype: int64</code></pre><p>此外，可以通过<code>month_name, day_name</code>返回英文的月名和星期名，注意它们是方法而不是属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.month_name()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    January1    January2    Januarydtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.day_name()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    Wednesday1     Thursday2       Fridaydtype: object</code></pre><p>第二类判断操作主要用于测试是否为月/季/年的第一天或者最后一天：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.is_year_start <span class="hljs-comment"># 还可选 is_quarter/month_start</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0     True1    False2    Falsedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.is_year_end <span class="hljs-comment"># 还可选 is_quarter/month_end</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    False1    False2    Falsedtype: bool</code></pre><p>第三类的取整操作包含<code>round, ceil, floor</code>，它们的公共参数为<code>freq</code>，常用的包括<code>H, min, S</code>（小时、分钟、秒），所有可选的<code>freq</code>可参考<ahref="https://pandas.pydata.org/docs/user_guide/timeseries.html#offset-aliases%3E">此处</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series(pd.date_range(<span class="hljs-string">&#x27;2020-1-1 20:35:00&#x27;</span>, <span class="hljs-string">&#x27;2020-1-1 22:35:00&#x27;</span>, freq=<span class="hljs-string">&#x27;45min&#x27;</span>))<br>s<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   2020-01-01 20:35:001   2020-01-01 21:20:002   2020-01-01 22:05:00dtype: datetime64[ns]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.<span class="hljs-built_in">round</span>(<span class="hljs-string">&#x27;1H&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   2020-01-01 21:00:001   2020-01-01 21:00:002   2020-01-01 22:00:00dtype: datetime64[ns]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.ceil(<span class="hljs-string">&#x27;1H&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   2020-01-01 21:00:001   2020-01-01 22:00:002   2020-01-01 23:00:00dtype: datetime64[ns]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.floor(<span class="hljs-string">&#x27;1H&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   2020-01-01 20:00:001   2020-01-01 21:00:002   2020-01-01 22:00:00dtype: datetime64[ns]</code></pre><h3 id="时间戳的切片与索引">4. 时间戳的切片与索引</h3><p>一般而言，时间戳序列作为索引使用。如果想要选出某个子时间戳序列，第一类方法是利用<code>dt</code>对象和布尔条件联合使用，另一种方式是利用切片，后者常用于连续时间戳。下面，举一些例子说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series(np.random.randint(<span class="hljs-number">2</span>,size=<span class="hljs-number">366</span>), index=pd.date_range(<span class="hljs-string">&#x27;2020-01-01&#x27;</span>,<span class="hljs-string">&#x27;2020-12-31&#x27;</span>))<br>idx = pd.Series(s.index).dt<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01    02020-01-02    12020-01-03    12020-01-04    02020-01-05    0Freq: D, dtype: int32</code></pre><p>Example1：每月的第一天或者最后一天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[(idx.is_month_start|idx.is_month_end).values].head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01    02020-01-31    12020-02-01    12020-02-29    12020-03-01    0dtype: int32</code></pre><p>Example2：双休日</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[idx.dayofweek.isin([<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]).values].head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-04    02020-01-05    02020-01-11    12020-01-12    02020-01-18    0dtype: int32</code></pre><p>Example3：取出单日值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;2020-01-01&#x27;</span>]<br></code></pre></td></tr></table></figure><pre><code class="hljs">0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;20200101&#x27;</span>] <span class="hljs-comment"># 自动转换标准格式</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0</code></pre><p>Example4：取出七月</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;2020-07&#x27;</span>].head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-07-01    12020-07-02    12020-07-03    02020-07-04    12020-07-05    0Freq: D, dtype: int32</code></pre><p>Example5：取出5月初至7月15日</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;2020-05&#x27;</span>:<span class="hljs-string">&#x27;2020-7-15&#x27;</span>].head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-05-01    12020-05-02    12020-05-03    12020-05-04    12020-05-05    1Freq: D, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[<span class="hljs-string">&#x27;2020-05&#x27;</span>:<span class="hljs-string">&#x27;2020-7-15&#x27;</span>].tail()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-07-11    12020-07-12    12020-07-13    12020-07-14    12020-07-15    1Freq: D, dtype: int32</code></pre><h2 id="三时间差">三、时间差</h2><h3 id="timedelta的生成">1. Timedelta的生成</h3><p>正如在第一节中所说，时间差可以理解为两个时间戳的差，这里也可以通过<code>pd.Timedelta</code>来构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp(<span class="hljs-string">&#x27;20200102 08:00:00&#x27;</span>)-pd.Timestamp(<span class="hljs-string">&#x27;20200101 07:35:00&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timedelta(&#39;1 days 00:25:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timedelta(days=<span class="hljs-number">1</span>, minutes=<span class="hljs-number">25</span>) <span class="hljs-comment"># 需要注意加s</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">Timedelta(&#39;1 days 00:25:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timedelta(<span class="hljs-string">&#x27;1 days 25 minutes&#x27;</span>) <span class="hljs-comment"># 字符串生成</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">Timedelta(&#39;1 days 00:25:00&#39;)</code></pre><p>生成时间差序列的主要方式是<code>pd.to_timedelta</code>，其类型为<code>timedelta64[ns]</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.to_timedelta(df.Time_Record)<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   0 days 00:04:341   0 days 00:04:202   0 days 00:05:223   0 days 00:04:084   0 days 00:05:22Name: Time_Record, dtype: timedelta64[ns]</code></pre><p>与<code>date_range</code>一样，时间差序列也可以用<code>timedelta_range</code>来生成，它们两者具有一致的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.timedelta_range(<span class="hljs-string">&#x27;0s&#x27;</span>, <span class="hljs-string">&#x27;1000s&#x27;</span>, freq=<span class="hljs-string">&#x27;6min&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">TimedeltaIndex([&#39;0 days 00:00:00&#39;, &#39;0 days 00:06:00&#39;, &#39;0 days 00:12:00&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;6T&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.timedelta_range(<span class="hljs-string">&#x27;0s&#x27;</span>, <span class="hljs-string">&#x27;1000s&#x27;</span>, periods=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">TimedeltaIndex([&#39;0 days 00:00:00&#39;, &#39;0 days 00:08:20&#39;, &#39;0 days 00:16:40&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><p>对于<code>Timedelta</code>序列，同样也定义了<code>dt</code>对象，上面主要定义了的属性包括<code>days, seconds, mircroseconds, nanoseconds</code>，它们分别返回了对应的时间差特征。需要注意的是，这里的<code>seconds</code>不是指单纯的秒，而是对天数取余后剩余的秒数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.seconds.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    2741    2602    3223    2484    322Name: Time_Record, dtype: int64</code></pre><p>如果不想对天数取余而直接对应秒数，可以使用<code>total_seconds</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.dt.total_seconds().head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    274.01    260.02    322.03    248.04    322.0Name: Time_Record, dtype: float64</code></pre><p>与时间戳序列类似，取整函数也是可以在<code>dt</code>对象上使用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.to_timedelta(df.Time_Record).dt.<span class="hljs-built_in">round</span>(<span class="hljs-string">&#x27;min&#x27;</span>).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   0 days 00:05:001   0 days 00:04:002   0 days 00:05:003   0 days 00:04:004   0 days 00:05:00Name: Time_Record, dtype: timedelta64[ns]</code></pre><h3 id="timedelta的运算">2. Timedelta的运算</h3><p>时间差支持的常用运算有三类：与标量的乘法运算、与时间戳的加减法运算、与时间差的加减法与除法运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">td1 = pd.Timedelta(days=<span class="hljs-number">1</span>)<br>td2 = pd.Timedelta(days=<span class="hljs-number">3</span>)<br>ts = pd.Timestamp(<span class="hljs-string">&#x27;20200101&#x27;</span>)<br>td1 * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">Timedelta(&#39;2 days 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">td2 - td1<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timedelta(&#39;2 days 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ts + td1<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2020-01-02 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ts - td1<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2019-12-31 00:00:00&#39;)</code></pre><p>这些运算都可以移植到时间差的序列上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">td1 = pd.timedelta_range(start=<span class="hljs-string">&#x27;1 days&#x27;</span>, periods=<span class="hljs-number">5</span>)<br>td2 = pd.timedelta_range(start=<span class="hljs-string">&#x27;12 hours&#x27;</span>, freq=<span class="hljs-string">&#x27;2H&#x27;</span>, periods=<span class="hljs-number">5</span>)<br>ts = pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>, <span class="hljs-string">&#x27;20200105&#x27;</span>)<br>td1 * <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">TimedeltaIndex([&#39;5 days&#39;, &#39;10 days&#39;, &#39;15 days&#39;, &#39;20 days&#39;, &#39;25 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;5D&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">td1 * pd.Series(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))) <span class="hljs-comment"># 逐个相乘</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">0    0 days1    2 days2    6 days3   12 days4   20 daysdtype: timedelta64[ns]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">td1 - td2<br></code></pre></td></tr></table></figure><pre><code class="hljs">TimedeltaIndex([&#39;0 days 12:00:00&#39;, &#39;1 days 10:00:00&#39;, &#39;2 days 08:00:00&#39;,                &#39;3 days 06:00:00&#39;, &#39;4 days 04:00:00&#39;],               dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">td1 + pd.Timestamp(<span class="hljs-string">&#x27;20200101&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-02&#39;, &#39;2020-01-03&#39;, &#39;2020-01-04&#39;, &#39;2020-01-05&#39;,               &#39;2020-01-06&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">td1 + ts <span class="hljs-comment"># 逐个相加</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-02&#39;, &#39;2020-01-04&#39;, &#39;2020-01-06&#39;, &#39;2020-01-08&#39;,               &#39;2020-01-10&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><h2 id="四日期偏置">四、日期偏置</h2><h3 id="offset对象">1. Offset对象</h3><p>日期偏置是一种和日历相关的特殊时间差，例如回到第一节中的两个问题：如何求2020年9月第一个周一的日期，以及如何求2020年9月7日后的第30个工作日是哪一天。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp(<span class="hljs-string">&#x27;20200831&#x27;</span>) + pd.offsets.WeekOfMonth(week=<span class="hljs-number">0</span>,weekday=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2020-09-07 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp(<span class="hljs-string">&#x27;20200907&#x27;</span>) + pd.offsets.BDay(<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2020-10-19 00:00:00&#39;)</code></pre><p>从上面的例子中可以看到，<code>Offset</code>对象在<code>pd.offsets</code>中被定义。当使用<code>+</code>时获取离其最近的下一个日期，当使用<code>-</code>时获取离其最近的上一个日期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp(<span class="hljs-string">&#x27;20200831&#x27;</span>) - pd.offsets.WeekOfMonth(week=<span class="hljs-number">0</span>,weekday=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2020-08-03 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp(<span class="hljs-string">&#x27;20200907&#x27;</span>) - pd.offsets.BDay(<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2020-07-27 00:00:00&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.Timestamp(<span class="hljs-string">&#x27;20200907&#x27;</span>) + pd.offsets.MonthEnd()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Timestamp(&#39;2020-09-30 00:00:00&#39;)</code></pre><p>常用的日期偏置如下可以查阅这里的<ahref="https://pandas.pydata.org/docs/user_guide/timeseries.html#dateoffset-objects">文档</a>描述。在文档罗列的<code>Offset</code>中，需要介绍一个特殊的<code>Offset</code>对象<code>CDay</code>，其中的<code>holidays, weekmask</code>参数能够分别对自定义的日期和星期进行过滤，前者传入了需要过滤的日期列表，后者传入的是三个字母的星期缩写构成的星期字符串，其作用是只保留字符串中出现的星期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_filter = pd.offsets.CDay(n=<span class="hljs-number">1</span>,weekmask=<span class="hljs-string">&#x27;Wed Fri&#x27;</span>,holidays=[<span class="hljs-string">&#x27;20200109&#x27;</span>])<br>dr = pd.date_range(<span class="hljs-string">&#x27;20200108&#x27;</span>, <span class="hljs-string">&#x27;20200111&#x27;</span>)<br>dr.to_series().dt.dayofweek<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-08    22020-01-09    32020-01-10    42020-01-11    5Freq: D, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[i + my_filter <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dr]<br></code></pre></td></tr></table></figure><pre><code class="hljs">[Timestamp(&#39;2020-01-10 00:00:00&#39;), Timestamp(&#39;2020-01-10 00:00:00&#39;), Timestamp(&#39;2020-01-15 00:00:00&#39;), Timestamp(&#39;2020-01-15 00:00:00&#39;)]</code></pre><p>上面的例子中，<code>n</code>表示增加一天<code>CDay</code>，<code>dr</code>中的第一天为<code>20200108</code>，但由于下一天<code>20200109</code>被排除了，并且<code>20200110</code>是合法的周五，因此转为<code>20200110</code>，其他后面的日期处理类似。#### 【CAUTION】不要使用部分<code>Offset</code> 在当前版本下由于一些<code>bug</code> ，不要使用 <code>Day</code> 级别以下的<code>Offset</code> 对象，比如 <code>Hour, Second</code>等，请使用对应的 <code>Timedelta</code> 对象来代替。 #### 【END】 ### 2.偏置字符串</p><p>前面提到了关于<code>date_range</code>的<code>freq</code>取值可用<code>Offset</code>对象，同时在<code>pandas</code>中几乎每一个<code>Offset</code>对象绑定了日期偏置字符串（<code>frequencies strings/offset aliases</code>），可以指定<code>Offset</code>对应的字符串来替代使用。下面举一些常见的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200331&#x27;</span>, freq=<span class="hljs-string">&#x27;MS&#x27;</span>) <span class="hljs-comment"># 月初</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01&#39;, &#39;2020-02-01&#39;, &#39;2020-03-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200331&#x27;</span>, freq=<span class="hljs-string">&#x27;M&#x27;</span>) <span class="hljs-comment"># 月末</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-31&#39;, &#39;2020-02-29&#39;, &#39;2020-03-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200110&#x27;</span>, freq=<span class="hljs-string">&#x27;B&#x27;</span>) <span class="hljs-comment"># 工作日</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01&#39;, &#39;2020-01-02&#39;, &#39;2020-01-03&#39;, &#39;2020-01-06&#39;,               &#39;2020-01-07&#39;, &#39;2020-01-08&#39;, &#39;2020-01-09&#39;, &#39;2020-01-10&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200201&#x27;</span>, freq=<span class="hljs-string">&#x27;W-MON&#x27;</span>) <span class="hljs-comment"># 周一</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-06&#39;, &#39;2020-01-13&#39;, &#39;2020-01-20&#39;, &#39;2020-01-27&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;W-MON&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200201&#x27;</span>, freq=<span class="hljs-string">&#x27;WOM-1MON&#x27;</span>) <span class="hljs-comment"># 每月第一个周一</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-06&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;WOM-1MON&#39;)</code></pre><p>上面的这些字符串，等价于使用如下的<code>Offset</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200331&#x27;</span>, freq=pd.offsets.MonthBegin())<br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01&#39;, &#39;2020-02-01&#39;, &#39;2020-03-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200331&#x27;</span>, freq=pd.offsets.MonthEnd())<br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-31&#39;, &#39;2020-02-29&#39;, &#39;2020-03-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200110&#x27;</span>, freq=pd.offsets.BDay())<br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-01&#39;, &#39;2020-01-02&#39;, &#39;2020-01-03&#39;, &#39;2020-01-06&#39;,               &#39;2020-01-07&#39;, &#39;2020-01-08&#39;, &#39;2020-01-09&#39;, &#39;2020-01-10&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200201&#x27;</span>, freq=pd.offsets.CDay(weekmask=<span class="hljs-string">&#x27;Mon&#x27;</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-06&#39;, &#39;2020-01-13&#39;, &#39;2020-01-20&#39;, &#39;2020-01-27&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;C&#39;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>,<span class="hljs-string">&#x27;20200201&#x27;</span>, freq=pd.offsets.WeekOfMonth(week=<span class="hljs-number">0</span>,weekday=<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><pre><code class="hljs">DatetimeIndex([&#39;2020-01-06&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;WOM-1MON&#39;)</code></pre><h4 id="caution关于时区问题的说明">【CAUTION】关于时区问题的说明</h4><p>各类时间对象的开发，除了使用<code>python</code>内置的<code>datetime</code>模块，<code>pandas</code>还利用了<code>dateutil</code>模块，很大一部分是为了处理时区问题。总所周知，我国是没有夏令时调整时间一说的，但有些国家会有这种做法，导致了相对而言一天里可能会有23/24/25个小时，也就是<code>relativedelta</code>，这使得<code>Offset</code>对象和<code>Timedelta</code>对象有了对同一问题处理产生不同结果的现象，其中的规则也较为复杂，官方文档的写法存在部分描述错误，并且难以对描述做出统一修正，因为牵涉到了<code>Offset</code>相关的很多组件。因此，本教程完全不考虑时区处理，如果对时区处理的时间偏置有兴趣了解讨论，可以联系我或者参见<ahref="https://github.com/pandas-dev/pandas/pull/36516">这里</a>的讨论。#### 【END】 ## 五、时序中的滑窗与分组 ### 1. 滑动窗口</p><p>所谓时序的滑窗函数，即把滑动窗口用<code>freq</code>关键词代替，下面给出一个具体的应用案例：在股票市场中有一个指标为<code>BOLL</code>指标，它由中轨线、上轨线、下轨线这三根线构成，具体的计算方法分别是<code>N</code>日均值线、<code>N</code>日均值加两倍<code>N</code>日标准差线、<code>N</code>日均值减两倍<code>N</code>日标准差线。利用<code>rolling</code>对象计算<code>N=30</code>的<code>BOLL</code>指标可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>idx = pd.date_range(<span class="hljs-string">&#x27;20200101&#x27;</span>, <span class="hljs-string">&#x27;20201231&#x27;</span>, freq=<span class="hljs-string">&#x27;B&#x27;</span>)<br>np.random.seed(<span class="hljs-number">2020</span>)<br>data = np.random.randint(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(idx)).cumsum() <span class="hljs-comment"># 随机游动构造模拟序列</span><br>s = pd.Series(data,index=idx)<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01   -12020-01-02   -22020-01-03   -12020-01-06   -12020-01-07   -2Freq: B, dtype: int32</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">r = s.rolling(<span class="hljs-string">&#x27;30D&#x27;</span>)<br>plt.plot(s)<br>plt.title(<span class="hljs-string">&#x27;BOLL LINES&#x27;</span>)<br>plt.plot(r.mean())<br>plt.plot(r.mean()+r.std()*<span class="hljs-number">2</span>)<br>plt.plot(r.mean()-r.std()*<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[&lt;matplotlib.lines.Line2D at 0x26941924dc8&gt;]</code></pre><figure><imgsrc="%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE_files/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE_114_1.svg"alt="svg" /><figcaption aria-hidden="true">svg</figcaption></figure><p>对于<code>shift</code>函数而言，作用在<code>datetime64</code>为索引的序列上时，可以指定<code>freq</code>单位进行滑动：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.shift(freq=<span class="hljs-string">&#x27;50D&#x27;</span>).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-02-20   -12020-02-21   -22020-02-22   -12020-02-25   -12020-02-26   -2dtype: int32</code></pre><p>另外，<code>datetime64[ns]</code>的序列进行<code>diff</code>后就能够得到<code>timedelta64[ns]</code>的序列，这能够使用户方便地观察有序时间序列的间隔：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_series = pd.Series(s.index)<br>my_series.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0   2020-01-011   2020-01-022   2020-01-033   2020-01-064   2020-01-07dtype: datetime64[ns]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_series.diff(<span class="hljs-number">1</span>).head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      NaT1   1 days2   1 days3   3 days4   1 daysdtype: timedelta64[ns]</code></pre><h3 id="重采样">2. 重采样</h3><p>重采样对象<code>resample</code>和第四章中分组对象<code>groupby</code>的用法类似，前者是针对时间序列的分组计算而设计的分组对象。</p><p>例如，对上面的序列计算每10天的均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.resample(<span class="hljs-string">&#x27;10D&#x27;</span>).mean().head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01   -2.0000002020-01-11   -3.1666672020-01-21   -3.6250002020-01-31   -4.0000002020-02-10   -0.375000Freq: 10D, dtype: float64</code></pre><p>同时，如果没有内置定义的处理函数，可以通过<code>apply</code>方法自定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.resample(<span class="hljs-string">&#x27;10D&#x27;</span>).apply(<span class="hljs-keyword">lambda</span> x:x.<span class="hljs-built_in">max</span>()-x.<span class="hljs-built_in">min</span>()).head() <span class="hljs-comment"># 极差</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01    32020-01-11    42020-01-21    42020-01-31    22020-02-10    4Freq: 10D, dtype: int32</code></pre><p>在<code>resample</code>中要特别注意组边界值的处理情况，默认情况下起始值的计算方法是从最小值时间戳对应日期的午夜<code>00:00:00</code>开始增加<code>freq</code>，直到不超过该最小时间戳的最大时间戳，由此对应的时间戳为起始值，然后每次累加<code>freq</code>参数作为分割结点进行分组，区间情况为左闭右开。下面构造一个不均匀的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">idx = pd.date_range(<span class="hljs-string">&#x27;20200101 8:26:35&#x27;</span>, <span class="hljs-string">&#x27;20200101 9:31:58&#x27;</span>, freq=<span class="hljs-string">&#x27;77s&#x27;</span>)<br>data = np.random.randint(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(idx)).cumsum()<br>s = pd.Series(data,index=idx)<br>s.head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01 08:26:35   -12020-01-01 08:27:52   -12020-01-01 08:29:09   -22020-01-01 08:30:26   -32020-01-01 08:31:43   -4Freq: 77S, dtype: int32</code></pre><p>下面对应的第一个组起始值为<code>08:24:00</code>，其是从当天0点增加72个<code>freq=7 min</code>得到的，如果再增加一个<code>freq</code>则超出了序列的最小时间戳<code>08:26:35</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.resample(<span class="hljs-string">&#x27;7min&#x27;</span>).mean().head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01 08:24:00   -1.7500002020-01-01 08:31:00   -2.6000002020-01-01 08:38:00   -2.1666672020-01-01 08:45:00    0.2000002020-01-01 08:52:00    2.833333Freq: 7T, dtype: float64</code></pre><p>有时候，用户希望从序列的最小时间戳开始依次增加<code>freq</code>进行分组，此时可以指定<code>origin</code>参数为<code>start</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.resample(<span class="hljs-string">&#x27;7min&#x27;</span>, origin=<span class="hljs-string">&#x27;start&#x27;</span>).mean().head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01 08:26:35   -2.3333332020-01-01 08:33:35   -2.4000002020-01-01 08:40:35   -1.3333332020-01-01 08:47:35    1.2000002020-01-01 08:54:35    3.166667Freq: 7T, dtype: float64</code></pre><p>在返回值中，要注意索引一般是取组的第一个时间戳，但<code>M, A, Q, BM, BA, BQ, W</code>这七个是取对应区间的最后一个时间戳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = pd.Series(np.random.randint(<span class="hljs-number">2</span>,size=<span class="hljs-number">366</span>), index=pd.date_range(<span class="hljs-string">&#x27;2020-01-01&#x27;</span>, <span class="hljs-string">&#x27;2020-12-31&#x27;</span>))<br>s.resample(<span class="hljs-string">&#x27;M&#x27;</span>).mean().head()<br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-31    0.4516132020-02-29    0.4482762020-03-31    0.5161292020-04-30    0.5666672020-05-31    0.451613Freq: M, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s.resample(<span class="hljs-string">&#x27;MS&#x27;</span>).mean().head() <span class="hljs-comment"># 结果一样，但索引不同</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">2020-01-01    0.4516132020-02-01    0.4482762020-03-01    0.5161292020-04-01    0.5666672020-05-01    0.451613Freq: MS, dtype: float64</code></pre><h2 id="六练习">六、练习</h2><h3 id="ex1太阳辐射数据集">Ex1：太阳辐射数据集</h3><p>现有一份关于太阳辐射的数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/solar.csv&#x27;</span>, usecols=[<span class="hljs-string">&#x27;Data&#x27;</span>,<span class="hljs-string">&#x27;Time&#x27;</span>,<span class="hljs-string">&#x27;Radiation&#x27;</span>,<span class="hljs-string">&#x27;Temperature&#x27;</span>])<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Data</th><th>Time</th><th>Radiation</th><th>Temperature</th></tr></thead><tbody><tr><th>0</th><td>9/29/2016 12:00:00 AM</td><td>23:55:26</td><td>1.21</td><td>48</td></tr><tr><th>1</th><td>9/29/2016 12:00:00 AM</td><td>23:50:23</td><td>1.21</td><td>48</td></tr><tr><th>2</th><td>9/29/2016 12:00:00 AM</td><td>23:45:26</td><td>1.23</td><td>48</td></tr></tbody></table></div><ol type="1"><li>将<code>Datetime, Time</code>合并为一个时间列<code>Datetime</code>，同时把它作为索引后排序。</li><li>每条记录时间的间隔显然并不一致，请解决如下问题：</li></ol><ul><li>找出间隔时间的前三个最大值所对应的三组时间戳。</li><li>是否存在一个大致的范围，使得绝大多数的间隔时间都落在这个区间中？如果存在，请对此范围内的样本间隔秒数画出柱状图，设置<code>bins=50</code>。</li></ul><ol start="3" type="1"><li>求如下指标对应的<code>Series</code>：</li></ol><ul><li>温度与辐射量的6小时滑动相关系数</li><li>以三点、九点、十五点、二十一点为分割，该观测所在时间区间的温度均值序列</li><li>每个观测6小时前的辐射量（一般而言不会恰好取到，此时取最近时间戳对应的辐射量）### Ex2：水果销量数据集</li></ul><p>现有一份2019年每日水果销量记录表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/fruit.csv&#x27;</span>)<br>df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Date</th><th>Fruit</th><th>Sale</th></tr></thead><tbody><tr><th>0</th><td>2019-04-18</td><td>Peach</td><td>15</td></tr><tr><th>1</th><td>2019-12-29</td><td>Peach</td><td>15</td></tr><tr><th>2</th><td>2019-06-05</td><td>Peach</td><td>19</td></tr></tbody></table></div><ol type="1"><li>统计如下指标：</li></ol><ul><li>每月上半月（15号及之前）与下半月葡萄销量的比值</li><li>每月最后一天的生梨销量总和</li><li>每月最后一天工作日的生梨销量总和</li><li>每月最后五天的苹果销量均值</li></ul><ol start="2" type="1"><li>按月计算周一至周日各品种水果的平均记录条数，行索引外层为水果名称，内层为月份，列索引为星期。</li><li>按天计算向前10个工作日窗口的苹果销量均值序列，非工作日的值用上一个工作日的结果填充。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas分组</title>
    <link href="/2023/10/01/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%88%86%E7%BB%84/"/>
    <url>/2023/10/01/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="pandas-分组">Pandas 分组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="一分组模式及其对象">一、分组模式及其对象</h2><h3 id="分组的一般模式">1. 分组的一般模式</h3><p>分组操作在日常生活中使用极其广泛，例如：</p><ul><li>依据性别分组，统计全国人口寿命的平均值</li><li>依据季节分组，对每一个季节的温度进行组内标准化</li><li>依据班级筛选出组内数学分数的平均值超过80分的班级</li></ul><p>从上述的几个例子中不难看出，想要实现分组操作，必须明确三个要素：分组依据、数据来源、操作及其返回结果。同时从充分性的角度来说，如果明确了这三方面，就能确定一个分组操作，从而分组代码的一般模式即：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">df<span class="hljs-selector-class">.groupby</span>(分组依据)<span class="hljs-selector-attr">[数据来源]</span>.使用操作<br></code></pre></td></tr></table></figure> 例如第一个例子中的代码就应该如下： <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">df<span class="hljs-selector-class">.groupby</span>(<span class="hljs-string">&#x27;Gender&#x27;</span>)<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Longevity&#x27;</span>]</span><span class="hljs-selector-class">.mean</span>()<br></code></pre></td></tr></table></figure></p><p>现在返回到学生体测的数据集上，如果想要按照性别统计身高中位数，就可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&#x27;../data/learn_pandas.csv&#x27;</span>)<br>df.groupby(<span class="hljs-string">&#x27;Gender&#x27;</span>)[<span class="hljs-string">&#x27;Height&#x27;</span>].median()<br></code></pre></td></tr></table></figure><pre><code class="hljs">GenderFemale    159.6Male      173.4Name: Height, dtype: float64</code></pre><h3 id="分组依据的本质">2. 分组依据的本质</h3><p>前面提到的若干例子都是以单一维度进行分组的，比如根据性别，如果现在需要根据多个维度进行分组，该如何做？事实上，只需在<code>groupby</code>中传入相应列名构成的列表即可。例如，现希望根据学校和性别进行分组，统计身高的均值就可以如下写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby([<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>])[<span class="hljs-string">&#x27;Height&#x27;</span>].mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">School                         GenderFudan University               Female    158.776923                               Male      174.212500Peking University              Female    158.666667                               Male      172.030000Shanghai Jiao Tong University  Female    159.122500                               Male      176.760000Tsinghua University            Female    159.753333                               Male      171.638889Name: Height, dtype: float64</code></pre><p>目前为止，<code>groupby</code>的分组依据都是直接可以从列中按照名字获取的，那如果希望通过一定的复杂逻辑来分组，例如根据学生体重是否超过总体均值来分组，同样还是计算身高的均值。</p><p>首先应该先写出分组条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">condition = df.Weight &gt; df.Weight.mean()<br></code></pre></td></tr></table></figure><p>然后将其传入<code>groupby</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby(condition)[<span class="hljs-string">&#x27;Height&#x27;</span>].mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">WeightFalse    159.034646True     172.705357Name: Height, dtype: float64</code></pre><h4 id="练一练">【练一练】</h4><p>请根据上下四分位数分割，将体重分为high、normal、low三组，统计身高的均值。#### 【END】从索引可以看出，其实最后产生的结果就是按照条件列表中元素的值（此处是<code>True</code>和<code>False</code>）来分组，下面用随机传入字母序列来验证这一想法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">item = np.random.choice(<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abc&#x27;</span>), df.shape[<span class="hljs-number">0</span>])<br>df.groupby(item)[<span class="hljs-string">&#x27;Height&#x27;</span>].mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">a    163.094828b    163.874603c    162.666129Name: Height, dtype: float64</code></pre><p>此处的索引就是原先item中的元素，如果传入多个序列进入<code>groupby</code>，那么最后分组的依据就是这两个序列对应行的唯一组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby([condition, item])[<span class="hljs-string">&#x27;Height&#x27;</span>].mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">Weight   False   a    159.334146        b    159.257143        c    158.543182True    a    172.164706        b    173.109524        c    172.744444Name: Height, dtype: float64</code></pre><p>由此可以看出，之前传入列名只是一种简便的记号，事实上等价于传入的是一个或多个列，最后分组的依据来自于数据来源组合的unique值，通过<code>drop_duplicates</code>就能知道具体的组类别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df[[<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Gender&#x27;</span>]].drop_duplicates()<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>School</th><th>Gender</th></tr></thead><tbody><tr><th>0</th><td>Shanghai Jiao Tong University</td><td>Female</td></tr><tr><th>1</th><td>Peking University</td><td>Male</td></tr><tr><th>2</th><td>Shanghai Jiao Tong University</td><td>Male</td></tr><tr><th>3</th><td>Fudan University</td><td>Female</td></tr><tr><th>4</th><td>Fudan University</td><td>Male</td></tr><tr><th>5</th><td>Tsinghua University</td><td>Female</td></tr><tr><th>9</th><td>Peking University</td><td>Female</td></tr><tr><th>16</th><td>Tsinghua University</td><td>Male</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.groupby([df[<span class="hljs-string">&#x27;School&#x27;</span>], df[<span class="hljs-string">&#x27;Gender&#x27;</span>]])[<span class="hljs-string">&#x27;Height&#x27;</span>].mean()<br></code></pre></td></tr></table></figure><pre><code class="hljs">School                         GenderFudan University               Female    158.776923                               Male      174.212500Peking University              Female    158.666667                               Male      172.030000Shanghai Jiao Tong University  Female    159.122500                               Male      176.760000Tsinghua University            Female    159.753333                               Male      171.638889Name: Height, dtype: float64</code></pre><h3 id="groupby对象">3. Groupby对象</h3><p>能够注意到，最终具体做分组操作时，所调用的方法都来自于<code>pandas</code>中的<code>groupby</code>对象，这个对象上定义了许多方法，也具有一些方便的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">gb = df.groupby([<span class="hljs-string">&#x27;School&#x27;</span>, <span class="hljs-string">&#x27;Grade&#x27;</span>])<br>gb<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001C1E7AB1408&gt;</code></pre><p>通过<code>ngroups</code>属性，可以得到分组个数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">gb.ngroups<br></code></pre></td></tr></table></figure><pre><code class="hljs">16</code></pre><p>通过<code>groups</code>属性，可以返回从$</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习----学习理论</title>
    <link href="/2023/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0----%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/"/>
    <url>/2023/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0----%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章">第四章</h1><h3 id="第六部分-学习理论learning-theory">第六部分 学习理论（LearningTheory）</h3><h4 id="偏差方差的权衡biasvariance-tradeoff">1偏差/方差的权衡（Bias/variance tradeoff ）</h4><p>在讲线性回归的时候，我们讨论过这样的问题：拟合数据的时候，选择线性的“<spanclass="math inline">\(y = \theta_0+\theta_1x\)</span>”这样的“简单”模型，还是选择多项式的“<spanclass="math inline">\(y= \theta_0 + \theta_1x+...+\theta_5x^5\)</span>”这种“复杂”模型。如下图所示：</p><p><img src="/img/cs229note4f1.png" /></p><p>如最右侧图所示，用一个五次多项式来进行拟合，得到的并不是一个好模型。而且，虽然这个五次多项式对于训练集中的每一个<spanclass="math inline">\(x\)</span>（例如之前文中说的居住面积）都给出了非常好的预测的<span class="math inline">\(y\)</span>值（对应的就是房屋价格），但是我们也不能指望这个模型能够对训练集之外的点给出靠谱的预测。换句话说，用这种高次多项式来对训练集进行学习得到的模型根本不能扩展运用到其他房屋上面去。一个推测模型（hypothesis）的<strong>泛化误差（generalizationerror）</strong>（稍后再给出正式定义），正是那些不属于训练集的样本潜在的预期偏差（expectederror on examples not necessarily in the training set）。</p><p>上面图中最左边的线性拟合和最右边的高次多项式拟合都有非常大的泛化误差。然而，这两个模型各自出的问题是很不一样的。如果<span class="math inline">\(y\)</span> 和 <spanclass="math inline">\(x\)</span>之间的关系不是线性的，那么即便我们有一个非常大规模的训练集，然后用来进行线性拟合，得到的线性模型都还是不能够准确捕捉到数据的结构。我们粗略地将一个模型的<strong>偏差（bias）</strong>定义为预期的泛化误差（expected generalizationerror），即便我们要去拟合的对象是一个非常大的甚至是无限的训练数据集。这样的话，对于上面三幅图中所展示的那个情况来看，最左边的那个线性模型就具有特别大的偏差（bias），可能是对数据欠拟合（也就是说，没有捕捉到数据所体现的结构特征）。</p><p>除了这个偏差（bias）之外，还有另外一个构成泛化误差（generalizationerror）的因素，也就是模型拟合过程的<strong>方差（variance）。</strong>例如在最右边的图中，使用了五次多项式进行了拟合，这样有很大的风险，很可能我们基于数据拟合出来的模型可能碰巧只适合于眼下这个小规模的有限的训练集，而并不能反映<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span>之间更广泛的关系。例如，在实际中，可能我们选择的训练集中的房屋碰巧就是一些比平均价格要稍微贵一些的房屋，也可能有另外的一些比平均值要低一点的房屋，等等。通过对训练集拟合得到的这个“不太靠谱的（spurious）”的模式，我们得到的可能也就是一个有很大泛化误差（largegeneralizationerror）的模型。这样的话，我们就说这个模型的方差很大（largevariance）<span class="math inline">\(^1\)</span>。</p><blockquote><p>1在讲义里面，我们不准备给出对偏差（bias）和方差（variance）给出正式的定义，也就说道上面讨论这样的程度而已。当然了，这两者都有严格的正式定义，例如在线性回归里面，对于这两者的定义，有若干不同的观点，但是哪一个最权威最正确（right）呢？这个还有争议的。</p></blockquote><p>通常情况下，咱们需要在偏差（bias）和方差（variance）之间进行权衡妥协。如果我们的模型过于“简单（simple）”，而且参数非常少，那这样就可能会有很大的偏差（bias），而方差（variance）可能就很小；如果我们的模型过于“复杂（complex）”，有非常多的参数，那就可能反过来又特别大的方差（variance），而偏差（bias）就会小一些。在上面三种不同拟合的样例中，用二次函数来进行拟合得到的效果，明显是胜过一次线性拟合，也强于五次多项式拟合。</p><h4 id="预先准备preliminaries">2 预先准备（Preliminaries）</h4><p>在这一部分的讲义中，我们要开始进入到机器学习的理论（learningtheory）了。本章内容非常有趣，而且有启发性，还能帮助我们培养直觉，能够得到在不同背景下如何最佳应用学习算法的经验规则。此外，我们还会探究一些问题：首先，上文我们刚刚谈论到的偏差（bias）/方差（variance），能不能更正规地总结一下？这个问题还会引出关于模型选择的方法，这些方法可以在对一个训练集进行拟合的时候来帮助确定要用的多项式应该是几阶的。其次，在机器学习的过程中，我们真正关注的也就是泛化误差（generalizationerror），不过绝大部分的学习算法都是将训练集和模型结合的。那么针对训练集的表现好坏程度，为何就能告诉我们泛化误差的信息呢？例如，我们能将训练集的误差和泛化误差联系起来么？第三个，也是最后一点，是否存在某些条件，我们能否在这些条件下证明某些学习算法能够良好工作？</p><p>我们先来给出两个很简单又很有用的引理（lemma）。</p><p>引理1 (联合约束，The union bound)。设 <spanclass="math inline">\(A_1, A_2, ..., A_k\)</span> 是 <spanclass="math inline">\(k\)</span>个不同事件（但不一定互相独立），则有：</p><p><span class="math display">\[P(A_1\cup...\cup A_k)\leq P(A_1)+...+P(A_k)\]</span></p><p>在概率论中，联合约束通常被当做是公理（所以我们就不尝试证明了），实际上也很直观的：<span class="math inline">\(k\)</span> 个事件至少发生一个的概率最多是<span class="math inline">\(k\)</span>个不同的事件各自发生的概率总和。</p><p>引理2 (Hoeffding 不等式) 。设 <spanclass="math inline">\(Z_1,...,Z_m\)</span> 是 <spanclass="math inline">\(m\)</span>个独立的并且共同遵循伯努利分布（Bernoulli(<spanclass="math inline">\(\phi\)</span>)distribution）的随机变量（independent and identically distributed (iid)random variables）。例如：<span class="math inline">\(P(Z_i=1)=\phi\)</span> 而 <span class="math inline">\(P(Z_i =0)= 1 -\phi\)</span>. 设 <spanclass="math inline">\(\hat\phi=(\frac1m)\sum^m_{i=1}Z_i\)</span>是这些随机变量的平均值，然后设任意的 <span class="math inline">\(\gamma\geq 0\)</span> 为某一固定值（fixed），则有：</p><p><span class="math display">\[P(|\phi-\hat\phi|&gt;\gamma)\leq 2\exp (-2\gamma^2m)\]</span></p><p>上面这个引理（在机器学习理论里面也称为 <strong>切尔诺夫约束，Chernoffbound</strong>）表明，如果我们我们从一个伯努利分布的随机变量中选取平均值 <spanclass="math inline">\(\hat\phi\)</span> 来作为对 <spanclass="math inline">\(\phi\)</span> 的估计值，那么只要 <spanclass="math inline">\(m\)</span>足够大，我们偏移真实值很远的概率就比较小。另外一种表述方式是：如果你有一个有偏差的硬币（biasedcoin），抛起来落下人头朝上的概率是 <spanclass="math inline">\(\phi\)</span>，如果你抛了 <spanclass="math inline">\(m\)</span> 次，然后计算人头朝上的比例，若 <spanclass="math inline">\(m\)</span> 非常大，那么这个比例的值，就是一个对<span class="math inline">\(\phi\)</span>的一个概率很高的很好的估计。</p><p>基于上面这两个引理，我们就可以去证明在机器学习理论中一些很深刻和重要的结论了。</p><p>为了简化表述，我们先集中关注一下二分法分类，其中的标签简化为 <spanclass="math inline">\(y \in \{0,1\}\)</span>。然后我们即将讲到的所有内容也都会推广到其它问题中，例如回归问题以及多类别的分类问题等等。</p><p>假设我们有一个给定的训练集 <span class="math inline">\(S =\{(x^{(i)},y^{(i)});i = 1,...,m\}\)</span>，其样本规模为 <spanclass="math inline">\(m\)</span>，集合中的训练样本 <spanclass="math inline">\((x^{(i)},y^{(i)})\)</span> 是服从某概率分布 <spanclass="math inline">\(D\)</span>的独立且同分布的随机变量。设一个假设（hypothesis）为<spanclass="math inline">\(h\)</span>，我们则用如下的方法定义训练误差（也称为学习理论中的<strong>经验风险empirical risk</strong> 或者<strong>经验误差 empiricalerror）</strong>：</p><p><span class="math display">\[\hat\epsilon(h) =\frac1m\sum^m_{i=1}1\{h(x^{(i)})\neq y^{(i)}\}\]</span></p><p>这个值只是假设模型 <span class="math inline">\(h\)</span>分类错误样本占据训练样本总数的分数。如果我们要特定指定对某个训练样本集合<span class="math inline">\(S\)</span> 的经验误差 <spanclass="math inline">\(\hat\epsilon(h)\)</span>，可以写作 <spanclass="math inline">\(\hat\epsilon_S(h)\)</span>。然后我们就可以定义泛化误差（generalizationerror）为：</p><p><span class="math display">\[\epsilon(h) =P_{(x,y)\sim D}(h(x)\neq y)\]</span></p><p>经验误差 <span class="math inline">\(\epsilon(h)\)</span>的这个定义实际上也就相当于，基于分布 <spanclass="math inline">\(D\)</span> 给出的一个新的样本 <spanclass="math inline">\((x, y)\)</span> ，假设模型 <spanclass="math inline">\(h\)</span> 对该样本分类错误的概率。</p><p>要注意，这里我们有一个预先假设，也就是训练集的数据与要用来检验假设用的数据都服从同一个分布<spanclass="math inline">\(D\)</span>（这一假设存在于对泛化误差的定义中）。这个假设通常也被认为是PAC 假设之一<span class="math inline">\(^2\)</span>。</p><blockquote><p>2 PAC 是一个缩写，原型为“probably approximatelycorrect”，这是一个框架和一系列假设的集合，在机器学习理论中的很多结构都是基于这些假设而证明得到的。这个系列假设中<strong>最重要的两个，就是训练集与测试集服从同一分布，以及训练样本的独立性。</strong></p></blockquote><p>考虑线性分类的情况，假设 <span class="math inline">\(h_\theta (x) =1\{\theta^T x \geq 0\}\)</span>。拟合参数 <spanclass="math inline">\(\theta\)</span>的合理方法是什么呢？一个思路就是可以使训练误差（trainingerror）最小化，然后选择取最小值的时候的 <spanclass="math inline">\(\theta\)</span> ：</p><p><span class="math display">\[\hat\theta=arg\min_\theta\hat\epsilon(h_\theta)\]</span></p><p>我们把上面这个过程称之为<strong>经验风险最小化</strong>（empiricalrisk minimization，缩写为ERM），而这种情况下通过学习算法得到的假设结果就是 <spanclass="math inline">\(\hat h = h_{\hat\theta}\)</span> 。我们把 ERM看做为最“基础（basic）”的学习算法，在这一系列的讲义中我们主要关注的就是这种算法。（其他的例如逻辑回归等等算法也可以看作是对ERM 的某种近似（approximations）。）</p><p>在咱们关于机器学习理论的研究中，有一种做法很有用处，就是把具体的参数化（specificparameterization）抽象出去，并且也把是否使用线性分选器（linearclassifier）之类的问题也抽象出去。我们把通过学习算法所使用的<strong>假设类（hypothesisclass）<span class="math inline">\(H\)</span></strong>定义为所有分类器的集合（set of allclassifiers）。对于线性分类问题来说，<span class="math inline">\(H =\{h_\theta : h_\theta(x) = 1\{\theta^T x \geq 0\}, \theta \inR^{n+1}\}\)</span>，是一个对 <spanclass="math inline">\(X\)</span>（输入特征）进行分类的所有分类器的集合，其中所有分类边界为线性。更广泛来说，假设我们研究神经网络（neuralnetworks），那么可以设 <span class="math inline">\(H\)</span>为能表示某些神经网络结构的所有分类器的集合。</p><p>现在就可以把 经验风险最小化（ERM）看作是对函数类 <spanclass="math inline">\(H\)</span>的最小化，其中由学习算法来选择假设（hypothesis）：</p><p><span class="math display">\[\hat h=arg\min_{h\in H}\hat\epsilon(h)\]</span></p><h4 id="有限个假设finite-h的情况">3 有限个假设（finite H）的情况</h4><p>我们首先来考虑一下假设类有限情况下的学习问题，其中假设类 <spanclass="math inline">\(H = \{h_1, ..., h_k\}\)</span>，由 <spanclass="math inline">\(k\)</span> 个不同假设组成。因此，<spanclass="math inline">\(H\)</span> 实际上就是由 <spanclass="math inline">\(k\)</span> 个从输入特征 <spanclass="math inline">\(X\)</span> 映射到 <span class="math inline">\(\{0,1\}\)</span> 的函数组成的集合，而经验风险最小化（ERM）就是从这样的 <spanclass="math inline">\(k\)</span> 个函数中选择训练误差最小（smallesttraining error）的作为 <span class="math inline">\(\hat h\)</span>。</p><p>我们希望能够确保 <span class="math inline">\(\hat{h}\)</span>的泛化误差。这需要两个步骤：首先要表明 <spanclass="math inline">\(\hat\epsilon(h)\)</span> 是对所有 <spanclass="math inline">\(h\)</span> 的 <spanclass="math inline">\(\epsilon(h)\)</span>的一个可靠估计。其次就需要表明这个 <spanclass="math inline">\(\hat\epsilon(h)\)</span> 位于 <spanclass="math inline">\(\hat{h}\)</span> 泛化误差的上界。</p><p>任选一个固定的 <span class="math inline">\(h_i \inH\)</span>。假如有一个伯努利随机变量（Bernoulli random variable） <spanclass="math inline">\(Z\)</span>，其分布入下面式中定义。 然后我们从<span class="math inline">\(D\)</span> 中取样 <spanclass="math inline">\((x, y)\)</span>，并设 <spanclass="math inline">\(Z=1\{h_i(x)\neqy\}\)</span>。也就是说，我们会选择一个样本，然后令 <spanclass="math inline">\(Z\)</span> 指示 <spanclass="math inline">\(h_i\)</span>是否对该样本进行了错误分类。类似地，我们还定义了一个 <spanclass="math inline">\(Z_j=1\{h_i(x^{(j)})\neqy^{(j)}\}\)</span>。由于我们的训练样本都是从 <spanclass="math inline">\(D\)</span>中取来的独立随机变量（iid），所以在此基础上构建的 <spanclass="math inline">\(Z\)</span> 和 <spanclass="math inline">\(Z_j\)</span> 也都服从相同的分布。</p><p>这样就能找到针对随机选取的训练样本进行错误分类的概率 — 也就是 <spanclass="math inline">\(\epsilon(h)\)</span> — 正好就是 <spanclass="math inline">\(Z\)</span> (以及 <spanclass="math inline">\(Z_j\)</span>) 的期望值（expectedvalue）。然后，就可以把训练误差写成下面这种形式：</p><p><span class="math display">\[\hat\epsilon(h_i)=\frac 1m\sum_{j=1}^mZ_j\]</span></p><p>因此，<span class="math inline">\(\hat\epsilon(h_i)\)</span> 就正好是<span class="math inline">\(m\)</span> 个随机变量 <spanclass="math inline">\(Z_j\)</span> 的平均值，而这个 <spanclass="math inline">\(Z_j\)</span>是服从伯努利分布的独立随机变量（iid），其均值就是 <spanclass="math inline">\(\epsilon(h_i)\)</span>。接下来，就可以使用Hoeffding 不等式，得到下面的式子：</p><p><span class="math display">\[P(|\epsilon(h_i)-\hat\epsilon(h_i)|&gt;\gamma)\leq 2\exp (-2\gamma^2m)\]</span></p><p>这就表明，对于我们给定的某个固定的 <spanclass="math inline">\(h_i\)</span>，假如训练样本的规模 <spanclass="math inline">\(m\)</span>规模很大的时候，训练误差有很接近泛化误差（generalizationerror）的概率是很高的。然而我们不仅仅满足于针对某一个特定的 <spanclass="math inline">\(h_i\)</span> 的时候能保证 <spanclass="math inline">\(\epsilon(h_i)\)</span> 接近 <spanclass="math inline">\(\hat\epsilon(h_i)\)</span>且接近的概率很高。我们还要证明同时针对所有的 <spanclass="math inline">\(h \in H\)</span> 这个结论都成立。为了证明这个结论，我们设 <span class="math inline">\(A_i\)</span>来表示事件 <span class="math inline">\(|\epsilon(h_i) -\hat\epsilon(h_i)| &gt; \gamma\)</span>。我们已经证明了，对于任意给定的<span class="math inline">\(A_i\)</span>，都有 <spanclass="math inline">\(P(A_i) \le 2\exp (-2\gamma^2m)\)</span>成立。接下来，使用联合约束（union bound），就可以得出下面的关系：</p><p><span class="math display">\[\begin{aligned}P(\exists h\in H.|\epsilon(h_i)-\hat\epsilon(h_i)|&gt;\gamma)&amp; =P(A_1\cup...\cup A_k) \\                                                   &amp; \le\sum_{i=1}^k P(A_i) \\                                                   &amp; \le\sum_{i=1}^k 2\exp (-2\gamma^2m) \\                                                   &amp; = 2k\exp(-2\gamma^2m)\end{aligned}\]</span></p><p>如果等式两边都用 1 来减去原始值（subtract both sides from1），则不等关系改变为：</p><p><span class="math display">\[\begin{aligned}P(\neg\exists h\in H.|\epsilon(h_i)-\hat\epsilon(h_i)|&gt;\gamma)&amp;= P(\forall h\in H.|\epsilon(h_i)-\hat\epsilon(h_i)|\le\gamma) \\&amp; \ge 1-2k\exp (-2\gamma^2m)\end{aligned}\]</span></p><p>（<span class="math inline">\(“\neg”\)</span> 这个符号的意思是“非”。）如上所示，至少有 <span class="math inline">\(1-2k exp(-2\gamma^2m)\)</span> 的概率，我们能确保对于所有的 <span class="math inline">\(h\in H\)</span>，<span class="math inline">\(\epsilon(h)\)</span> 在<span class="math inline">\(\hat\epsilon(h)\)</span> 附近的 <spanclass="math inline">\(\gamma\)</span>范围内。这种结果就叫做一致收敛结果（uniform convergenceresult），因为这是一个针对所有的 <span class="math inline">\(h \inH\)</span> 都同时成立的约束（与之相反的是只针对某一个 <spanclass="math inline">\(h\)</span> 才成立的情况）。</p><p>在上面的讨论中，我们涉及到的是针对某些 <spanclass="math inline">\(m\)</span> 和 <spanclass="math inline">\(\gamma\)</span>的特定值，给定一个概率约束：对于某些 <span class="math inline">\(h \inH\)</span>, 都有 <span class="math inline">\(|\epsilon(h) -\hat\epsilon(h)| \geq \gamma\)</span>。这里我们感兴趣的变量（quantitiesof interest）有三个：<span class="math inline">\(m\)</span>, <spanclass="math inline">\(\gamma\)</span>, 以及误差的概率（probability oferror）；我们可以将其中的任意一个用另外两个来进行约束（bound either onein terms of the other two）。</p><p>例如，我们可以提出下面这样的一个问题：给定一个 <spanclass="math inline">\(\gamma\)</span> 以及某个 <spanclass="math inline">\(\delta \geq0\)</span>，那么如果要保证训练误差处于泛化误差附近 <spanclass="math inline">\(\gamma\)</span> 的范围内的概率最小为 <spanclass="math inline">\(1 – \delta\)</span>，那么 <spanclass="math inline">\(m\)</span> 应该要多大呢？可以设 <spanclass="math inline">\(\delta = 2k exp(-2\gamma^2 m)\)</span> 然后解出来<spanclass="math inline">\(m\)</span>（自己给自己证明一下这样是对的吧！），然后我们就发现，如果有：</p><p><span class="math display">\[m\ge \frac{1}{2\gamma^2}log\frac{2k}{\delta}\]</span></p><p>并且概率最小为 <spanclass="math inline">\(1-\delta\)</span>，就能保证对于所有的 <spanclass="math inline">\(h \in H\)</span> 都有 <spanclass="math inline">\(|\epsilon(h) - \hat\epsilon(h)| ≤ \gamma\)</span>。（反过来，这也表明，对于<strong>某些</strong> <spanclass="math inline">\(h \in H\)</span>， <spanclass="math inline">\(|\epsilon(h) - \hat\epsilon(h)| \geq\gamma\)</span> 的概率最大为 <spanclass="math inline">\(\delta\)</span>。）这种联合约束也说明了需要多少数量的训练样本才能对结果有所保证。是某些特定的方法或者算法所需要训练集的规模<span class="math inline">\(m\)</span> 来实现一定程度的性能（achieve acertain level of performance），这样的训练集规模 <spanclass="math inline">\(m\)</span>也叫做此类算法的<strong>样本复杂度</strong> （the algorithm’s samplecomplexity）。</p><p>上面这个约束的关键特性在于要保证结果，所需的训练样本数量只有 <spanclass="math inline">\(k\)</span> 的对数（only logarithmic in k），<spanclass="math inline">\(k\)</span> 即假设集合 <spanclass="math inline">\(H\)</span>中的假设个数。这以特性稍后会很重要。</p><p>同理，我们也可以将 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(\delta\)</span> 设置为固定值，然后通过上面的等式对<span class="math inline">\(\gamma\)</span> 进行求解，然后表明对于所有的<span class="math inline">\(h \in H\)</span> ，都有概率为 <spanclass="math inline">\(1–\delta\)</span>（这里还是要你自己去证明了，不过你相信这个是对的就好了。）。</p><p><span class="math display">\[|\hat\epsilon(h)-\epsilon(h)|\le \sqrt{\frac{1}{2m}log\frac{2k}{\delta}}\]</span></p><p>现在，我们假设这个联合收敛成立（uniform convergenceholds），也就是说，对于所有的 <span class="math inline">\(h \inH\)</span>，都有 <span class="math inline">\(|ε(h)-\hat\epsilon(h)| ≤\gamma\)</span>。我们的学习算法选择了 <spanclass="math inline">\(\hat{h} = arg\min_{h\in H}\hat\epsilon(h)\)</span>，关于这种算法的泛化，我们能给出什么相关的证明呢？</p><p>将 <span class="math inline">\(h^∗ = arg \min_{h\in H}\epsilon(h)\)</span> 定义为 <span class="math inline">\(H\)</span>中最佳可能假设（best possible hypothesis）。这里要注意此处的 <spanclass="math inline">\(h^∗\)</span> 是我们使用假设集合 <spanclass="math inline">\(H\)</span>所能找出的最佳假设，所以很自然地，我们就能理解可以用这个 <spanclass="math inline">\(h^∗\)</span> 来进行性能对比了。则有：</p><p><span class="math display">\[\begin{aligned}\epsilon(\hat h) &amp; \le \hat\epsilon(\hat h)+\gamma \\                 &amp; \le \hat\epsilon(h^*)+\gamma \\                 &amp; \le \epsilon(h^*)+2\gamma\end{aligned}\]</span></p><p>上面的第一行用到了定理 <span class="math inline">\(| \epsilon(\hat h)- \hat\epsilon (\hat h) | \le\gamma\)</span>（可以通过上面的联合收敛假设来推出）。第二行用到的定理是<span class="math inline">\(\hat{h}\)</span> 是选来用于得到最小 <spanclass="math inline">\(\hat\epsilon(h)\)</span> ，然后因此对于所有的<span class="math inline">\(h\)</span> 都有 <spanclass="math inline">\(\hat\epsilon(\hat{h}) \leq\hat\epsilon(h)\)</span>，也就自然能推出 <spanclass="math inline">\(\hat\epsilon(\hat{h}) \le\hat\epsilon(h^∗)\)</span>。第三行再次用到了上面的联合收敛假设，此假设表明 <spanclass="math inline">\(\hat\epsilon(h^∗) \le \epsilon(h^∗) +\gamma\)</span>。所以，我们就能得出下面这样的结论：如果联合收敛成立，那么 <spanclass="math inline">\(\hat h\)</span> 的泛化误差最多也就与 <spanclass="math inline">\(H\)</span> 中的最佳可能假设相差 <spanclass="math inline">\(2\gamma\)</span>。</p><p>好了，咱们接下来就把上面这一大堆整理成一条定理（theorem）。</p><p><strong>定理:</strong> 设 <span class="math inline">\(|H| =k\)</span><code>译者注：即 H 集合中元素个数为 k</code>，然后设 <spanclass="math inline">\(m\)</span> 和 <spanclass="math inline">\(\delta\)</span> 为任意的固定值。然后概率至少为<span class="math inline">\(1 - \delta\)</span>，则有：</p><p><span class="math display">\[\epsilon(\hat h)\le (\min_{h\inH}\epsilon(h))+2\sqrt{\frac{1}{2m}log\frac{2k}{\delta}}\]</span></p><p>上面这个的证明，可以通过令 <spanclass="math inline">\(\gamma\)</span> 等于平方根<spanclass="math inline">\(\sqrt{\cdot}\)</span>的形式，然后利用我们之前得到的概率至少为<span class="math inline">\(1 – \delta\)</span>的情况下联合收敛成立，接下来利用联合收敛能表明 <spanclass="math inline">\(\epsilon(h)\)</span> 最多比 <spanclass="math inline">\(\epsilon(h^∗) = \min_{h\in H} \epsilon(h)\)</span>多 <spanclass="math inline">\(2\gamma\)</span>（这个前面我们已经证明过了）。</p><p>这也对我们之前提到过的在模型选择的过程中在偏差（bias）/方差（variance）之间的权衡给出了定量方式。例如，加入我们有某个假设类<spanclass="math inline">\(H\)</span>，然后考虑切换成某个更大规模的假设类<span class="math inline">\(H&#39; \supseteqH\)</span>。如果我们切换到了 <span class="math inline">\(H&#39;\)</span>，那么第一次的 <span class="math inline">\(\min_h \epsilon(h)\)</span>只可能降低（因为我们这次在一个更大规模的函数集合里面来选取最小值了）。因此，使用一个更大规模的假设类来进行学习，我们的学习算法的“偏差（bias）”只会降低。然而，如果<span class="math inline">\(k\)</span>值增大了，那么第二项的那个二倍平方根项<spanclass="math inline">\(2\sqrt{\cdot}\)</span>也会增大。这一项的增大就会导致我们使用一个更大规模的假设的时候，“方差（variance）”就会增大。</p><p>通过保持 <span class="math inline">\(\gamma\)</span> 和 <spanclass="math inline">\(\delta\)</span> 为固定值，然后像上面一样求解 <spanclass="math inline">\(m\)</span>，我们还能够得到下面的样本复杂度约束：</p><p><strong>推论（Corollary）：</strong> 设 <spanclass="math inline">\(|H| = k\)</span> ，然后令 <spanclass="math inline">\(\delta,\gamma\)</span>为任意的固定值。对于满足概率最少为 <span class="math inline">\(1 -\delta\)</span> 的 <span class="math inline">\(\epsilon(\hat{h}) \lemin_{h\in H} \epsilon(h) + 2\gamma\)</span> ，下面等式关系成立：</p><p><span class="math display">\[\begin{aligned}m &amp;\ge \frac{1}{2\gamma^2}log\frac{2k}{\delta} \\  &amp; = O(\frac{1}{\gamma^2}log\frac{k}{\delta})    \end{aligned}\]</span></p><h4 id="无限个假设infinite-h的情况">4 无限个假设（infiniteH）的情况</h4><p>我们已经针对有限个假设类的情况证明了一些有用的定理。然而有很多的假设类都包含有无限个函数，其中包括用实数参数化的类（比如线性分类问题）。那针对这种无限个假设的情况，我们能证明出类似的结论么？</p><p>我们先从一些不太“准确”论证的内容开始（not the “right”argument）。当然也有更好的更通用的论证，但先从这种不太“准确”的内容除法，将有助于锻炼我们在此领域内的直觉（intuitionsabout the domain）。</p><p>若我们有一个假设集合 <span class="math inline">\(H\)</span>，使用<span class="math inline">\(d\)</span> 个实数来进行参数化（parameterizedby d real numbers）。由于我们使用计算机表述实数，而 IEEE的双精度浮点数（ C 语言里面的 double 类型）使用了 64 bit来表示一个浮点数（floating-pointnumber,），这就意味着如果我们在学习算法中使用双精度浮点数（double-precision floating point），那我们的算法就由 64 d 个 bit来进行参数化（parameterized by 64dbits）。这样我们的这个假设类实际上包含的不同假设的个数最多为 <spanclass="math inline">\(k = 2^{64d}\)</span>。结合上一节的最后一段那个推论（Corollary），我们就能发现，要保证 <spanclass="math inline">\(\epsilon(\hat{h}) \leq \epsilon(h^∗) +2\gamma\)</span> ，同时还要保证概率至少为 <span class="math inline">\(1- \delta\)</span> ，则需要训练样本规模 <spanclass="math inline">\(m\)</span> 满足<span class="math inline">\(m \geO(\frac{1}{\gamma^2}log\frac{2^{64d}}{\delta})=O(\frac{d}{\gamma^2}log\frac{1}{\delta})=O_{\gamma,\delta}(d)\)</span>（这里的<span class="math inline">\(\gamma\)</span>，<spanclass="math inline">\(\delta\)</span>下标表示最后一个大<spanclass="math inline">\(O\)</span>可能是一个依赖于<spanclass="math inline">\(\gamma\)</span>和<spanclass="math inline">\(\delta\)</span>的隐藏常数。）因此，所需的训练样本规模在模型参数中最多也就是线性的（thenumber of training examples needed is at most linear in the parametersof the model）。</p><p>The fact that we relied on 64-bit floating point makes this argumentnot entirely satisfying, but the conclusion is nonetheless roughlycorrect: If what we’re going to do is try to minimize training error,then in order to learn “well” using a hypothesis class that has dparameters, generally we’re going to need on the order of a linearnumber of training examples in d.</p><p>上述论证依赖于假定参数是 64位浮点数（但是实际上实数参数不一定如此实现），因此还不能完全令人满意，但这个结论大致上是正确的：如果我们试图使训练误差（trainingerror）最小化，那么为了使用具有 <span class="math inline">\(d\)</span>个参数的假设类（hypothesis class）的学习效果“较好（well）”，通常就需要<span class="math inline">\(d\)</span> 的线性规模个训练样本。</p><p>（在这里要注意的是，对于使用经验风险最小化（empirical riskminimization，ERM）的学习算法，上面这些结论已经被证明适用。因此，样本复杂度（samplecomplexity）对 <span class="math inline">\(d\)</span>的线性依赖性通常适用于大多数分类识别学习算法（discriminative learningalgorithms），但训练误差或者训练误差近似值的最小化，就未必适用于分类识别了。对很多的非ERM 学习算法提供可靠的理论论证，仍然是目前很活跃的一个研究领域。）</p><p>前面的论证还有另外一部分让人不太满意，就是依赖于对 <spanclass="math inline">\(H\)</span>的参数化（parameterization）。根据直觉来看，这个参数化似乎应该不会有太大影响：我们已经把线性分类器（linearclassifiers）写成了 <span class="math inline">\(h_\theta(x) =1\{\theta_0 + \theta_1x_1 + ···\theta_n x_n \geq 0\}\)</span>的形式，其中有 <span class="math inline">\(n+1\)</span> 个参数 <spanclass="math inline">\(\theta_0,...,\theta_n\)</span> 。但也可以写成<span class="math inline">\(h_{u,v}(x) = 1\{(u^2_0 - v_0^2) + (u^2_1 -v_1^2)x1 + ··· (u^2_n - v_n^2)x_n \geq 0\}\)</span> 的形式，这样就有<span class="math inline">\(2n+2\)</span> 个参数 <spanclass="math inline">\(u_i, v_i\)</span>了。然而这两种形式都定义了同样的一个 <spanclass="math inline">\(H：\)</span> 一个 <spanclass="math inline">\(n\)</span> 维的线性分类器集合。</p><p>要推导出更让人满意的论证结果，我们需要再额外定义一些概念。</p><p>给定一个点的集合 <span class="math inline">\(S = \{x^{(i)}, ...,x^{(d)}\}\)</span>（与训练样本集合无关），其中 <spanclass="math inline">\(x(i) \in X\)</span>，如果 <spanclass="math inline">\(H\)</span> 能够对 集合 <spanclass="math inline">\(S\)</span> 实现任意的标签化（can realize anylabeling on S），则称 <strong><span class="math inline">\(H\)</span>打散（shatter）</strong> 了 <spanclass="math inline">\(S\)</span>。例如，对于任意的标签集合 （set oflabels）<span class="math inline">\(\{y^{(1)}, ...,y^{(d)}\}\)</span>，都有 一些<span class="math inline">\(h\in H\)</span>，对于所有的<span class="math inline">\(i = 1, ...d\)</span>，式子<spanclass="math inline">\(h(x^{(i)}) =y^{(i)}\)</span>都成立。（译者注：关于 shattered set 的定义可以参考：<ahref="https://en.wikipedia.org/wiki/Shattered_set"><em>https://en.wikipedia.org/wiki/Shattered_set</em></a>更多关于 VC 维 的内容也可以参考：<ahref="https://www.zhihu.com/question/38607822"><em>https://www.zhihu.com/question/38607822</em></a>）</p><p>给定一个假设类 <span class="math inline">\(H\)</span>，我们定义其<strong>VC维度（Vapnik-Chervonenkis dimension），</strong> 写作 <spanclass="math inline">\(VC(H)\)</span>，这个值也就是能被 <spanclass="math inline">\(H\)</span> 打散（shatter）的最大的集合规模。（如果<span class="math inline">\(H\)</span> 能打散任意大的集合（arbitrarilylarge sets），那么 <span class="math inline">\(VC(H) =∞\)</span>。）</p><p>例如，若一个集合由下图所示的三个点组成：</p><p><img src="/img/cs229note4f2.png" /></p><p>那么二维线性分类器 <span class="math inline">\((h(x) = 1\{\theta_0+\theta_1 x_1 + \theta_2 x_2 \geq 0\})\)</span> 的集合 <spanclass="math inline">\(H\)</span>能否将上图所示的这个集合打散呢？答案是能。具体来看则如下图所示，以下八种分类情况中的任意一个，我们都能找到一种用能够实现“零训练误差（zero training error）” 的线性分类器（linearclassifier）：</p><p><img src="/img/cs229note4f3.png" /></p><p>此外，这也有可能表明，这个假设类 <spanclass="math inline">\(H\)</span> 不能打散（shatter）4个点构成的集合。因此，<span class="math inline">\(H\)</span>可以打散（shatter）的最大集合规模为 3，也就是说 <spanclass="math inline">\(VC（H）= 3\)</span>。</p><p>这里要注意，<span class="math inline">\(H\)</span> 的 <spanclass="math inline">\(VC\)</span> 维 为3，即便有某些 3 个点的集合不能被<span class="math inline">\(H\)</span>打散。例如如果三个点都在一条直线上（如下图左侧的图所示），那就没办法能够用线性分类器来对这三个点的类别进行划分了（如下图右侧所示）。</p><p><img src="/img/cs229note4f4.png" /></p><p>换个方式来说，在 <span class="math inline">\(VC\)</span> 维的定义之下，要保证 <span class="math inline">\(VC(H)\)</span> 至少为<span class="math inline">\(d\)</span>，只需要证明至少有一个规模为 <spanclass="math inline">\(d\)</span> 的集合能够被 <spanclass="math inline">\(H\)</span> 打散 就可以了。</p><p>这样就能够给出下面的定理（theorem）了，该定理来自Vapnik。（有不少人认为这是所有学习理论中最重要的一个定理。）</p><p>Theorem. Let H be given, and let d = VC(H). Then with probability atleast 1-δ, we have that for all h∈H,</p><p>定理：给定 <span class="math inline">\(H\)</span>，设 <spanclass="math inline">\(d = VC(H)\)</span>。然后对于所有的 <spanclass="math inline">\(h\in H\)</span>，都有至少为 <spanclass="math inline">\(1-\delta\)</span> 的概率使下面的关系成立：</p><p><span class="math display">\[|\epsilon(h)-\hat\epsilon(h)|\le O(\sqrt{\frac{d}{m}log\frac{d}{m}+\frac1mlog\frac 1\delta})\]</span></p><p>此外，有至少为 <span class="math inline">\(1-\delta\)</span>的概率：</p><p><span class="math display">\[\epsilon(\hat h)\le\epsilon(h^*)+O(\sqrt{\frac{d}{m}log\frac{d}{m}+\frac 1mlog\frac1\delta})\]</span></p><p>换句话说，如果一个假设类有有限的 <spanclass="math inline">\(VC\)</span> 维，那么只要训练样本规模 <spanclass="math inline">\(m\)</span> 增大，就能够保证联合收敛成立（uniformconvergence occurs）。和之前一样，这就能够让我们以 <spanclass="math inline">\(\epsilon(h)\)</span> 的形式来给 <spanclass="math inline">\(\epsilon(h^∗)\)</span>建立一个约束（bound）。此外还有下面的推论（corollary）：</p><p>Corollary. For <span class="math inline">\(|ε(h) - \hat\epsilon(h)| ≤\gamma\)</span> to hold for all h ∈ H (and hence <spanclass="math inline">\(\epsilon(\hat{h}) ≤ \epsilon(h^∗) +2\gamma\)</span>) with probability at least 1 - δ, it suffices that<span class="math inline">\(m = O_{\gamma,\delta}(d)\)</span>.</p><p><strong>推论（Corollary）：</strong> 对于所有的 <spanclass="math inline">\(h \in H\)</span> 成立的 <spanclass="math inline">\(|\epsilon(h) - \epsilon(\hat h)| \le\gamma\)</span> （因此也有 <span class="math inline">\(\epsilon(\hat h)≤ \epsilon(h^∗) + 2\gamma\)</span>），则有至少为 <spanclass="math inline">\(1 – \delta\)</span> 的概率，满足 <spanclass="math inline">\(m = O_{\gamma,\delta}(d)\)</span>。</p><p>In other words, the number of training examples needed to learn“well” using H is linear in the VC dimension of H. It turns out that,for “most” hypothesis classes, the VC dimension (assuming a “reasonable”parameterization) is also roughly linear in the number of parameters.Putting these together, we conclude that (for an algorithm that tries tominimize training error) the number of training examples needed isusually roughly linear in the number of parameters of H.</p><p>换个方式来说，要保证使用 假设集合 <spanclass="math inline">\(H\)</span> 的机器学习的算法的学习效果“良好（well）”，那么训练集样本规模 <spanclass="math inline">\(m\)</span> 需要与 <spanclass="math inline">\(H\)</span> 的 <spanclass="math inline">\(VC\)</span> 维度 线性相关（linear in the VCdimension ofH）。这也表明，对于“绝大多数（most）”假设类来说，（假设是“合理（reasonable）”参数化的）<spanclass="math inline">\(VC\)</span>维度也大概会和参数的个数线性相关。把这些综合到一起，我们就能得出这样的一个结论：对于一个试图将训练误差最小化的学习算法来说：训练样本个数通常都大概与假设类 <span class="math inline">\(H\)</span> 的参数个数线性相关。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习----支持向量机</title>
    <link href="/2023/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0----%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2023/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0----%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章">第三章</h1><h3 id="第五部分-支持向量机support-vector-machines">第五部分支持向量机(Support Vector Machines)</h3><p>本章的讲义主要讲述的是 支持向量机（Support Vector Machine ，缩写为SVM） 学习算法。SVM算得上是现有的最好的现成的(“off-the-shelf”)监督学习算法之一，很多人实际上认为这里没有“之一”这两个字的必要，认为SVM 就是最好的现成的监督学习算法。讲这个 SVM的来龙去脉之前，我们需要先讲一些关于边界的内容，以及对数据进行分割成大的区块（gap）的思路。接下来，我们要讲一下最优边界分类器(optimalmargin classifier,)，其中还会引入一些关于拉格朗日对偶(Lagrangeduality)的内容。然后我们还会接触到核(Kernels)，这提供了一种在非常高的维度(例如无穷维度)中进行SVM 学习的高效率方法，最终本章结尾部分会讲 SMO 算法，也就是 SVM算法的一个有效实现方法。</p><h4 id="边界margins直觉intuition">1 边界(Margins)：直觉(Intuition)</h4><p>咱们这回讲 SVM学习算法，从边界(margins)开始说起。这一节我们会给出关于边界的一些直观展示(intuitions)，以及对于我们做出的预测的信心(confidence)；在本章的第三节中，会对这些概念进行更正式化的表述。</p><p>考虑逻辑回归，其中的概率分布<span class="math inline">\(p(y =1|x;\theta)\)</span> 是基于 <span class="math inline">\(h_\theta(x) =g(\theta^Tx)\)</span> 而建立的模型。当且仅当 <spanclass="math inline">\(h_\theta(x) \geq 0.5\)</span> ，也就是 <spanclass="math inline">\(\theta^Tx \geq 0\)</span>的时候，我们才会预测出“<spanclass="math inline">\(1\)</span>”。假如有一个正向(Positive)的训练样本(positivetra_ining example)(<span class="math inline">\(y =1\)</span>)。那么<span class="math inline">\(\theta^Tx\)</span>越大，<span class="math inline">\(h_\theta (x) = p(y = 1|x; w,b)\)</span> 也就越大，我们对预测 Label 为 <spanclass="math inline">\(1\)</span> 的“信心(confidence)”也就越强。所以如果<span class="math inline">\(y = 1\)</span> 且 <spanclass="math inline">\(\theta^T x \gg 0\)</span>（远大于 <spanclass="math inline">\(0\)</span>），那么我们就对这时候进行的预测非常有信心，当然这只是一种很不正式的粗略认识。与之类似，在逻辑回归中，如果有<span class="math inline">\(y = 0\)</span> 且 <spanclass="math inline">\(\theta^T x \ll 0\)</span>(远小于0)，我们也对这时候给出的预测很有信心。所以还是以一种非常不正式的方式来说，对于一个给定的训练集，如果我们能找到一个<span class="math inline">\(\theta\)</span>，满足当 <spanclass="math inline">\(y^{(i)} = 1\)</span> 的时候总有 <spanclass="math inline">\(\theta^T x^{(i)} \gg 0\)</span>，而 <spanclass="math inline">\(y^{(i)} = 0\)</span> 的时候则 <spanclass="math inline">\(\theta^T x^{(i)} \ll0\)</span>，我们就说这个对训练数据的拟合很好，因为这就能对所有训练样本给出可靠（甚至正确）的分类。似乎这样就是咱们要实现的目标了，稍后我们就要使用<strong>函数边界记号(notionof functional margins)</strong> 来用正规的语言来表达该思路。</p><p>还有另外一种的直观表示，例如下面这个图当中，画叉的点表示的是正向训练样本，而小圆圈的点表示的是负向训练样本，图中还画出了<strong>分类边界(decisionboundary)，</strong> 这条线也就是通过等式 <spanclass="math inline">\(\theta^T x = 0\)</span>来确定的，也叫做<strong>分类超平面(separating hyperplane)。</strong>图中还标出了三个点 <span class="math inline">\(A，B 和 C\)</span>。</p><p><img src="/img/cs229note3f1.png" /></p><p>可以发现 <span class="math inline">\(A\)</span>点距离分界线很远。如果我们对 <span class="math inline">\(A\)</span> 点的<span class="math inline">\(y\)</span>值进行预测，估计我们会很有信心地认为在那个位置的 <spanclass="math inline">\(y = 1\)</span>。与之相反的是 <spanclass="math inline">\(C\)</span>，这个点距离边界线很近，而且虽然这个<span class="math inline">\(C\)</span> 点也在预测值 <spanclass="math inline">\(y = 1\)</span>的一侧，但看上去距离边界线的距离实在是很近的，所以也很可能会让我们对这个点的预测为<span class="math inline">\(y = 0\)</span>。因此，我们对 <spanclass="math inline">\(A\)</span> 点的预测要比对 <spanclass="math inline">\(C\)</span> 点的预测更有把握得多。<spanclass="math inline">\(B\)</span>点正好在上面两种极端情况之间，更广泛地说，如果一个点距离<strong>分类超平面(separatinghyperplane)</strong>比较远，我们就可以对给出的预测很有信心。那么给定一个训练集，如果我们能够找到一个分类边界，利用这个边界我们可以对所有的训练样本给出正确并且有信心（也就是数据点距离分类边界要都很远）的预测，那这就是我们想要达到的状态了。当然上面这种说法还是很不正规，后面我们会使用<strong>几何边界记号(notionof geometric margins)</strong> 来更正规地来表达。</p><h4 id="记号notation">2 记号(Notation)</h4><p>在讨论 SVMs的时候，出于简化的目的，我们先要引入一个新的记号，用来表示分类。假设我们要针对一个二值化分类的问题建立一个线性分类器，其中用来分类的标签(label)为<span class="math inline">\(y\)</span>，分类特征(feature)为 <spanclass="math inline">\(x\)</span>。从此以后我们就用 $y <br /></p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习----生成模型</title>
    <link href="/2023/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0----%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0----%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章">第二章</h1><h3 id="第四部分-生成学习算法generative-learning-algorithms">第四部分生成学习算法(Generative Learning algorithms)</h3><p>目前为止，我们讲过的学习算法的模型都是<span class="math inline">\(p(y|x;\theta)\)</span>，也就是给定 <span class="math inline">\(x\)</span>下 <span class="math inline">\(y\)</span> 的条件分布，以 <spanclass="math inline">\(\theta\)</span> 为参数。例如，逻辑回归中就是以<span class="math inline">\(h_\theta(x) = g(\theta^T x)\)</span> 作为<span class="math inline">\(p (y|x;\theta)\)</span> 的模型，这里的 <spanclass="math inline">\(g\)</span> 是一个 <spanclass="math inline">\(S\)</span>型函数（sigmoidfunction）。接下来，咱们要讲一下一种不同类型的学习算法。</p><p>设想有这样一种分类问题，我们要学习基于一个动物的某个特征来辨别它是大象<spanclass="math inline">\((y=1)\)</span>还是小狗<spanclass="math inline">\((y=0)\)</span>。给定一个训练集，用逻辑回归或者基础版的<strong>感知器算法（perceptronalgorithm）</strong>这样的一个算法能找到一条直线，作为区分开大象和小狗的边界。接下来，要辨别一个新的动物是大象还是小狗，程序就要检查这个新动物的值落到了划分出来的哪个区域中，然后根据所落到的区域来给出预测。</p><p>还有另外一种方法。首先，观察大象，然后我们针对大象的样子来进行建模。然后，再观察小狗，针对小狗的样子另外建立一个模型。最后要判断一种新动物归属哪一类，我们可以把新动物分别用大象和小狗的模型来进比对，看看新动物更接近哪个训练集中已有的模型。</p><p>例如逻辑回归之类的直接试图建立 <spanclass="math inline">\(p(y|x)\)</span>的算法，以及感知器算法（perceptronalgorithm）等直接用投图（mappings directly）的思路来判断对应 <spanclass="math inline">\(X\)</span> 的值落到了 <spanclass="math inline">\(\{0, 1\}\)</span>中哪个区域的算法，这些都叫<strong>判别式学习算法（discriminativelearning algorithms）。</strong>和之前的这些判别式算法不同，下面我们要讲的新算法是对 <spanclass="math inline">\(p(x|y)\)</span> 和 <spanclass="math inline">\(p(y)\)</span>来进行建模。这类算法叫<strong>做生成学习算法（generativelearning algorithms）</strong>。例如如果 <spanclass="math inline">\(y\)</span> 用来表示一个样例是 小狗 <spanclass="math inline">\((0)\)</span> 或者 大象 <spanclass="math inline">\((1)\)</span>，那么<spanclass="math inline">\(p(x|y =0)\)</span>就是对小狗特征分布的建模，而<span class="math inline">\(p(x|y= 1)\)</span>就是对大象特征分布的建模。</p><p>对 <span class="math inline">\(p(y)\)</span> (通常称为<strong>classpriors</strong><code>译者注：这里没有找到合适的词进行翻译</code>)和<span class="math inline">\(p(x|y)\)</span>进行建模之后，我们的算法就是用<strong>贝叶斯规则（Bayes rule）</strong>来推导对应给定 <span class="math inline">\(x\)</span> 下 <spanclass="math inline">\(y\)</span> 的<strong>后验分布（posteriordistribution）</strong>：</p><p><span class="math display">\[p(y|x)=\frac{p(x|y)p(y)}{p(x)}\]</span></p><p>这里的<strong>分母（denominator）</strong> 为：<spanclass="math inline">\(p(x) = p(x|y = 1)p(y = 1) + p(x|y = 0)p(y =0)\)</span>（这个等式关系可以根据概率的标准性质来推导验证<code>译者注：其实就是条件概率</code>），这样接下来就可以把它表示成我们熟悉的<span class="math inline">\(p(x|y)\)</span>和 <spanclass="math inline">\(p(y)\)</span> 的形式了。实际上如果我们计算<spanclass="math inline">\(p(y|x)\)</span>来进行预测，那就并不需要去计算这个分母，因为有下面的等式关系：</p><p><span class="math display">\[\begin{aligned}\arg \max_y p(y|x) &amp; =\arg \max_y \frac{p(x|y)p(y)}{p(x)}\\&amp;= \arg \max_y p(x|y)p(y)\end{aligned}\]</span></p><h4 id="高斯判别分析gaussian-discriminant-analysis">1高斯判别分析（Gaussian discriminant analysis）</h4><p>咱们要学的第一个生成学习算法就是<strong>高斯判别分析（Gaussiandiscriminant analysis</strong>，缩写为GDA。<code>译者注：高斯真棒！</code>）在这个模型里面，我们<strong>假设<span class="math inline">\(p(x|y)\)</span>是一个多元正态分布。</strong>所以首先咱们简单讲一下多元正态分布的一些特点，然后再继续讲 GDA高斯判别分析模型。</p><h5 id="多元正态分布multivariate-normal-distribution">1.1多元正态分布（multivariate normal distribution）</h5><p><spanclass="math inline">\(n\)</span>维多元正态分布，也叫做多变量高斯分布，参数为一个<spanclass="math inline">\(n\)</span>维 <strong>均值向量</strong> <spanclass="math inline">\(\mu \in  R^n \)</span>，以及一个<strong>协方差矩阵</strong> <span class="math inline">\(\Sigma\in  R^{n\times n}\)</span>，其中<span class="math inline">\(\Sigma \geq0\)</span> 是一个对称（symmetric）的半正定（positivesemi-definite）矩阵。当然也可以写成"<span class="math inline">\(N (\mu,\Sigma)\)</span>" 的分布形式，密度（density）函数为：</p><p><span class="math display">\[p(x;\mu,\Sigma)=\frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))\]</span></p><p>在上面的等式中，"<spanclass="math inline">\(|\Sigma|\)</span>"的意思是矩阵<spanclass="math inline">\(\Sigma\)</span>的行列式（determinant）。对于一个在<span class="math inline">\(N(\mu,\Sigma)\)</span>分布中的随机变量 <spanclass="math inline">\(X\)</span>，其平均值（跟正态分布里面差不多，所以并不意外）就是 <spanclass="math inline">\(\mu\)</span> 了：</p><p><span class="math display">\[E[X]=\int_x xp(x;\mu,\Sigma)dx=\mu\]</span></p><p>随机变量<spanclass="math inline">\(Z\)</span>是一个有值的向量（vector-valued randomvariable），<span class="math inline">\(Z\)</span> 的<strong>协方差（covariance）</strong> 的定义是：<spanclass="math inline">\(Cov(Z) = E[(Z-E[Z])(Z-E[Z])^T]\)</span>。这是对实数随机变量的方差（variance）这一概念的泛化扩展。这个协方差还可以定义成<spanclass="math inline">\(Cov(Z) =E[ZZ^T]-(E[Z])(E[Z])^T\)</span>（你可以自己证明一下这两个定义实际上是等价的。）如果<span class="math inline">\(X\)</span> 是一个多变量正态分布，即 <spanclass="math inline">\(X \sim N (\mu, \Sigma)\)</span>，则有：</p><p><span class="math display">\[Cov(X)=\Sigma\]</span></p><p>下面这些样例是一些高斯分布的密度图，如下图所示：</p><p><img src="/img/cs229note2f1.png" /></p><p>最左边的图，展示的是一个均值为<spanclass="math inline">\(0\)</span>（实际上是一个<spanclass="math inline">\(2\times 1\)</span>的零向量）的高斯分布，协方差矩阵就是<span class="math inline">\(\Sigma =I\)</span> （一个 <span class="math inline">\(2\times2\)</span>的单位矩阵，identity matrix）。这种均值为<spanclass="math inline">\(0\)</span>并且协方差矩阵为单位矩阵的高斯分布也叫做<strong>标准正态分布。</strong>中间的图中展示的是均值为<spanclass="math inline">\(0\)</span>而协方差矩阵是<spanclass="math inline">\(0.6I\)</span>的高斯分布的概率密度函数；最右边的展示的是协方差矩阵<spanclass="math inline">\(\Sigma =2I\)</span>的高斯分布的概率密度函数。从这几个图可以看出，随着协方差矩阵<spanclass="math inline">\(\Sigma\)</span>变大，高斯分布的形态就变得更宽平（spread-out），而如果协方差矩阵<spanclass="math inline">\(\Sigma\)</span>变小，分布就会更加集中（compressed）。</p><p>来看一下更多的样例：</p><p><img src="/img/cs229note2f2.png" /></p><p>上面这几个图展示的是均值为<spanclass="math inline">\(0\)</span>，但协方差矩阵各不相同的高斯分布，其中的协方差矩阵依次如下所示：</p><p><span class="math display">\[\Sigma =\begin{bmatrix}1 &amp; 0 \\ 0 &amp; 1 \\ \end{bmatrix};\Sigma =\begin{bmatrix}1 &amp; 0.5 \\ 0.5 &amp; 1 \\\end{bmatrix};\Sigma =\begin{bmatrix}1 &amp; 0.8 \\ 0.8 &amp; 1 \\\end{bmatrix}\]</span></p><p>第一幅图还跟之前的标准正态分布的样子很相似，然后我们发现随着增大协方差矩阵<spanclass="math inline">\(\Sigma\)</span>的反对角线（off-diagonal）的值，密度图像开始朝着  45° 方向 (也就是 <spanclass="math inline">\(x_1 = x_2\)</span>所在的方向)逐渐压缩（compressed）。看一下三个同样分布密度图的轮廓图（contours）能看得更明显：</p><p><img src="/img/cs229note2f3.png" /></p><p>下面的是另外一组样例，调整了协方差矩阵<spanclass="math inline">\(\Sigma\)</span>:</p><p><span class="math display">\[\Sigma =\begin{bmatrix}1 &amp; 0.5 \\ 0.5 &amp; 1 \\\end{bmatrix};\Sigma =\begin{bmatrix}1 &amp; 0.8 \\ 0.8 &amp; 1 \\\end{bmatrix}\Sigma =\begin{bmatrix}3 &amp; 0.8 \\ 0.8 &amp; 1 \\ \end{bmatrix};\]</span></p><p>上面这三个图像对应的协方差矩阵分别如下所示：</p><p><img src="/img/cs229note2f4.png" /></p><p>从最左边的到中间<code>译者注：注意，左边和中间的这两个协方差矩阵中，右上和左下的元素都是负值！</code>很明显随着协方差矩阵中右上左下这个对角线方向元素的值的降低，图像还是又被压扁了（compressed），只是方向是反方向的。最后，随着我们修改参数，通常生成的轮廓图（contours）都是椭圆（最右边的图就是一个例子）。</p><p>再举一些例子，固定协方差矩阵为单位矩阵，即<spanclass="math inline">\(\Sigma = I\)</span>，然后调整均值<spanclass="math inline">\(\mu\)</span>，我们就可以让密度图像随着均值而移动：</p><p><img src="/img/cs229note2f5.png" /></p><p>上面的图像中协方差矩阵都是单位矩阵，即 <spanclass="math inline">\(\Sigma = I\)</span>，对应的均值<spanclass="math inline">\(\mu\)</span>如下所示：</p><p><span class="math display">\[\mu =\begin{bmatrix}1 \\ 0 \\\end{bmatrix};\mu =\begin{bmatrix}-0.5 \\ 0 \\\end{bmatrix};\mu =\begin{bmatrix}-1 \\ -1.5 \\\end{bmatrix};\]</span></p><h5 id="高斯判别分析模型gaussian-discriminant-analysis-model">1.2高斯判别分析模型（Gaussian Discriminant Analysis model）</h5><p>假如我们有一个分类问题，其中输入特征 <spanclass="math inline">\(x\)</span>是一系列的连续随机变量（continuous-valued randomvariables），那就可以使用高斯判别分析（Gaussian Discriminant Analysis，缩写为 GDA）模型，其中对 <spanclass="math inline">\(p(x|y)\)</span>用多元正态分布来进行建模。这个模型为：</p><p><span class="math display">\[\begin{aligned}y &amp; \sim Bernoulli(\phi)\\x|y = 0 &amp; \sim N(\mu_o,\Sigma)\\x|y = 1 &amp; \sim N(\mu_1,\Sigma)\\\end{aligned}\]</span></p><p>分布写出来的具体形式如下：</p><p><span class="math display">\[\begin{aligned}p(y) &amp; =\phi^y (1-\phi)^{1-y}\\p(x|y=0) &amp; = \frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}} exp ( -\frac{1}{2}(x-\mu_0)^T\Sigma^{-1}(x-\mu_0)  )\\p(x|y=1) &amp; = \frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}} exp ( -\frac{1}{2}(x-\mu_1)^T\Sigma^{-1}(x-\mu_1)  )\\\end{aligned}\]</span></p><p>在上面的等式中，模型的参数包括<span class="math inline">\(\phi,\Sigma, \mu_0 和\mu_1\)</span>。（要注意，虽然这里有两个不同方向的均值向量<spanclass="math inline">\(\mu_0\)</span> 和 <spanclass="math inline">\(\mu_1\)</span>，针对这个模型还是一般只是用一个协方差矩阵<spanclass="math inline">\(\Sigma\)</span>。）取对数的似然函数（log-likelihood）如下所示：</p><p><span class="math display">\[\begin{aligned}l(\phi,\mu_0,\mu_1,\Sigma) &amp;= \log\prod^m_{i=1}p(x^{(i)},y^{(i)};\phi,\mu_0,\mu_1,\Sigma)\\&amp;= \log\prod^m_{i=1}p(x^{(i)}|y^{(i)};\mu_0,\mu_1,\Sigma)p(y^{(i)};\phi)\\\end{aligned}\]</span></p><p>通过使 <span class="math inline">\(l\)</span>取得最大值，找到对应的参数组合，然后就能找到该参数组合对应的最大似然估计，如下所示（参考习题集1）：</p><p><span class="math display">\[\begin{aligned}\phi &amp; = \frac {1}{m} \sum^m_{i=1}1\{y^{(i)}=1\}\\\mu_0 &amp; =\frac{\sum^m_{i=1}1\{y^{(i)}=0\}x^{(i)}}{\sum^m_{i=1}1\{y^{(i)}=0\}}\\\mu_1 &amp; =\frac{\sum^m_{i=1}1\{y^{(i)}=1\}x^{(i)}}{\sum^m_{i=1}1\{y^{(i)}=1\}}\\\Sigma &amp; =\frac{1}{m}\sum^m_{i=1}(x^{(i)}-\mu_{y^{(i)}})(x^{(i)}-\mu_{y^{(i)}})^T\\\end{aligned}\]</span></p><p>用图形化的方式来表述，这个算法可以按照下面的图示所表示：</p><p><img src="/img/cs229note2f6.png" /></p><p>图中展示的点就是训练数据集，图中的两个高斯分布就是针对两类数据各自进行的拟合。要注意这两个高斯分布的轮廓图有同样的形状和拉伸方向，这是因为他们都有同样的协方差矩阵<spanclass="math inline">\(\Sigma\)</span>，但他们有不同的均值<spanclass="math inline">\(\mu_0\)</span> 和 <spanclass="math inline">\(\mu_1\)</span> 。此外，图中的直线给出了<spanclass="math inline">\(p (y = 1|x) = 0.5\)</span>这条边界线。在这条边界的一侧，我们预测 <span class="math inline">\(y =1\)</span>是最可能的结果，而另一侧，就预测 <span class="math inline">\(y= 0\)</span>是最可能的结果。</p><h5 id="讨论高斯判别分析gda与逻辑回归logistic-regression">1.3讨论：高斯判别分析（GDA）与逻辑回归（logistic regression）</h5><p>高斯判别分析模型与逻辑回归有很有趣的相关性。如果我们把变量（quantity）<spanclass="math inline">\(p (y = 1|x; \phi, \mu_0, \mu_1, \Sigma)\)</span>作为一个 <span class="math inline">\(x\)</span>的函数，就会发现可以用如下的形式来表达：</p><p><span class="math display">\[p(y=1|x;\phi,\Sigma,\mu_0,\mu_1)=\frac 1 {1+exp(-\theta^Tx)}\]</span></p><p>其中的 <span class="math inline">\(\theta\)</span> 是对<spanclass="math inline">\(\phi\)</span>, <spanclass="math inline">\(\Sigma\)</span>, <spanclass="math inline">\(\mu_0\)</span>, <spanclass="math inline">\(\mu_1\)</span>的某种函数。这就是逻辑回归（也是一种判别分析算法）用来对<spanclass="math inline">\(p (y = 1|x)\)</span> 建模的形式。</p><blockquote><p>注：上面这里用到了一种转换，就是重新对<spanclass="math inline">\(x^{(i)}\)</span>向量进行了定义，在右手侧（right-hand-side）增加了一个额外的坐标<spanclass="math inline">\(x_0^{(i)} = 1\)</span>，然后使之成为了一个 <spanclass="math inline">\(n+1\)</span>维的向量；具体内容参考习题集1。</p></blockquote><p>这两个模型中什么时候该选哪一个呢？一般来说，高斯判别分析（GDA）和逻辑回归，对同一个训练集，可能给出的判别曲线是不一样的。哪一个更好些呢？</p><p>我们刚刚已经表明，如果<spanclass="math inline">\(p(x|y)\)</span>是一个多变量的高斯分布（且具有一个共享的协方差矩阵<spanclass="math inline">\(\Sigma\)</span>），那么<spanclass="math inline">\(p(y|x)\)</span>则必然符合一个逻辑函数（logisticfunction）。然而，反过来，这个命题是不成立的。例如假如<spanclass="math inline">\(p(y|x)\)</span>是一个逻辑函数，这并不能保证<spanclass="math inline">\(p(x|y)\)</span>一定是一个多变量的高斯分布。这就表明<strong>高斯判别模型能比逻辑回归对数据进行更强的建模和假设（strongermodeling assumptions）。</strong>这也就意味着，<strong>在这两种模型假设都可用的时候，高斯判别分析法去拟合数据是更好的，是一个更好的模型。</strong>尤其当<spanclass="math inline">\(p(x|y)\)</span>已经确定是一个高斯分布（有共享的协方差矩阵<spanclass="math inline">\(\Sigma\)</span>），那么高斯判别分析是<strong>渐进有效的（asymptoticallyefficient）。</strong>实际上，这也意味着，在面对非常大的训练集（训练样本规模 $m$特别大）的时候，严格来说，可能就没有什么别的算法能比高斯判别分析更好（比如考虑到对<spanclass="math inline">\(p(y|x)\)</span>估计的准确度等等）。所以在这种情况下就表明，高斯判别分析（GDA）是一个比逻辑回归更好的算法；再扩展一下，即便对于小规模的训练集，我们最终也会发现高斯判别分析（GDA）是更好的。</p><p>奈何事有正反，由于逻辑回归做出的假设要明显更弱一些（significantlyweaker），所以因此逻辑回归给出的判断鲁棒性（robust）也更强，同时也对错误的建模假设不那么敏感。有很多不同的假设集合都能够将<spanclass="math inline">\(p(y|x)\)</span>引向逻辑回归函数。例如，如果<spanclass="math inline">\(x|y = 0\sim Poisson(\lambda_0)\)</span>是一个泊松分布，而<span class="math inline">\(x|y = 1\simPoisson(\lambda_1)\)</span>也是一个泊松分布，那么<spanclass="math inline">\(p(y|x)\)</span>也将是适合逻辑回归的（logistic）。逻辑回归也适用于这类的泊松分布的数据。但对这样的数据，如果我们强行使用高斯判别分析（GDA），然后用高斯分布来拟合这些非高斯数据，那么结果的可预测性就会降低，而且GDA这种方法也许可行，也有可能是不能用。</p><p>总结一下也就是：高斯判别分析方法（GDA）能够建立更强的模型假设，并且在数据利用上更加有效（比如说，需要更少的训练集就能有"还不错的"效果），当然前提是模型假设争取或者至少接近正确。逻辑回归建立的假设更弱，因此对于偏离的模型假设来说更加鲁棒（robust）。然而，如果训练集数据的确是非高斯分布的（non-Gaussian），而且是有限的大规模数据（inthe limit of largedatasets），那么逻辑回归几乎总是比GDA要更好的。因此，在实际中，逻辑回归的使用频率要比GDA高得多。（关于判别和生成模型的对比的相关讨论也适用于我们下面要讲的朴素贝叶斯算法（NaiveBayes），但朴素贝叶斯算法还是被认为是一个非常优秀也非常流行的分类算法。）</p><h4 id="朴素贝叶斯法naive-bayes">2 朴素贝叶斯法（Naive Bayes）</h4><p>在高斯判别分析（GDA）方法中，特征向量 <spanclass="math inline">\(x\)</span>是连续的，值为实数的向量。下面我们要讲的是当 <spanclass="math inline">\(x_i\)</span> 是离散值的时候来使用的另外一种学习算法。</p><p>下面就来继续看一个之前见过的样例，来尝试建立一个邮件筛选器，使用机器学习的方法。这回咱们要来对邮件信息进行分类，来判断是否为商业广告邮件（就是垃圾邮件），还是非垃圾邮件。在学会了怎么实现之后，我们就可以让邮件阅读器能够自动对垃圾信息进行过滤，或者单独把这些垃圾邮件放进一个单独的文件夹中。对邮件进行分类是一个案例，属于文本分类这一更广泛问题集合。</p><p>假设我们有了一个训练集（也就是一堆已经标好了是否为垃圾邮件的邮件）。要构建垃圾邮件分选器，咱们先要开始确定用来描述一封邮件的特征<spanclass="math inline">\(x_i\)</span>有哪些。</p><p>我们将用一个特征向量来表示一封邮件，这个向量的长度等于字典中单词的个数。如果邮件中包含了字典中的第<span class="math inline">\(i\)</span> 个单词，那么就令 <spanclass="math inline">\(x_i = 1\)</span>；反之则<spanclass="math inline">\(x_i = 0\)</span>。例如下面这个向量：</p><p><span class="math display">\[x=\begin{bmatrix}1\\0\\0\\\vdots \\1\\ \vdots \\0\end{bmatrix}\begin{matrix}\text{a}\\ \text{aardvark}\\ \text{aardwolf}\\ \vdots\\\text{buy}\\ \vdots\\ \text{zygmurgy}\\ \end{matrix}\]</span></p><p>就用来表示一个邮件，其中包含了两个单词 "a" 和 "buy"，但没有单词"aardvark"， "aardwolf" 或者 "zymurgy"。这个单词集合编码整理成的特征向量也成为<strong>词汇表（vocabulary,），</strong>所以特征向量 <span class="math inline">\(x\)</span>的维度就等于词汇表的长度。</p><blockquote><p>注：实际应用中并不需要遍历整个英语词典来组成所有英语单词的列表，实践中更常用的方法是遍历一下训练集，然后把出现过一次以上的单词才编码成特征向量。这样做除了能够降低模型中单词表的长度之外，还能够降低运算量和空间占用，此外还有一个好处就是能够包含一些你的邮件中出现了而词典中没有的单词，比如本课程的缩写CS229。有时候（比如在作业里面），还要排除一些特别高频率的词汇，比如像冠词the，介词of和and 等等；这些高频率但是没有具体意义的虚词也叫做stopwords，因为很多文档中都要有这些词，用它们也基本不能用来判定一个邮件是否为垃圾邮件。</p></blockquote><p>选好了特征向量了，接下来就是建立一个生成模型（generativemodel）。所以我们必须对<spanclass="math inline">\(p(x|y)\)</span>进行建模。但是，假如我们的单词有五万个词，则特征向量<spanclass="math inline">\(x \in  \{0, 1\}^{50000}\)</span> （即 <spanclass="math inline">\(x\)</span>是一个 <spanclass="math inline">\(50000\)</span> 维的向量，其值是<spanclass="math inline">\(0\)</span>或者<spanclass="math inline">\(1\)</span>），如果我们要对这样的 <spanclass="math inline">\(x\)</span>进行多项式分布的建模，那么就可能有<spanclass="math inline">\(2^{50000}\)</span> 种可能的输出，然后就要用一个<spanclass="math inline">\((2^{50000}-1)\)</span>维的参数向量。这样参数明显太多了。</p><p>要给<spanclass="math inline">\(p(x|y)\)</span>建模，先来做一个非常强的假设。我们<strong>假设特征向量<spanclass="math inline">\(x_i\)</span> 对于给定的 <spanclass="math inline">\(y\)</span> 是独立的。</strong>这个假设也叫做<strong>朴素贝叶斯假设（Naive Bayes ，NBassumption），</strong>基于此假设衍生的算法也就叫做<strong>朴素贝叶斯分类器（Naive Bayesclassifier）。</strong> 例如，如果 <span class="math inline">\(y =1\)</span> 意味着一个邮件是垃圾邮件；然后其中"buy" 是第<spanclass="math inline">\(2087\)</span>个单词，而 "price"是第<spanclass="math inline">\(39831\)</span>个单词；那么接下来我们就假设，如果我告诉你<span class="math inline">\(y =1\)</span>，也就是说某一个特定的邮件是垃圾邮件，那么对于<spanclass="math inline">\(x_{2087}\)</span> （也就是单词 buy是否出现在邮件里）的了解并不会影响你对<spanclass="math inline">\(x_{39831}\)</span>（单词price出现的位置）的采信值。更正规一点，可以写成 <spanclass="math inline">\(p(x_{2087}|y) = p(x_{2087}|y,x_{39831})\)</span>。（要注意这个并不是说<spanclass="math inline">\(x_{2087}\)</span> 和 <spanclass="math inline">\(x_{39831}\)</span>这两个特征是独立的，那样就变成了<spanclass="math inline">\(p(x_{2087}) =p(x_{2087}|x_{39831})\)</span>，我们这里是说在给定了 <spanclass="math inline">\(y\)</span>的这样一个条件下，二者才是有条件的独立。）</p><p>然后我们就得到了等式：</p><p><span class="math display">\[\begin{aligned}p(x_1, ..., x_{50000}|y) &amp; = p(x_1|y)p(x_2|y,x_1)p(x_3|y,x_1,x_2)... p(x_{50000}|y,x_1,x_2,...,x_{49999})\\&amp; = p(x_1|y)p(x_2|y)p(x_3|y) ... p(x_{50000}|y)\\&amp; = \prod^n_{i=1}p(x_i|y)\\\end{aligned}\]</span></p><p>第一行的等式就是简单地来自概率的基本性质，第二个等式则使用了朴素贝叶斯假设。这里要注意，朴素贝叶斯假设也是一个很强的假设，产生的这个算法可以适用于很多种问题。</p><p>我们这个模型的参数为 <span class="math inline">\(\phi_{i|y=1} = p(x_i = 1|y = 1), \phi_{i|y=0} = p (x_i = 1|y = 0)\)</span>, 而 <spanclass="math inline">\(\phi_y = p (y =1)\)</span>。和以往一样，给定一个训练集<spanclass="math inline">\(\{(x^{(i)},y^{(i)}); i = 1, ...,m\}\)</span>，就可以写出下面的联合似然函数：</p><p><span class="math display">\[\mathcal{L}(\phi_y,\phi_{j|y=0},\phi_{j|y=1})=\prod^m_{i=1}p(x^{(i)},y^{(i)})\]</span></p><p>找到使联合似然函数取得最大值的对应参数组合 <spanclass="math inline">\(\phi_y , \phi_{i|y=0} 和 \phi_{i|y=1}\)</span>就给出了最大似然估计：</p><p><span class="math display">\[\begin{aligned}\phi_{j|y=1} &amp;=\frac{\sum^m_{i=1}1\{x_j^{(i)} =1 \wedge y^{(i)} =1\}}{\sum^m_{i=1}1\{y^{(i)} =1\}} \\\phi_{j|y=0} &amp;= \frac{\sum^m_{i=1}1\{x_j^{(i)} =1 \wedge y^{(i)}=0\} }{\sum^m_{i=1}1\{y^{(i)} =0\}} \\\phi_{y} &amp;= \frac{\sum^m_{i=1}1\{y^{(i)} =1\}}{m}\\\end{aligned}\]</span></p><p>在上面的等式中，"<spanclass="math inline">\(\wedge\)</span>(and)"这个符号的意思是逻辑"和"。这些参数有一个非常自然的解释。例如<span class="math inline">\(\phi_{j|y=1}\)</span> 正是垃圾 <spanclass="math inline">\((y = 1)\)</span> 邮件中出现单词 <spanclass="math inline">\(j\)</span> 的邮件所占的比例。</p><p>拟合好了全部这些参数之后，要对一个新样本的特征向量 <spanclass="math inline">\(x\)</span>进行预测，只要进行如下的简单地计算：</p><p><span class="math display">\[\begin{aligned}p(y=1|x)&amp;=  \frac{p(x|y=1)p(y=1)}{p(x)}\\&amp;=\frac{(\prod^n_{i=1}p(x_i|y=1))p(y=1)}{(\prod^n_{i=1}p(x_i|y=1))p(y=1)+  (\prod^n_{i=1}p(x_i|y=0))p(y=0)}  \\\end{aligned}\]</span></p><p>然后选择有最高后验概率的概率。</p><p>最后我们要注意，刚刚我们对朴素贝叶斯算法的使用中，特征向量 <spanclass="math inline">\(x_i\)</span>都是二值化的，其实特征向量也可以是多个离散值，比如<spanclass="math inline">\(\{1, 2, ...,k_i\}\)</span>这样也都是可以的。这时候只需要把对<spanclass="math inline">\(p(x_i|y)\)</span>的建模从伯努利分布改成多项式分布。实际上，即便一些原始的输入值是连续值（比如我们第一个案例中的房屋面积），也可以转换成一个小规模的离散值的集合，然后再使用朴素贝叶斯方法。例如，如果我们用特征向量<span class="math inline">\(x_i\)</span>来表示住房面积，那么就可以按照下面所示的方法来对这一变量进行离散化：</p><table><thead><tr class="header"><th style="text-align: center;">居住面积</th><th style="text-align: center;"><spanclass="math inline">\(&lt;400\)</span></th><th style="text-align: center;"><spanclass="math inline">\(400-800\)</span></th><th style="text-align: center;"><spanclass="math inline">\(800-1200\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1200-1600\)</span></th><th style="text-align: center;"><spanclass="math inline">\(&gt;1600\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">离散值 <spanclass="math inline">\(x_i\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(4\)</span></td><td style="text-align: center;"><spanclass="math inline">\(5\)</span></td></tr></tbody></table><p>这样，对于一个面积为 <span class="math inline">\(890\)</span>平方英尺的房屋，就可以根据上面这个集合中对应的值来把特征向量的这一项的<spanclass="math inline">\(x_i\)</span>值设置为<spanclass="math inline">\(3\)</span>。然后就可以用朴素贝叶斯算法，并且将<spanclass="math inline">\(p(x_i|y)\)</span>作为多项式分布来进行建模，就都跟前面讲过的内容一样了。当原生的连续值的属性不太容易用一个多元正态分布来进行建模的时候，将其特征向量离散化然后使用朴素贝叶斯法（NB）来替代高斯判别分析法（GDA），通常能形成一个更好的分类器。</p><h5 id="拉普拉斯平滑laplace-smoothing">2.1 拉普拉斯平滑（Laplacesmoothing）</h5><p>刚刚讲过的朴素贝叶斯算法能够解决很多问题了，但还能对这种方法进行一点小调整来进一步提高效果，尤其是应对文本分类的情况。我们来简要讨论一下一个算法当前状态的一个问题，然后在讲一下如何解决这个问题。</p><p>还是考虑垃圾邮件分类的过程，设想你学完了CS229的课程，然后做了很棒的研究项目，之后你决定在<spanclass="math inline">\(2003\)</span>年<spanclass="math inline">\(6\)</span>月<code>译者注：作者这讲义一定写得很早</code>把自己的作品投稿到NIPS会议，这个NIPS是机器学习领域的一个顶级会议，递交论文的截止日期一般是六月末到七月初。你通过邮件来对这个会议进行了讨论，然后你也开始收到带有nips四个字母的信息。但这个是你第一个NIPS论文，而在此之前，你从来没有接到过任何带有nips 这个单词的邮件；尤其重要的是，nips这个单词就从来都没有出现在你的垃圾/正常邮件训练集里面。假如这个 nips是你字典中的第<spanclass="math inline">\(35000\)</span>个单词，那么你的朴素贝叶斯垃圾邮件筛选器就要对参数<spanclass="math inline">\(\phi_{35000|y}\)</span>进行最大似然估计，如下所示：</p><p><span class="math display">\[\begin{aligned}\phi_{35000|y=1} &amp;=  \frac{\sum^m_{i=1}1\{x^{(i)}_{35000}=1 \wedgey^{(i)}=1  \}}{\sum^m_{i=1}1\{y^{(i)}=0\}}  &amp;=0 \\\phi_{35000|y=0} &amp;=  \frac{\sum^m_{i=1}1\{x^{(i)}_{35000}=1 \wedgey^{(i)}=0  \}}{\sum^m_{i=1}1\{y^{(i)}=0\}}  &amp;=0 \\\end{aligned}\]</span></p><p>也就是说，因为之前程序从来没有在别的垃圾邮件或者正常邮件的训练样本中看到过nips 这个词，所以它就认为看到这个词出现在这两种邮件中的概率都是<spanclass="math inline">\(0\)</span>。因此当要决定一个包含 nips这个单词的邮件是否为垃圾邮件的时候，他就检验这个类的后验概率，然后得到了：</p><p><span class="math display">\[\begin{aligned}p(y=1|x) &amp;= \frac{ \prod^n_{i=1} p(x_i|y=1)p(y=1) }   {\prod^n_{i=1}p(x_i|y=1)p(y=1) +\prod^n_{i=1} p(x_i|y=0)p(y=0)    }\\&amp;= \frac00\\\end{aligned}\]</span></p><p>这是因为对于" <span class="math inline">\(\prod^n_{i=1}p(x_i|y)\)</span>"中包含了<span class="math inline">\(p(x_{35000}|y) =0\)</span>的都加了起来，也就还是<spanclass="math inline">\(0\)</span>。所以我们的算法得到的就是 <spanclass="math inline">\(\frac00\)</span>，也就是不知道该做出怎么样的预测了。</p><p>然后进一步拓展一下这个问题，统计学上来说，只因为你在自己以前的有限的训练数据集中没见到过一件事，就估计这个事件的概率为零，这明显不是个好主意。假设问题是估计一个多项式随机变量<span class="math inline">\(z\)</span> ，其取值范围在<spanclass="math inline">\(\{1,..., k\}\)</span>之内。接下来就可以用<spanclass="math inline">\(\phi_i = p (z = i)\)</span>来作为多项式参数。给定一个 <span class="math inline">\(m\)</span>个独立观测<span class="math inline">\(\{z^{(1)}, ..., z^{(m)}\}\)</span>组成的集合，然后最大似然估计的形式如下：</p><p><span class="math display">\[\phi_j=\frac{\sum^m_{i=1}1\{z^{(i)}=j\}}m\]</span></p><p>正如咱们之前见到的，如果我们用这些最大似然估计，那么一些<spanclass="math inline">\(\phi_j\)</span>可能最终就是零了，这就是个问题了。要避免这个情况，咱们就可以引入<strong>拉普拉斯平滑（Laplacesmoothing），</strong> 这种方法把上面的估计替换成：</p><p><span class="math display">\[\phi_j=\frac{\sum^m_{i=1}1\{z^{(i)}=j\}+1}{m+k}\]</span></p><p>这里首先是对分子加<spanclass="math inline">\(1\)</span>，然后对分母加<spanclass="math inline">\(k\)</span>，要注意<spanclass="math inline">\(\sum^k_{j=1} \phi_j =1\)</span>依然成立（自己检验一下），这是一个必须有的性质，因为<spanclass="math inline">\(\phi_j\)</span> 是对概率的估计，然后所有的概率加到一起必然等于<spanclass="math inline">\(1\)</span>。另外对于所有的 <spanclass="math inline">\(j\)</span> 值，都有<spanclass="math inline">\(\phi_j \neq0\)</span>，这就解决了刚刚的概率估计为零的问题了。在某些特定的条件下（相当强的假设条件下，arguablyquite strong），可以发现拉普拉斯平滑还真能给出对参数<spanclass="math inline">\(\phi_j\)</span> 的最佳估计（optimalestimator）。</p><p>回到我们的朴素贝叶斯分选器问题上，使用了拉普拉斯平滑之后，对参数的估计就写成了下面的形式：</p><!-- $$\begin{aligned}\phi_{j|y=1} & =\frac{\sum^m_{i=1}1\{x_j^{(i)}=1\wedge y ^{(i)}=1\}+1}{\sum^m_{i=1}1{\{y^{(i)}=1\}}+2}\\\phi_{j|y=0} & =\frac{\sum^m_{i=1}1\{x_j^{(i)}=1\wedge y ^{(i)}=10\}+1}{\sum^m_{i=1}1{\{y^{(i)}=0\}}+2}\\\end{aligned}$$ --><p><span class="math display">\[\begin{gathered}\phi_{j|y=1} =\frac{\sum_{i=1}^m1\{x_j^{(i)}=1\wedgey^{(i)}=1\}+1}{\sum_{i=1}^m1\{y^{(i)}=1\}+2} \\\phi_{j|y=0} =\frac{\sum_{i=1}^m1\{x_j^{(i)}=1\wedgey^{(i)}=10\}+1}{\sum_{i=1}^m1\{y^{(i)}=0\}+2}\end{gathered}\]</span></p><p>（在实际应用中，通常是否对<span class="math inline">\(\phi_y\)</span>使用拉普拉斯并没有太大影响，因为通常我们会对每个垃圾邮件和非垃圾邮件都有一个合适的划分比例，所以<spanclass="math inline">\(\phi_y\)</span> 会是对<spanclass="math inline">\(p(y = 1)\)</span>的一个合理估计，无论如何都会与零点有一定距离。）</p><h5 id="针对文本分类的事件模型event-models-for-text-classification">2.2针对文本分类的事件模型（Event models for text classification）</h5><p>到这里就要给咱们关于生成学习算法的讨论进行一下收尾了，所以就接着讲一点关于文本分类方面的另一个模型。我们刚已经演示过的朴素贝叶斯方法能够解决很多分类问题了，不过还有另一个相关的算法，在针对文本的分类效果还要更好。</p><p>在针对文本进行分类的特定背景下，咱们上面讲的朴素贝叶斯方法使用的是一种叫做<strong>多元伯努利事件模型（Multi-VariateBernoulli event model）。</strong>在这个模型里面，我们假设邮件发送的方式，是随机确定的（根据先验类<em>classpriors</em>， <spanclass="math inline">\(p(y)\)</span>），无论是不是垃圾邮件发送者，他是否给你发下一封邮件都是随机决定的。那么发件人就会遍历词典，决定在邮件中是否包含某个单词<spanclass="math inline">\(i\)</span>，各个单词之间互相独立，并且服从概率分布<spanclass="math inline">\(p(x_i=1|y)=\phi_{i|y}\)</span>。因此，一条消息的概率为：<spanclass="math inline">\(p(y)\prod^n_{i-1}p(x_i|y)\)</span></p><p>然后还有另外一个模型，叫做<strong>多项式事件模型（Multinomial eventmodel）。</strong>要描述这个模型，我们需要使用一个不同的记号和特征集来表征各种邮件。设<span class="math inline">\(x_i\)</span> 表示单词中的第<spanclass="math inline">\(i\)</span>个单词。因此，<spanclass="math inline">\(x_i\)</span>现在就是一个整数，取值范围为<spanclass="math inline">\(\{1,...,|V|\}\)</span>，这里的<spanclass="math inline">\(|V|\)</span>是词汇列表（即字典）的长度。这样一个有<span class="math inline">\(n\)</span>个单词的邮件就可以表征为一个长度为 <spanclass="math inline">\(n\)</span> 的向量<spanclass="math inline">\((x_1,x_2,...,x_n)\)</span>；这里要注意，不同的邮件内容，<spanclass="math inline">\(n\)</span>的取值可以是不同的。例如，如果一个邮件的开头是"A NIPS . . ." ，那么<spanclass="math inline">\(x_1 = 1\)</span> ("a" 是词典中的第一个)，而<spanclass="math inline">\(x_2 = 35000\)</span> (这是假设"nips"是词典中的第35000个)。</p><p>在多项式事件模型中，我们假设邮件的生成是通过一个随机过程的，而是否为垃圾邮件是首先决定的（根据<spanclass="math inline">\(p(y)\)</span>），这个和之前的模型假设一样。然后邮件的发送者写邮件首先是要生成从对单词<span class="math inline">\((p(x_1|y))\)</span>的某种多项式分布中生成 <spanclass="math inline">\(x_1\)</span>。然后第二步是独立于 <spanclass="math inline">\(x_1\)</span> 来生成 <spanclass="math inline">\(x_2\)</span>，但也是从相同的多项式分布中来选取，然后是<span class="math inline">\(x_3\)</span>,<spanclass="math inline">\(x_4\)</span>等等，以此类推，直到生成了整个邮件中的所有的词。因此，一个邮件的总体概率就是<spanclass="math inline">\(p(y)\prod^n_{i=1}p(x_i|y)\)</span>。要注意这个方程看着和我们之前那个多元伯努利事件模型里面的邮件概率很相似，但实际上这里面的意义完全不同了。尤其是这里的<spanclass="math inline">\(x_i|y\)</span>现在是一个多项式分布了，而不是伯努利分布了。</p><p>我们新模型的参数还是<span class="math inline">\(\phi_y =p(y)\)</span>，这个跟以前一样，然后还有<spanclass="math inline">\(\phi_{k|y=1} = p(x_j =k|y=1)\)</span> (对任何<span class="math inline">\(j\)</span>)以及 <spanclass="math inline">\(\phi_{i|y=0} =p(x_j=k|y=0)\)</span>。要注意这里我们已经假设了对于任何<spanclass="math inline">\(j\)</span> 的值，<spanclass="math inline">\(p(x_j|y)\)</span>这个概率都是相等的，也就是意味着在这个哪个词汇生成的这个分布不依赖这个词在邮件中的位置<spanclass="math inline">\(j\)</span>。</p><p>如果给定一个训练集<span class="math inline">\(\{(x^{(i)},y^{(i)}); i= 1, ..., m\}\)</span>，其中 <span class="math inline">\(x^{(i)}  = (x^{(i)}_{1} , x^{(i)}_{2} ,..., x^{(i)}_{n_i})\)</span>（这里的<spanclass="math inline">\(n\)</span>是在第<spanclass="math inline">\(i\)</span>个训练样本中的单词数目），那么这个数据的似然函数如下所示：</p><p><span class="math display">\[\begin{aligned}\mathcal{L}(\phi,\phi_{k|y=0},\phi_{k|y=1})&amp; = \prod^m_{i=1}p(x^{(i)},y^{(i)})\\&amp; =\prod^m_{i=1}(\prod^{n_i}_{j=1}p(x_j^{(i)}|y;\phi_{k|y=0},\phi_{k|y=1}))p(y^{(i)};\phi_y)\\\end{aligned}\]</span></p><p>让上面的这个函数最大化就可以产生对参数的最大似然估计：</p><p><span class="math display">\[\begin{aligned}\phi_{k|y=1}&amp;=  \frac{\sum^m_{i=1}\sum^{n_i}_{j=1}1\{x_j^{(i)}=k\wedgey^{(i)}=1\}}{\sum^m_{i=1}1\{y^{(i)}=1\}n_i} \\\phi_{k|y=0}&amp;=  \frac{\sum^m_{i=1}\sum^{n_i}_{j=1}1\{x_j^{(i)}=k\wedgey^{(i)}=0\}}{\sum^m_{i=1}1\{y^{(i)}=0\}n_i} \\\phi_y&amp;=   \frac{\sum^m_{i=1}1\{y^{(i)}=1\}}{m}\\\end{aligned}\]</span></p><p>如果使用拉普拉斯平滑（实践中会用这个方法来提高性能）来估计<spanclass="math inline">\(\phi_{k|y=0}\)</span> 和 <spanclass="math inline">\(\phi_{k|y=1}\)</span>，就在分子上加1，然后分母上加<spanclass="math inline">\(|V|\)</span>，就得到了下面的等式：</p><p><span class="math display">\[\begin{aligned}\phi_{k|y=1}&amp;=  \frac{\sum^m_{i=1}\sum^{n_i}_{j=1}1\{x_j^{(i)}=k\wedgey^{(i)}=1\}+1}{\sum^m_{i=1}1\{y^{(i)}=1\}n_i+|V|} \\\phi_{k|y=0}&amp;=  \frac{\sum^m_{i=1}\sum^{n_i}_{j=1}1\{x_j^{(i)}=k\wedgey^{(i)}=0\}+1}{\sum^m_{i=1}1\{y^{(i)}=0\}n_i+|V|} \\\end{aligned}\]</span></p><p>当然了，这个并不见得就是一个最好的分类算法，不过朴素贝叶斯分选器通常用起来还都出乎意料地那么好。所以这个方法就是一个很好的"首发选择"，因为它很简单又很好实现。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习----线性模型</title>
    <link href="/2023/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0----%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/08/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0----%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章">第一章</h1><h2 id="监督学习supervised-learning">监督学习（Supervisedlearning）</h2><p>咱们先来聊几个使用监督学习来解决问题的实例。假如咱们有一个数据集，里面的数据是俄勒冈州波特兰市的<span class="math inline">\(47\)</span> 套房屋的面积和价格：</p><table><thead><tr class="header"><th style="text-align: center;">居住面积（平方英尺）</th><th style="text-align: center;">价格（千美元）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(2104\)</span></td><td style="text-align: center;"><spanclass="math inline">\(400\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(1600\)</span></td><td style="text-align: center;"><spanclass="math inline">\(330\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(2400\)</span></td><td style="text-align: center;"><spanclass="math inline">\(369\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(1416\)</span></td><td style="text-align: center;"><spanclass="math inline">\(232\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(3000\)</span></td><td style="text-align: center;"><spanclass="math inline">\(540\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\vdots\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\vdots\)</span></td></tr></tbody></table><p>用这些数据来投个图：</p><p><img src="/img/cs229note1f1.png" /></p><p>有了这样的数据，我们怎样才能学会预测波特兰其他房屋的价格，以及它们的居住面积？</p><p>这里要先规范一下符号和含义，这些符号以后还要用到，咱们假设 <spanclass="math inline">\(x^{(i)}\)</span> 表示 “输入的”变量值（在这个例子中就是房屋面积），也可以叫做<strong>输入特征</strong>；然后咱们用<span class="math inline">\(y^{(i)}\)</span>来表示“输出值”，或者称之为<strong>目标变量</strong>，这个例子里面就是房屋价格。这样的一对<spanclass="math inline">\((x^{(i)},y^{(i)})\)</span>就称为一组训练样本，然后咱们用来让机器来学习的数据集，就是——一个长度为<span class="math inline">\(m\)</span> 的训练样本的列表<spanclass="math inline">\(\{(x^{(i)},y^{(i)}); i = 1,\dots,m\}\)</span>——也叫做一个<strong>训练集</strong>。另外一定注意，这里的上标<spanclass="math inline">\((i)\)</span>只是作为训练集的索引记号，和数学乘方没有任何关系，千万别误解了。另外我们还会用大写的<spanclass="math inline">\(X\)</span>来表示<strong>输入值的空间</strong>，大写的<spanclass="math inline">\(Y\)</span>表示<strong>输出值的空间</strong>。在本节的这个例子中，输入输出的空间都是实数域，所以<span class="math inline">\(X = Y = R\)</span>。</p><p>然后再用更加规范的方式来描述一下监督学习问题，我们的目标是，给定一个训练集，来让机器学习一个函数<span class="math inline">\(h: X → Y\)</span>，让 <spanclass="math inline">\(h(x)\)</span> 是一个与对应的真实 <spanclass="math inline">\(y\)</span>值比较接近的评估值。由于一些历史上的原因，这个函数 <spanclass="math inline">\(h\)</span>就被叫做<strong>假设（hypothesis）</strong>。用一个图来表示的话，这个过程大概就是下面这样：</p><p><img src="/img/cs229note1f2.png" /></p><p>如果我们要预测的目标变量是连续的，比如在咱们这个房屋价格-面积的案例中，这种学习问题就被称为<strong>回归问题。</strong>如果<spanclass="math inline">\(y\)</span>只能取一小部分的离散的值（比如给定房屋面积，咱们要来确定这个房子是一个住宅还是公寓），这样的问题就叫做<strong>分类问题。</strong></p><h3 id="第一部分-线性回归">第一部分 线性回归</h3><p>为了让我们的房屋案例更有意思，咱们稍微对数据集进行一下补充，增加上每一个房屋的卧室数目：</p><table><thead><tr class="header"><th style="text-align: center;">居住面积（平方英尺）</th><th style="text-align: center;">卧室数目</th><th style="text-align: center;">价格（千美元）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(2104\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(400\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(1600\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(330\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(2400\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(369\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(1416\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(232\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(3000\)</span></td><td style="text-align: center;"><spanclass="math inline">\(4\)</span></td><td style="text-align: center;"><spanclass="math inline">\(540\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\vdots\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\vdots\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\vdots\)</span></td></tr></tbody></table><p>现在，输入特征 <span class="math inline">\(x\)</span> 就是在 <spanclass="math inline">\(R^2\)</span> 范围取值的一个二维向量了。例如 <spanclass="math inline">\(x_1^{(i)}\)</span> 就是训练集中第 <spanclass="math inline">\(i\)</span> 个房屋的面积，而 <spanclass="math inline">\(x_2^{(i)}\)</span> 就是训练集中第 <spanclass="math inline">\(i\)</span>个房屋的卧室数目。（通常来说，设计一个学习算法的时候，选择哪些输入特征都取决于你，所以如果你不在波特兰收集房屋信息数据，你也完全可以选择包含其他的特征，例如房屋是否有壁炉，卫生间的数量啊等等。关于特征筛选的内容会在后面的章节进行更详细的介绍，不过目前来说就暂时先用给定的这两个特征了。）</p><p>要进行这个监督学习，咱们必须得确定好如何在计算机里面对这个<strong>函数/假设</strong><span class="math inline">\(h\)</span>进行表示。咱们现在刚刚开始，就来个简单点的，咱们把 <spanclass="math inline">\(y\)</span> 假设为一个以 <spanclass="math inline">\(x\)</span> 为变量的线性函数：</p><p><span class="math display">\[h_\theta  (x) = \theta_0 + \theta_1 \times x_1 + \theta_2 \times x_2\]</span></p><p>这里的<spanclass="math inline">\(\theta_i\)</span>是<strong>参数</strong>（也可以叫做<strong>权重</strong>），是从<span class="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span>的线性函数映射的空间参数。在不至于引起混淆的情况下，咱们可以把<spanclass="math inline">\(h_\theta(x)\)</span> 里面的 <spanclass="math inline">\(\theta\)</span> 省略掉，就简写成 <spanclass="math inline">\(h(x)\)</span>。另外为了简化公式，咱们还设 <spanclass="math inline">\(x_0 = 1\)</span>（这个为 <strong>截距项 interceptterm</strong>）。这样简化之后就有了：</p><p><span class="math display">\[h(x) = \sum^n_{i=0}  \theta_i x_i = \theta^T x\]</span></p><p>等式最右边的 <span class="math inline">\(\theta\)</span> 和 <spanclass="math inline">\(x\)</span> 都是向量，等式中的 <spanclass="math inline">\(n\)</span> 是输入变量的个数（不包括<spanclass="math inline">\(x_0\)</span>）。</p><p>现在，给定了一个训练集，咱们怎么来挑选/学习参数 <spanclass="math inline">\(\theta\)</span> 呢？一个看上去比较合理的方法就是让<span class="math inline">\(h(x)\)</span> 尽量逼近 <spanclass="math inline">\(y\)</span>，至少对咱已有的训练样本能适用。用公式的方式来表示的话，就要定义一个函数，来衡量对于每个不同的<span class="math inline">\(\theta\)</span> 值，<spanclass="math inline">\(h(x^{(i)})\)</span> 与对应的 <spanclass="math inline">\(y^{(i)}\)</span>的距离。这样用如下的方式定义了一个 <strong>成本函数 （costfunction</strong>）:</p><p><span class="math display">\[J(\theta) = \frac 12 \sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})^2  \]</span></p><p>如果之前你接触过线性回归，你会发现这个函数和<strong>常规最小二乘法</strong>拟合模型中的最小二乘法成本函数非常相似。不管之前接触过没有，咱们都接着往下进行，以后就会发现这是一个更广泛的算法家族中的一个特例。</p><h4 id="最小均方算法lms-algorithm">1 最小均方算法（LMS algorithm）</h4><p>我们希望选择一个能让 <span class="math inline">\(J(\theta)\)</span>最小的 <span class="math inline">\(\theta\)</span>值。怎么做呢，咱们先用一个搜索的算法，从某一个对 <spanclass="math inline">\(\theta\)</span> 的“初始猜测值”，然后对 <spanclass="math inline">\(\theta\)</span> 值不断进行调整，来让 <spanclass="math inline">\(J(\theta)\)</span>逐渐变小，最好是直到我们能够达到一个使 <spanclass="math inline">\(J(\theta)\)</span> 最小的 <spanclass="math inline">\(\theta\)</span>。具体来说，咱们可以考虑使用梯度下降法（gradientdescent algorithm），这个方法就是从某一个 <spanclass="math inline">\(\theta\)</span>的初始值开始，然后逐渐重复更新：<spanclass="math inline">\(^1\)</span></p><p><span class="math display">\[\theta_j := \theta_j - \alpha \frac \partial {\partial\theta_j}J(\theta)\]</span></p><p>（上面的这个更新要同时对应从 <span class="math inline">\(0\)</span>到 <span class="math inline">\(n\)</span> 的所有<spanclass="math inline">\(j\)</span> 值进行。）这里的 <spanclass="math inline">\(\alpha\)</span>也称为学习速率。这个算法是很自然的，逐步重复朝向 <spanclass="math inline">\(J\)</span> 降低最快的方向移动。</p><blockquote><p>1 本文中 $:= $表示的是计算机程序中的一种赋值操作，是把等号右边的计算结果赋值给左边的变量，<spanclass="math inline">\(a := b\)</span> 就表示用 <spanclass="math inline">\(b\)</span> 的值覆盖原有的<spanclass="math inline">\(a\)</span>值。要注意区分，如果写的是 <spanclass="math inline">\(a == b\)</span>则表示的是判断二者相等的关系。（译者注：在 Python 中，单个等号 <spanclass="math inline">\(=\)</span> 就是赋值，两个等号 <spanclass="math inline">\(==\)</span> 表示相等关系的判断。）</p></blockquote><p>要实现这个算法，咱们需要解决等号右边的导数项。首先来解决只有一组训练样本<span class="math inline">\((x, y)\)</span>的情况，这样就可以忽略掉等号右边对 <spanclass="math inline">\(J\)</span> 的求和项目了。公式就简化下面这样：</p><p><span class="math display">\[\begin{aligned}\frac \partial {\partial\theta_j}J(\theta) &amp; = \frac \partial{\partial\theta_j} \frac  12(h_\theta(x)-y)^2\\&amp; = 2 \cdot\frac 12(h_\theta(x)-y)\cdot \frac \partial{\partial\theta_j}  (h_\theta(x)-y) \\&amp; = (h_\theta(x)-y)\cdot \frac \partial{\partial\theta_j}(\sum^n_{i=0} \theta_ix_i-y) \\&amp; = (h_\theta(x)-y) x_j\end{aligned}\]</span></p><p>对单个训练样本，更新规则如下所示：</p><p><span class="math display">\[\theta_j := \theta_j + \alpha (y^{(i)}-h_\theta (x^{(i)}))x_j^{(i)}\]</span></p><p>这个规则也叫 <strong>LMS</strong> 更新规则 （LMS 是 “least meansquares” 的缩写，意思是最小均方），也被称为 <strong>Widrow-Hoff</strong>学习规则。这个规则有几个看上去就很自然直观的特性。例如，更新的大小与<spanclass="math inline">\((y^{(i)} −h_\theta(x^{(i)}))\)</span>成正比；另外，当我们遇到训练样本的预测值与<span class="math inline">\(y^{(i)}\)</span>的真实值非常接近的情况下，就会发现基本没必要再对参数进行修改了；与此相反的情况是，如果我们的预测值<span class="math inline">\(h_\theta(x^{(i)})\)</span> 与 <spanclass="math inline">\(y^{(i)}\)</span>的真实值有很大的误差（比如距离特别远），那就需要对参数进行更大地调整。</p><p>当只有一个训练样本的时候，我们推导出了 LMS规则。当一个训练集有超过一个训练样本的时候，有两种对这个规则的修改方法。第一种就是下面这个算法：</p>$<span class="math display">\[\begin{aligned}&amp;\qquad 重复直到收敛 \{ \\&amp;\qquad\qquad\theta_j := \theta_j + \alpha\sum^m_{i=1}(y^{(i)}-h_\theta (x^{(i)}))x_j^{(i)}\quad(对每个j) \\&amp;\qquad\}\end{aligned}\]</span><p>$</p><p>读者很容易能证明，在上面这个更新规则中求和项的值就是<spanclass="math inline">\(\frac {\partial J(\theta)}{\partial\theta_j}\)</span> （这是因为对 <span class="math inline">\(J\)</span>的原始定义）。所以这个更新规则实际上就是对原始的成本函数 $J$进行简单的梯度下降。这一方法在每一个步长内检查所有整个训练集中的所有样本，也叫做<strong>批量梯度下降法（batchgradientdescent</strong>）。这里要注意，因为梯度下降法容易被局部最小值影响，而我们要解决的这个线性回归的优化问题只能有一个全局的而不是局部的最优解；因此，梯度下降法应该总是收敛到全局最小值（假设学习速率<span class="math inline">\(\alpha\)</span> 不设置的过大）。<spanclass="math inline">\(J\)</span>很明确是一个凸二次函数。下面是一个样例，其中对一个二次函数使用了梯度下降法来找到最小值。</p><p><img src="/img/cs229note1f3.png" /></p><p>上图的椭圆就是一个二次函数的轮廓图。图中还有梯度下降法生成的规矩，初始点位置在<spanclass="math inline">\((48,30)\)</span>。图中的画的 <spanclass="math inline">\(x\)</span>（用直线连接起来了）标记了梯度下降法所经过的 <spanclass="math inline">\(\theta\)</span> 的可用值。</p><p>对咱们之前的房屋数据集进行批量梯度下降来拟合 <spanclass="math inline">\(\theta\)</span>，把房屋价格当作房屋面积的函数来进行预测，我们得到的结果是 <spanclass="math inline">\(\theta_0 = 71.27, \theta_1 =0.1345\)</span>。如果把 <spanclass="math inline">\(h_{\theta}(x)\)</span> 作为一个定义域在 <spanclass="math inline">\(x\)</span>上的函数来投影，同时也投上训练集中的已有数据点，会得到下面这幅图：</p><p><img src="/img/cs229note1f4.png" /></p><p>如果在数据集中添加上卧室数目作为输入特征，那么得到的结果就是 <spanclass="math inline">\(\theta_0 = 89.60, \theta_1 = 0.1392, \theta_2 =−8.738\)</span></p><p>这个结果就是用批量梯度下降法来获得的。此外还有另外一种方法能够替代批量梯度下降法，这种方法效果也不错。如下所示：</p>$<span class="math display">\[\begin{aligned}&amp;\qquad循环：\{ \\&amp;\qquad\qquad i从1到m,\{   \\&amp;\qquad\qquad\qquad\theta_j :=\theta_j  +\alpha(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)} \qquad(对每个 j)\\&amp;\qquad\qquad\}  \\&amp;\qquad\}\end{aligned}\]</span><p>$</p><p>在这个算法里，我们对整个训练集进行了循环遍历，每次遇到一个训练样本，根据每个单一训练样本的误差梯度来对参数进行更新。这个算法叫做<strong>随机梯度下降法（stochasticgradient descent）</strong>，或者叫<strong>增量梯度下降法（incrementalgradientdescent）</strong>。批量梯度下降法要在运行第一步之前先对整个训练集进行扫描遍历，当训练集的规模<span class="math inline">\(m\)</span>变得很大的时候，引起的性能开销就很不划算了；随机梯度下降法就没有这个问题，而是可以立即开始，对查询到的每个样本都进行运算。通常情况下，随机梯度下降法查找到足够接近最低值的<span class="math inline">\(\theta\)</span>的速度要比批量梯度下降法更快一些。（也要注意，也有可能会一直无法收敛（converge）到最小值，这时候<span class="math inline">\(\theta\)</span> 会一直在 <spanclass="math inline">\(J(\theta)\)</span>最小值附近震荡；不过通常情况下在最小值附近的这些值大多数其实也足够逼近了，足以满足咱们的精度要求，所以也可以用。<spanclass="math inline">\(^2\)</span>）由于这些原因，特别是在训练集很大的情况下，随机梯度下降往往比批量梯度下降更受青睐。</p><blockquote><p>2当然更常见的情况通常是我们事先对数据集已经有了描述，并且有了一个确定的学习速率<spanclass="math inline">\(\alpha\)</span>，然后来运行随机梯度下降，同时逐渐让学习速率<span class="math inline">\(\alpha\)</span> 随着算法的运行而逐渐趋于<spanclass="math inline">\(0\)</span>，这样也能保证我们最后得到的参数会收敛到最小值，而不是在最小值范围进行震荡。（译者注：由于以上种种原因，通常更推荐使用的都是随机梯度下降法，而不是批量梯度下降法，尤其是在训练用的数据集规模大的时候。）</p></blockquote><h4 id="法方程the-normal-equations">2 法方程（The normalequations）</h4><p>上文中的梯度下降法是一种找出 <span class="math inline">\(J\)</span>最小值的办法。然后咱们聊一聊另一种实现方法，这种方法寻找起来简单明了，而且不需要使用迭代算法。这种方法就是，我们直接利用找对应导数为<span class="math inline">\(0\)</span> 位置的 <spanclass="math inline">\(\theta_j\)</span>，这样就能找到 <spanclass="math inline">\(J\)</span>的最小值了。我们想实现这个目的，还不想写一大堆代数公式或者好几页的矩阵积分，所以就要介绍一些做矩阵积分的记号。</p><h5 id="矩阵导数matrix-derivatives">2.1 矩阵导数（Matrixderivatives）</h5><p>假如有一个函数 <span class="math inline">\(f: R^{m\times n} →R\)</span> 从 <span class="math inline">\(m\times n\)</span>大小的矩阵映射到实数域，那么就可以定义当矩阵为 <spanclass="math inline">\(A\)</span> 的时候有导函数 <spanclass="math inline">\(f\)</span> 如下所示：</p><p><span class="math display">\[\nabla_A f(A)=\begin{bmatrix} \frac {\partial f}{\partial A_{11}} &amp;\dots  &amp; \frac {\partial f}{\partial A_{1n}} \\ \vdots  &amp; \ddots&amp; \vdots  \\ \frac {\partial f}{\partial A_{m1}} &amp; \dots  &amp;\frac {\partial f}{\partial A_{mn}} \\ \end{bmatrix}\]</span></p>因此，这个梯度 <span class="math inline">\(\nabla_Af(A)\)</span>本身也是一个 <span class="math inline">\(m\times n\)</span>的矩阵，其中的第 <span class="math inline">\((i,j)\)</span> 个元素是 $ $。 假如 $ A =<span class="math display">\[\begin{bmatrix} A_{11} &amp; A_{12} \\A_{21} &amp; A_{22} \\ \end{bmatrix}\]</span><p>$ 是一个 <span class="math inline">\(2\times 2\)</span>矩阵，然后给定的函数 <span class="math inline">\(f:R^{2\times 2} →R\)</span> 为:</p><p><span class="math display">\[f(A) = \frac 32A_{11}+5A^2_{12}+A_{21}A_{22}\]</span></p><p>这里面的 <span class="math inline">\(A_{ij}\)</span> 表示的意思是矩阵<span class="math inline">\(A\)</span> 的第 <spanclass="math inline">\((i,j)\)</span> 个元素。然后就有了梯度：</p><p><span class="math display">\[\nabla _A f(A) =\begin{bmatrix} \frac  32 &amp; 10A_{12} \\ A_{22} &amp;A_{21} \\ \end{bmatrix}\]</span></p><p>然后咱们还要引入 <strong><spanclass="math inline">\(trace\)</span></strong> 求迹运算，简写为 <spanclass="math inline">\(“tr”\)</span>。对于一个给定的 <spanclass="math inline">\(n\times n\)</span> 方形矩阵 <spanclass="math inline">\(A\)</span>，它的迹定义为对角项和：</p><p><span class="math display">\[trA = \sum^n_{i=1} A_{ii}\]</span></p><p>假如 <span class="math inline">\(a\)</span> 是一个实数，实际上 <spanclass="math inline">\(a\)</span> 就可以看做是一个 <spanclass="math inline">\(1\times 1\)</span> 的矩阵，那么就有 <spanclass="math inline">\(a\)</span> 的迹 <span class="math inline">\(tr a =a\)</span>。(如果你之前没有见到过这个“运算记号”，就可以把 <spanclass="math inline">\(A\)</span> 的迹看成是 <spanclass="math inline">\(tr(A)\)</span>，或者理解成为一个对矩阵 <spanclass="math inline">\(A\)</span> 进行操作的 <spanclass="math inline">\(trace\)</span>函数。不过通常情况都是写成不带括号的形式更多一些。)</p><p>如果有两个矩阵 <span class="math inline">\(A\)</span> 和<spanclass="math inline">\(B\)</span>，能够满足 <spanclass="math inline">\(AB\)</span> 为方阵，<spanclass="math inline">\(trace\)</span> 求迹运算就有一个特殊的性质： <spanclass="math inline">\(trAB = trBA\)</span>(自己想办法证明)。在此基础上进行推论，就能得到类似下面这样的等式关系：</p><p><span class="math display">\[trABC=trCAB=trBCA \\trABCD=trDABC=trCDAB=trBCDA\]</span></p><p>下面这些和求迹运算相关的等量关系也很容易证明。其中 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 都是方形矩阵，<spanclass="math inline">\(a\)</span> 是一个实数：</p><p><span class="math display">\[trA=trA^T \\tr(A+B)=trA+trB \\tr a A=a trA\]</span></p><p>接下来咱们就来在不进行证明的情况下提出一些矩阵导数（其中的一些直到本节末尾才用得上）。另外要注意等式<spanclass="math inline">\((4)\)</span>中的<spanclass="math inline">\(A\)</span> 必须是<strong>非奇异方阵（non-singularsquare matrices</strong>），而 <span class="math inline">\(|A|\)</span>表示的是矩阵 <span class="math inline">\(A\)</span>的行列式。那么我们就有下面这些等量关系：</p><p><span class="math display">\[\begin{aligned}   \nabla_A tr AB &amp; = B^T &amp; \text{(1)}\\   \nabla_{A^T} f(A) &amp; = (\nabla_{A} f(A))^T &amp;\text{(2)}\\   \nabla_A tr ABA^TC&amp; = CAB+C^TAB^T &amp;\text{(3)}\\   \nabla_A|A| &amp; = |A|(A^{-1})^T &amp;\text{(4)}\\\end{aligned}\]</span></p><p>为了让咱们的矩阵运算记号更加具体，咱们就详细解释一下这些等式中的第一个。假如我们有一个确定的矩阵<span class="math inline">\(B \in R^{n\timesm}\)</span>（注意顺序，是<span class="math inline">\(n\timesm\)</span>，这里的意思也就是 <span class="math inline">\(B\)</span>的元素都是实数，<span class="math inline">\(B\)</span> 的形状是 <spanclass="math inline">\(n\times m\)</span>的一个矩阵），那么接下来就可以定义一个函数$ f: R^{mn} → R$，对应这里的就是 <span class="math inline">\(f(A) =trAB\)</span>。这里要注意，这个矩阵是有意义的，因为如果 $A R^{mn}$，那么 <span class="math inline">\(AB\)</span>就是一个方阵，是方阵就可以应用 <spanclass="math inline">\(trace\)</span> 求迹运算；因此，实际上 <spanclass="math inline">\(f\)</span> 映射的是从 $R^{mn} $ 到实数域 <spanclass="math inline">\(R\)</span>。这样接下来就可以使用矩阵导数来找到<span class="math inline">\(\nabla_Af(A)\)</span>，这个导函数本身也是一个 $m n <spanclass="math inline">\(的矩阵。上面的等式\)</span>(1)$表明了这个导数矩阵的第 <spanclass="math inline">\((i,j)\)</span>个元素等同于 <spanclass="math inline">\(B^T\)</span> （<spanclass="math inline">\(B\)</span>的转置）的第 <spanclass="math inline">\((i,j)\)</span> 个元素，或者更直接表示成 <spanclass="math inline">\(B_{ji}\)</span>。</p><p>上面等式<span class="math inline">\((1-3)\)</span>都很简单，证明就都留给读者做练习了。等式<spanclass="math inline">\((4)\)</span>需要用逆矩阵的伴随矩阵来推导出。<spanclass="math inline">\(^3\)</span></p><blockquote><p>3 假如咱们定义一个矩阵 <spanclass="math inline">\(A&#39;\)</span>，它的第 <spanclass="math inline">\((i,j)\)</span> 个元素是$ (−1)^{i+j}$ 与矩阵 $A$移除 第 <span class="math inline">\(i\)</span> 行 和 第 <spanclass="math inline">\(j\)</span> 列之后的行列式的乘积，则可以证明有<span class="math inline">\(A^{−1} =(A&#39;)^T /|A|\)</span>。（你可以检查一下，比如在 <spanclass="math inline">\(A\)</span> 是一个 <spanclass="math inline">\(2\times 2\)</span> 矩阵的情况下看看 <spanclass="math inline">\(A^{-1}\)</span>是什么样的，然后以此类推。如果你想看看对于这一类结果的证明，可以参考一本中级或者高级的线性代数教材，比如CharlesCurtis, 1991, Linear Algebra, Springer。）这也就意味着 $A' =|A|(A<sup>{−1})</sup>T $。此外，一个矩阵 <spanclass="math inline">\(A\)</span> 的行列式也可以写成 <spanclass="math inline">\(|A| = \sum_j A_{ij}A&#39;_{ij}\)</span> 。因为<span class="math inline">\((A&#39;)_{ij}\)</span> 不依赖 <spanclass="math inline">\(A_{ij}\)</span>（通过定义也能看出来），这也就意味着$()|A| = A'_{ij}$，综合起来也就得到上面的这个结果了。</p></blockquote><h5 id="最小二乘法回顾least-squares-revisited">2.2 最小二乘法回顾（Leastsquares revisited）</h5><p>通过刚才的内容，咱们大概掌握了矩阵导数这一工具，接下来咱们就继续用逼近模型（closed-form）来找到能让<span class="math inline">\(J(\theta)\)</span> 最小的 <spanclass="math inline">\(\theta\)</span> 值。首先咱们把 <spanclass="math inline">\(J\)</span> 用矩阵-向量的记号来重新表述。</p><p>给定一个训练集，把<strong>设计矩阵（design matrix）</strong> <spanclass="math inline">\(x\)</span> 设置为一个 <spanclass="math inline">\(m\times n\)</span>矩阵（实际上，如果考虑到截距项，也就是 <spanclass="math inline">\(\theta_0\)</span> 那一项，就应该是 <spanclass="math inline">\(m\times (n+1)\)</span>矩阵），这个矩阵里面包含了训练样本的输入值作为每一行：</p><p><span class="math display">\[X =\begin{bmatrix}-(x^{(1)}) ^T-\\-(x^{(2)}) ^T-\\\vdots \\-(x^{(m)}) ^T-\\\end{bmatrix}\]</span></p><p>然后，咱们设 <span class="math inline">\(\vec{y}\)</span> 是一个<span class="math inline">\(m\)</span> 维向量（m-dimensionalvector），其中包含了训练集中的所有目标值：</p><p><span class="math display">\[y =\begin{bmatrix}y^{(1)}\\y^{(2)}\\\vdots \\y^{(m)}\\\end{bmatrix}\]</span></p><p>因为 $h_(x^{(i)}) =(x<sup>{(i)})</sup>T$<code>译者注：这个怎么推出来的我目前还没尝试，目测不难</code>，所以可以证明存在下面这种等量关系：</p><p><span class="math display">\[\begin{aligned}X\theta - \vec{y}  &amp;=\begin{bmatrix}(x^{(1)})^T\theta \\\vdots \\(x^{(m)})^T\theta\\\end{bmatrix} -\begin{bmatrix}y^{(1)}\\\vdots \\y^{(m)}\\\end{bmatrix}\\&amp; =\begin{bmatrix}h_\theta (x^{1}) -y^{(1)}\\\vdots \\h_\theta (x^{m})-y^{(m)}\\\end{bmatrix}\\\end{aligned}\]</span></p><p>对于向量 <span class="math inline">\(\vec{z}\)</span> ，则有 <spanclass="math inline">\(z^T z = \sum_i z_i^2\)</span>，因此利用这个性质，可以推出:</p><p><span class="math display">\[\begin{aligned}\frac 12(X\theta - \vec{y})^T (X\theta - \vec{y}) &amp;=\frac 12\sum^m_{i=1}(h_\theta (x^{(i)})-y^{(i)})^2\\&amp;= J(\theta)\end{aligned}\]</span></p><p>最后，要让 <span class="math inline">\(J\)</span>的值最小，就要找到函数对于<spanclass="math inline">\(\theta\)</span>导数。结合等式<spanclass="math inline">\((2)\)</span>和等式<spanclass="math inline">\((3)\)</span>，就能得到下面这个等式<spanclass="math inline">\((5)\)</span>：</p><p><span class="math display">\[\nabla_{A^T} trABA^TC =B^TA^TC^T+BA^TC \qquad \text{(5)}\]</span></p><p>因此就有：</p><p><span class="math display">\[\begin{aligned}\nabla_\theta J(\theta) &amp;= \nabla_\theta \frac 12 (X\theta -\vec{y})^T (X\theta - \vec{y}) \\&amp;= \frac  12 \nabla_\theta (\theta ^TX^TX\theta -\theta^T X^T\vec{y} - \vec{y} ^TX\theta +\vec{y}^T \vec{y})\\&amp;= \frac  12 \nabla_\theta tr(\theta ^TX^TX\theta -\theta^T X^T\vec{y} - \vec{y} ^TX\theta +\vec{y}^T \vec{y})\\&amp;= \frac  12 \nabla_\theta (tr \theta ^TX^TX\theta - 2tr\vec{y} ^TX\theta)\\&amp;= \frac  12 (X^TX\theta+X^TX\theta-2X^T\vec{y}) \\&amp;= X^TX\theta-X^T\vec{y}\\\end{aligned}\]</span></p><p>在第三步，我们用到了一个定理，也就是一个实数的迹就是这个实数本身；第四步用到了<span class="math inline">\(trA = trA^T\)</span>这个定理；第五步用到了等式<span class="math inline">\((5)\)</span>，其中<span class="math inline">\(A^T =\theta, B=B^T =X^TX,C=I\)</span>,还用到了等式 <span class="math inline">\((1)\)</span>。要让<span class="math inline">\(J\)</span> 取得最小值，就设导数为 <spanclass="math inline">\(0\)</span>，然后就得到了下面的<strong>法线方程（normal equations）：</strong></p><p><span class="math display">\[X^TX\theta =X^T\vec{y}\]</span></p><p>所以让 <span class="math inline">\(J(\theta)\)</span> 取值最小的<span class="math inline">\(\theta\)</span> 就是</p><p><span class="math display">\[\theta = (X^TX)^{-1}X^T\vec{y}\]</span></p><h4 id="概率解释probabilistic-interpretation">3 概率解释（Probabilisticinterpretation）</h4><p>在面对回归问题的时候，可能有这样一些疑问，就是为什么选择线性回归，尤其是为什么选择最小二乘法作为成本函数<span class="math inline">\(J\)</span>？在本节里，我们会给出一系列的概率基本假设，基于这些假设，就可以推出最小二乘法回归是一种非常自然的算法。</p><p>首先咱们假设目标变量和输入值存在下面这种等量关系：</p><p><span class="math display">\[y^{(i)}=\theta^T x^{(i)}+ \epsilon ^{(i)}\]</span></p><p>上式中 $ ^{(i)}$ 是误差项，用于存放由于建模所忽略的变量导致的效果（比如可能某些特征对于房价的影响很明显，但我们做回归的时候忽略掉了）或者随机的噪音信息（randomnoise）。进一步假设 $ ^{(i)}$ 是独立同分布的 (IID ，independently andidentically distributed) ，服从高斯分布（Gaussian distribution，也叫正态分布 Normal distribution），其平均值为 <spanclass="math inline">\(0\)</span>，方差（variance）为 <spanclass="math inline">\(\sigma ^2\)</span>。这样就可以把这个假设写成 $^{(i)} ∼ N (0, ^2)$ 。然后 $ ^{(i)} $ 的密度函数就是：</p><p><span class="math display">\[p(\epsilon ^{(i)} )= \frac 1{\sqrt{2\pi}\sigma} exp (- \frac  {(\epsilon^{(i)} )^2}{2\sigma^2})\]</span></p><p>这意味着存在下面的等量关系：</p><p><span class="math display">\[p(y ^{(i)} |x^{(i)}; \theta)= \frac 1{\sqrt{2\pi}\sigma} exp (-\frac  {(y^{(i)} -\theta^T x ^{(i)} )^2}{2\sigma^2})\]</span></p><p>这里的记号 <span class="math inline">\(“p(y ^{(i)} |x^{(i)};\theta)”\)</span> 表示的是这是一个对于给定 <spanclass="math inline">\(x^{(i)}\)</span> 时 <spanclass="math inline">\(y^{(i)}\)</span> 的分布，用<spanclass="math inline">\(\theta\)</span> 代表该分布的参数。 注意这里不能用<span class="math inline">\(\theta(“p(y ^{(i)}|x^{(i)},\theta)”)\)</span>来当做条件，因为 <spanclass="math inline">\(\theta\)</span> 并不是一个随机变量。这个 <spanclass="math inline">\(y^{(i)}\)</span> 的分布还可以写成<spanclass="math inline">\(y^{(i)} | x^{(i)}; \theta ∼ N (\theta ^T x^{(i)},\sigma^2)\)</span>。</p><p>给定一个设计矩阵（design matrix）<spanclass="math inline">\(X\)</span>，其包含了所有的<spanclass="math inline">\(x^{(i)}\)</span>，然后再给定 <spanclass="math inline">\(\theta\)</span>，那么 <spanclass="math inline">\(y^{(i)}\)</span> 的分布是什么？数据的概率以<spanclass="math inline">\(p (\vec{y}|X;\theta )\)</span> 的形式给出。在<spanclass="math inline">\(\theta\)</span>取某个固定值的情况下，这个等式通常可以看做是一个<span class="math inline">\(\vec{y}\)</span> 的函数（也可以看成是 <spanclass="math inline">\(X\)</span> 的函数）。当我们要把它当做 <spanclass="math inline">\(\theta\)</span> 的函数的时候，就称它为<strong>似然</strong>函数（likelihood function)</p><p><span class="math display">\[L(\theta) =L(\theta;X,\vec{y})=p(\vec{y}|X;\theta)\]</span></p><p>结合之前对 <span class="math inline">\(\epsilon^{(i)}\)</span>的独立性假设 （这里对<span class="math inline">\(y^{(i)}\)</span>以及给定的 <span class="math inline">\(x^{(i)}\)</span>也都做同样假设），就可以把上面这个等式改写成下面的形式：</p><p><span class="math display">\[\begin{aligned}L(\theta) &amp;=\prod ^m _{i=1}p(y^{(i)}|x^{(i)};\theta)\\&amp;=\prod ^m _{i=1} \frac  1{\sqrt{2\pi}\sigma} exp(- \frac{(y^{(i)}-\theta^T x^{(i)})^2}{2\sigma^2})\\\end{aligned}\]</span></p><p>现在，给定了<span class="math inline">\(y^{(i)}\)</span> 和 <spanclass="math inline">\(x^{(i)}\)</span>之间关系的概率模型了，用什么方法来选择咱们对参数<span class="math inline">\(\theta\)</span>的最佳猜测呢？最大似然法（maximumlikelihood）告诉我们要选择能让数据的似然函数尽可能大的 <spanclass="math inline">\(\theta\)</span>。也就是说，咱们要找的 <spanclass="math inline">\(\theta\)</span> 能够让函数 <spanclass="math inline">\(L(\theta)\)</span> 取到最大值。</p><p>除了找到 <span class="math inline">\(L(\theta)\)</span>最大值，我们还以对任何严格递增的 <spanclass="math inline">\(L(\theta)\)</span>的函数求最大值。如果我们不直接使用 <spanclass="math inline">\(L(\theta)\)</span>，而是使用对数函数，来找<strong>对数似然函数<span class="math inline">\(l(\theta)\)</span></strong>的最大值，那这样对于求导来说就简单了一些：</p><p><span class="math display">\[\begin{aligned}l(\theta) &amp;=\log L(\theta)\\&amp;=\log \prod ^m _{i=1} \frac  1{\sqrt{2\pi}\sigma} exp(- \frac{(y^{(i)}-\theta^T x^{(i)})^2}{2\sigma^2})\\&amp;= \sum ^m _{i=1}log \frac  1{\sqrt{2\pi}\sigma} exp(- \frac{(y^{(i)}-\theta^T x^{(i)})^2}{2\sigma^2})\\&amp;= m \log \frac  1{\sqrt{2\pi}\sigma}- \frac 1{\sigma^2}\cdot \frac12 \sum^m_{i=1} (y^{(i)}-\theta^Tx^{(i)})^2\\\end{aligned}\]</span></p><p>因此，对 <span class="math inline">\(l(\theta)\)</span>取得最大值也就意味着下面这个子式取到最小值：</p><p><span class="math display">\[\frac 12 \sum^m _{i=1} (y^{(i)}-\theta^Tx^{(i)})^2\]</span></p><p>到这里我们能发现这个子式实际上就是 <spanclass="math inline">\(J(\theta)\)</span>，也就是最原始的最小二乘成本函数（least-squarescost function）。</p><p>总结一下也就是：在对数据进行概率假设的基础上，最小二乘回归得到的<span class="math inline">\(\theta\)</span> 和最大似然法估计的 <spanclass="math inline">\(\theta\)</span>是一致的。所以这是一系列的假设，其前提是认为最小二乘回归（least-squaresregression）能够被判定为一种非常自然的方法，这种方法正好就进行了最大似然估计（maximumlikelihoodestimation）。（要注意，对于验证最小二乘法是否为一个良好并且合理的过程来说，这些概率假设并不是必须的，此外可能（也确实）有其他的自然假设能够用来评判最小二乘方法。）</p><p>另外还要注意，在刚才的讨论中，我们最终对 <spanclass="math inline">\(\theta\)</span> 的选择并不依赖 <spanclass="math inline">\(\sigma^2\)</span>，而且也确实在不知道 <spanclass="math inline">\(\sigma^2\)</span>的情况下就已经找到了结果。稍后我们还要对这个情况加以利用，到时候我们会讨论指数族以及广义线性模型。</p><h4 id="局部加权线性回归locally-weighted-linear-regression">4局部加权线性回归（Locally weighted linear regression）</h4><p>假如问题还是根据从实数域内取值的 <span class="math inline">\(x\inR\)</span> 来预测 <span class="math inline">\(y\)</span>。左下角的图显示了使用 <span class="math inline">\(y = \theta_0 +\theta_1x\)</span>来对一个数据集进行拟合。我们明显能看出来这个数据的趋势并不是一条严格的直线，所以用直线进行的拟合就不是好的方法。</p><p><img src="/img/cs229note1f5.png" /></p><p>那么这次不用直线，而增加一个二次项，用<span class="math inline">\(y =\theta_0 + \theta_1x +\theta_2x^2\)</span> 来拟合。（看中间的图）很明显，我们对特征补充得越多，效果就越好。不过，增加太多特征也会造成危险的：最右边的图就是使用了五次多项式<span class="math inline">\(y = \sum^5_{j=0} \theta_jx^j\)</span>来进行拟合。看图就能发现，虽然这个拟合曲线完美地通过了所有当前数据集中的数据，但我们明显不能认为这个曲线是一个合适的预测工具，比如针对不同的居住面积<span class="math inline">\(x\)</span> 来预测房屋价格 <spanclass="math inline">\(y\)</span>。先不说这些特殊名词的正规定义，咱们就简单说，最左边的图像就是一个<strong>欠拟合(underfitting)</strong>的例子，比如明显能看出拟合的模型漏掉了数据集中的结构信息；而最右边的图像就是一个<strong>过拟合(overfitting)</strong>的例子。（在本课程的后续部分中，当我们讨论到关于学习理论的时候，会给出这些概念的标准定义，也会给出拟合程度对于一个猜测的好坏检验的意义。）</p><p>正如前文谈到的，也正如上面这个例子展示的，一个学习算法要保证能良好运行，特征的选择是非常重要的。（等到我们讲模型选择的时候，还会看到一些算法能够自动来选择一个良好的特征集。）在本节，咱们就简要地讲一下局部加权线性回归（locallyweighted linear regression，缩写为LWR），这个方法是假设有足够多的训练数据，对不太重要的特征进行一些筛选。这部分内容会比较简略，因为在作业中要求学生自己去探索一下LWR算法的各种性质了。</p><p>在原始版本的线性回归算法中，要对一个查询点 <spanclass="math inline">\(x\)</span> 进行预测，比如要衡量<spanclass="math inline">\(h(x)\)</span>，要经过下面的步骤：</p><ol type="1"><li>使用参数 <span class="math inline">\(\theta\)</span>进行拟合，让数据集中的值与拟合算出的值的差值平方<spanclass="math inline">\(\sum_i(y^{(i)} − \theta^T x^{(i)})^2\)</span>最小(最小二乘法的思想)；</li><li>输出 <span class="math inline">\(\theta^T x\)</span> 。</li></ol><p>相应地，在 LWR 局部加权线性回归方法中，步骤如下：</p><ol type="1"><li>使用参数 <span class="math inline">\(\theta\)</span>进行拟合，让加权距离<span class="math inline">\(\sum_i w^{(i)}(y^{(i)} −\theta^T x^{(i)} )^2\)</span> 最小；</li><li>输出 <span class="math inline">\(\theta^T x\)</span>。</li></ol><p>上面式子中的 <span class="math inline">\(w^{(i)}\)</span>是非负的权值。直观点说就是，如果对应某个<spanclass="math inline">\(i\)</span> 的权值 <spanclass="math inline">\(w^{(i)}\)</span> 特别大，那么在选择拟合参数 <spanclass="math inline">\(\theta\)</span> 的时候，就要尽量让这一点的 <spanclass="math inline">\((y^{(i)} − \theta^T x^{(i)} )^2\)</span>最小。而如果权值<span class="math inline">\(w^{(i)}\)</span>特别小，那么这一点对应的<span class="math inline">\((y^{(i)} − \theta^Tx^{(i)} )^2\)</span> 就基本在拟合过程中忽略掉了。</p><p>对于权值的选取可以使用下面这个比较标准的公式：<spanclass="math inline">\(^4\)</span></p><p><span class="math display">\[w^{(i)} = exp(- \frac {(x^{(i)}-x)^2}{2\tau^2})\]</span></p><blockquote><p>4 如果 <span class="math inline">\(x\)</span>是有值的向量，那就要对上面的式子进行泛化，得到的是<spanclass="math inline">\(w^{(i)} = exp(− \frac{(x^{(i)}-x)^T(x^{(i)}-x)}{2\tau^2})\)</span>，或者:<spanclass="math inline">\(w^{(i)} = exp(− \frac {(x^{(i)}-x)^T\Sigma^{-1}(x^{(i)}-x)}{2})\)</span>，这就看是选择用<spanclass="math inline">\(\tau\)</span> 还是 <spanclass="math inline">\(\Sigma\)</span>。</p></blockquote><p>要注意的是，权值是依赖每个特定的点 <spanclass="math inline">\(x\)</span>的，而这些点正是我们要去进行预测评估的点。此外，如果 <spanclass="math inline">\(|x^{(i)} − x|\)</span> 非常小，那么权值 $w^{(i)}$就接近 <span class="math inline">\(1\)</span>；反之如果 <spanclass="math inline">\(|x^{(i)} − x|\)</span> 非常大，那么权值 $w^{(i)}$就变小。所以可以看出， <span class="math inline">\(\theta\)</span>的选择过程中，查询点 <span class="math inline">\(x\)</span>附近的训练样本有更高得多的权值。（<spanclass="math inline">\(\theta\)</span>is chosen giving a much higher“weight” to the (errors on) training examples close to the query pointx.）（还要注意，当权值的方程的形式跟高斯分布的密度函数比较接近的时候，权值和高斯分布并没有什么直接联系，尤其是当权值不是随机值，且呈现正态分布或者其他形式分布的时候。）随着点$x^{(i)}$ 到查询点 <span class="math inline">\(x\)</span>的距离降低，训练样本的权值的也在降低，参数<spanclass="math inline">\(\tau\)</span> 控制了这个降低的速度；<spanclass="math inline">\(\tau\)</span>也叫做<strong>带宽参数</strong>，这个也是在你的作业中需要来体验和尝试的一个参数。</p><p>局部加权线性回归是咱们接触的第一个<strong>非参数</strong>算法。而更早之前咱们看到的无权重的线性回归算法就是一种<strong>参数</strong>学习算法，因为有固定的有限个数的参数（也就是 <spanclass="math inline">\(\theta_i\)</span> ），这些参数用来拟合数据。我们对<span class="math inline">\(\theta_i\)</span>进行了拟合之后，就把它们存了起来，也就不需要再保留训练数据样本来进行更进一步的预测了。与之相反，如果用局部加权线性回归算法，我们就必须一直保留着整个训练集。这里的非参数算法中的非参数“non-parametric” 是粗略地指：为了呈现出假设 <spanclass="math inline">\(h\)</span>随着数据集规模的增长而线性增长，我们需要以一定顺序保存一些数据的规模。（Theterm “non-parametric” (roughly) refers to the fact that the amount ofstuff we need to keep in order to represent the hypothesis h growslinearly with the size of the training set. ）</p><h3id="第二部分-分类和逻辑回归classification-and-logistic-regression">第二部分分类和逻辑回归（Classification and logistic regression）</h3><p>接下来咱们讲一下分类的问题。分类问题其实和回归问题很像，只不过我们现在要来预测的<span class="math inline">\(y\)</span>的值只局限于少数的若干个离散值。眼下咱们首先关注的是<strong>二值化分类</strong>问题，也就是说咱们要判断的 <span class="math inline">\(y\)</span>只有两个取值，<span class="math inline">\(0\)</span> 或者 <spanclass="math inline">\(1\)</span>。（咱们这里谈到的大部分内容也都可以扩展到多种类的情况。）例如，假如要建立一个垃圾邮件筛选器，那么就可以用<span class="math inline">\(x^{(i)}\)</span>表示一个邮件中的若干特征，然后如果这个邮件是垃圾邮件，<spanclass="math inline">\(y\)</span> 就设为<spanclass="math inline">\(1\)</span>，否则 <spanclass="math inline">\(y\)</span> 为 <spanclass="math inline">\(0\)</span>。<span class="math inline">\(0\)</span>也可以被称为<strong>消极类别（negative class）</strong>，而 <spanclass="math inline">\(1\)</span> 就成为<strong>积极类别（positiveclass</strong>），有的情况下也分别表示成“-” 和 “+”。对于给定的一个 <spanclass="math inline">\(x^{(i)}\)</span>，对应的<spanclass="math inline">\(y^{(i)}\)</span>也称为训练样本的<strong>标签（label）</strong>。</p><h4 id="逻辑回归logistic-regression">5 逻辑回归（Logisticregression）</h4><p>我们当然也可以还按照之前的线性回归的算法来根据给定的 <spanclass="math inline">\(x\)</span> 来预测 <spanclass="math inline">\(y\)</span>，只要忽略掉 <spanclass="math inline">\(y\)</span>是一个散列值就可以了。然而，这样构建的例子很容易遇到性能问题，这个方法运行效率会非常低，效果很差。而且从直观上来看，<spanclass="math inline">\(h_\theta(x)\)</span> 的值如果大于<spanclass="math inline">\(1\)</span> 或者小于<spanclass="math inline">\(0\)</span>就都没有意义了，因为咱们已经实现都确定了 <span class="math inline">\(y\in \{0, 1\}\)</span>，就是说 <span class="math inline">\(y\)</span>必然应当是 <span class="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span> 这两个值当中的一个。</p><p>所以咱们就改变一下假设函数<span class="math inline">\(h_\theta(x)\)</span> 的形式，来解决这个问题。比如咱们可以选择下面这个函数：</p><p><span class="math display">\[h_\theta(x) = g(\theta^T x) = \frac  1{1+e^{-\theta^Tx}}\]</span></p><p>其中有：</p><p><span class="math display">\[g(z)= \frac 1 {1+e^{-z}}\]</span></p><p>这个函数叫做<strong>逻辑函数 （Logistic function）</strong>，或者也叫<strong>双弯曲S型函数（sigmoid function</strong>）。下图是<span class="math inline">\(g(z)\)</span> 的函数图像：</p><p><img src="/img/cs229note1f6.png" /></p><p>注意到没有，当<span class="math inline">\(z\to +\infty\)</span>的时候 <span class="math inline">\(g(z)\)</span> 趋向于<spanclass="math inline">\(1\)</span>，而当<span class="math inline">\(z\to-\infty\)</span> 时<span class="math inline">\(g(z)\)</span> 趋向于<spanclass="math inline">\(0\)</span>。此外，这里的这个 <spanclass="math inline">\(g(z)\)</span> ，也就是 <spanclass="math inline">\(h(x)\)</span>，是一直在 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(1\)</span>之间波动的。然后咱们依然像最开始那样来设置 <spanclass="math inline">\(x_0 = 1\)</span>，这样就有了：<spanclass="math inline">\(\theta^T x =\theta_0+\sum^n_{j=1}\theta_jx_j\)</span></p><p>现在咱们就把 <span class="math inline">\(g\)</span>作为选定的函数了。当然其他的从<spanclass="math inline">\(0\)</span>到<spanclass="math inline">\(1\)</span>之间光滑递增的函数也可以使用，不过后面我们会了解到选择<span class="math inline">\(g\)</span>的一些原因（到时候我们讲广义线性模型GLMs，那时候还会讲生成学习算法，generative learningalgorithms），对这个逻辑函数的选择是很自然的。再继续深入之前，下面是要讲解的关于这个S 型函数的导数，也就是 <span class="math inline">\(g&#39;\)</span>的一些性质：</p><p><span class="math display">\[\begin{aligned}g&#39;(z) &amp; = \frac d{dz}\frac 1{1+e^{-z}}\\&amp; = \frac  1{(1+e^{-z})^2}(e^{-z})\\&amp; = \frac  1{(1+e^{-z})} \cdot (1- \frac 1{(1+e^{-z})})\\&amp; = g(z)(1-g(z))\\\end{aligned}\]</span></p><p>那么，给定了逻辑回归模型了，咱们怎么去拟合一个合适的 <spanclass="math inline">\(\theta\)</span>呢？我们之前已经看到了在一系列假设的前提下，最小二乘法回归可以通过最大似然估计来推出，那么接下来就给我们的这个分类模型做一系列的统计学假设，然后用最大似然法来拟合参数吧。</p><p>首先假设：</p><p><span class="math display">\[\begin{aligned}P(y=1|x;\theta)&amp;=h_{\theta}(x)\\P(y=0|x;\theta)&amp;=1- h_{\theta}(x)\\\end{aligned}\]</span></p><p>更简洁的写法是：</p><p><span class="math display">\[p(y|x;\theta)=(h_\theta (x))^y(1- h_\theta (x))^{1-y}\]</span></p><p>假设 <span class="math inline">\(m\)</span>个训练样本都是各自独立生成的，那么就可以按如下的方式来写参数的似然函数：</p><p><span class="math display">\[\begin{aligned}L(\theta) &amp;= p(\vec{y}| X; \theta)\\&amp;= \prod^m_{i=1}  p(y^{(i)}| x^{(i)}; \theta)\\&amp;= \prod^m_{i=1} (h_\theta (x^{(i)}))^{y^{(i)}}(1-h_\theta(x^{(i)}))^{1-y^{(i)}} \\\end{aligned}\]</span></p><p>然后还是跟之前一样，取个对数就更容易计算最大值：</p><p><span class="math display">\[\begin{aligned}l(\theta) &amp;=\log L(\theta) \\&amp;= \sum^m_{i=1} y^{(i)} \log h(x^{(i)})+(1-y^{(i)})\log(1-h(x^{(i)}))\end{aligned}\]</span></p><p>怎么让似然函数最大？就跟之前咱们在线性回归的时候用了求导数的方法类似，咱们这次就是用<strong>梯度上升法（gradientascent）</strong>。还是写成向量的形式，然后进行更新，也就是$ := +_l()$。<code>(注意更新方程中用的是加号而不是减号，因为我们现在是在找一个函数的最大值，而不是找最小值了。)</code>还是先从只有一组训练样本<span class="math inline">\((x,y)\)</span>来开始，然后求导数来推出随机梯度上升规则：</p><p><span class="math display">\[\begin{aligned}\frac  {\partial}{\partial \theta_j} l(\theta) &amp;=(y\frac  1{g(\theta ^T x)}  - (1-y)\frac  1 {1- g(\theta ^Tx)}   )\frac  {\partial}{\partial \theta_j}g(\theta ^Tx) \\&amp;= (y\frac  1 {g(\theta ^T x)}  - (1-y)\frac  1 {1- g(\theta ^Tx)}   )  g(\theta^Tx)(1-g(\theta^Tx)) \frac  {\partial}{\partial\theta_j}\theta ^Tx \\&amp;= (y(1-g(\theta^Tx) ) -(1-y) g(\theta^Tx)) x_j\\&amp;= (y-h_\theta(x))x_j\end{aligned}\]</span></p><p>上面的式子里，我们用到了对函数求导的定理 $ g'(z)= g(z)(1-g(z))$。然后就得到了随机梯度上升规则：</p><p><span class="math display">\[\theta_j := \theta_j + \alpha (y^{(i)}-h_\theta (x^{(i)}))x_j^{(i)}\]</span></p><p>如果跟之前的 LMS更新规则相对比，就能发现看上去挺相似的；不过这并不是同一个算法，因为这里的<spanclass="math inline">\(h_\theta(x^{(i)})\)</span>现在定义成了一个 <spanclass="math inline">\(\theta^Tx^{(i)}\)</span>的非线性函数。尽管如此，我们面对不同的学习问题使用了不同的算法，却得到了看上去一样的更新规则，这个还是有点让人吃惊。这是一个巧合么，还是背后有更深层次的原因呢？在我们学到了GLM 广义线性模型的时候就会得到答案了。（另外也可以看一下 习题集1 里面 Q3的附加题。）</p><h4 id="题外话-感知器学习算法the-perceptron-learning-algorithm">6题外话: 感知器学习算法（The perceptron learning algorithm）</h4><p>现在咱们来岔开一下话题，简要地聊一个算法，这个算法的历史很有趣，并且之后在我们讲学习理论的时候还要讲到它。设想一下，对逻辑回归方法修改一下，“强迫”它输出的值要么是<span class="math inline">\(0\)</span> 要么是 <spanclass="math inline">\(1\)</span>。要实现这个目的，很自然就应该把函数<span class="math inline">\(g\)</span>的定义修改一下，改成一个<strong>阈值函数（thresholdfunction）</strong>：</p><p><span class="math display">\[g(z)= \begin{cases} 1 &amp;  if\quad z \geq 0  \\0 &amp;  if\quad z &lt; 0  \end{cases}\]</span></p><p>如果我们还像之前一样令 <span class="math inline">\(h_\theta(x) =g(\theta^T x)\)</span>，但用刚刚上面的阈值函数作为 <spanclass="math inline">\(g\)</span>的定义，然后如果我们用了下面的更新规则：</p><p><span class="math display">\[\theta_j := \theta_j +\alpha(y^{(i)}-h_\theta (x^{(i)}))x_j^{(i)}\]</span></p><p>这样我们就得到了<strong>感知器学习算法。</strong></p><p>在 1960年代，这个“感知器（perceptron）”被认为是对大脑中单个神经元工作方法的一个粗略建模。鉴于这个算法的简单程度，这个算法也是我们后续在本课程中讲学习理论的时候的起点。但一定要注意，虽然这个感知器学习算法可能看上去表面上跟我们之前讲的其他算法挺相似，但实际上这是一个和逻辑回归以及最小二乘线性回归等算法在种类上都完全不同的算法；尤其重要的是，很难对感知器的预测赋予有意义的概率解释，也很难作为一种最大似然估计算法来推出感知器学习算法。</p><h4 id="让ltheta-取最大值的另外一个算法">7 让<spanclass="math inline">\(l(\theta)\)</span> 取最大值的另外一个算法</h4><p>再回到用 S 型函数 <span class="math inline">\(g(z)\)</span>来进行逻辑回归的情况，咱们来讲一个让 <spanclass="math inline">\(l(\theta)\)</span> 取最大值的另一个算法。</p><p>开始之前，咱们先想一下求一个方程零点的牛顿法。假如我们有一个从实数到实数的函数<span class="math inline">\(f:R \to R\)</span>，然后要找到一个 <spanclass="math inline">\(\theta\)</span> ，来满足 <spanclass="math inline">\(f(\theta)=0\)</span>，其中 <spanclass="math inline">\(\theta\in R\)</span> 是一个实数。牛顿法就是对<span class="math inline">\(\theta\)</span> 进行如下的更新：</p><p><span class="math display">\[\theta := \theta - \frac {f(\theta)}{f&#39;(\theta)}\]</span></p><p>这个方法可以通过一个很自然的解释，我们可以把它理解成用一个线性函数来对函数<span class="math inline">\(f\)</span> 进行逼近，这条直线是 <spanclass="math inline">\(f\)</span> 的切线，而猜测值是 <spanclass="math inline">\(\theta\)</span>，解的方法就是找到线性方程等于零的点，把这一个零点作为<span class="math inline">\(\theta\)</span>设置给下一次猜测，然后以此类推。</p><p>下面是对牛顿法的图解： <img src="/img/cs229note1f7.png" /></p><p>在最左边的图里面，可以看到函数 <span class="math inline">\(f\)</span>就是沿着 <span class="math inline">\(y=0\)</span>的一条直线。这时候是想要找一个 <spanclass="math inline">\(\theta\)</span> 来让 <spanclass="math inline">\(f(\theta)=0\)</span>。这时候发现这个 <spanclass="math inline">\(\theta\)</span> 值大概在 <spanclass="math inline">\(1.3\)</span> 左右。加入咱们猜测的初始值设定为<span class="math inline">\(\theta=4.5\)</span>。牛顿法就是在 <spanclass="math inline">\(\theta=4.5\)</span>这个位置画一条切线（中间的图）。这样就给出了下一个 <spanclass="math inline">\(\theta\)</span>猜测值的位置，也就是这个切线的零点，大概是<spanclass="math inline">\(2.8\)</span>。最右面的图中的是再运行一次这个迭代产生的结果，这时候<span class="math inline">\(\theta\)</span> 大概是<spanclass="math inline">\(1.8\)</span>。就这样几次迭代之后，很快就能接近<span class="math inline">\(\theta=1.3\)</span>。</p><p>牛顿法的给出的解决思路是让 <span class="math inline">\(f(\theta) =0\)</span> 。如果咱们要用它来让函数 <spanclass="math inline">\(l\)</span> 取得最大值能不能行呢？函数 <spanclass="math inline">\(l\)</span> 的最大值的点应该对应着是它的导数<spanclass="math inline">\(l&#39;(\theta)\)</span>等于零的点。所以通过令<span class="math inline">\(f(\theta) =l&#39;(\theta)\)</span>，咱们就可以同样用牛顿法来找到 <spanclass="math inline">\(l\)</span> 的最大值，然后得到下面的更新规则：</p><p><span class="math display">\[\theta := \theta - \frac {l&#39;(\theta)}{l&#39;&#39;(\theta)}\]</span></p><p>（扩展一下，额外再思考一下:如果咱们要用牛顿法来求一个函数的最小值而不是最大值，该怎么修改？）<code>译者注：试试法线的零点</code></p><p>最后，在咱们的逻辑回归背景中，<spanclass="math inline">\(\theta\)</span>是一个有值的向量，所以我们要对牛顿法进行扩展来适应这个情况。牛顿法进行扩展到多维情况，也叫牛顿-拉普森法（Newton-Raphsonmethod），如下所示：</p><p><span class="math display">\[\theta := \theta - H^{-1}\nabla_\theta l(\theta)\]</span></p><p>上面这个式子中的 <span class="math inline">\(\nabla_\thetal(\theta)\)</span>和之前的样例中的类似，是关于 <spanclass="math inline">\(\theta_i\)</span> 的 <spanclass="math inline">\(l(\theta)\)</span> 的偏导数向量；而 <spanclass="math inline">\(h\)</span> 是一个 <spanclass="math inline">\(n\times n\)</span> 矩阵,实际上如果包含截距项的话，应该是, <span class="math inline">\((n +1)\times (n + 1)\)</span>，也叫做 Hessian, 其详细定义是：</p><p><span class="math display">\[H_{ij}= \frac {\partial^2 l(\theta)}{\partial \theta_i \partial\theta_j}\]</span></p><p>牛顿法通常都能比（批量）梯度下降法收敛得更快，而且达到最小值所需要的迭代次数也低很多。然而，牛顿法中的单次迭代往往要比梯度下降法的单步耗费更多的性能开销，因为要查找和转换一个<span class="math inline">\(n\times n\)</span>的 Hessian矩阵；不过只要这个 <span class="math inline">\(n\)</span>不是太大，牛顿法通常就还是更快一些。当用牛顿法来在逻辑回归中求似然函数<spanclass="math inline">\(l(\theta)\)</span>的最大值的时候，得到这一结果的方法也叫做<strong>Fisher评分（Fisherscoring）。</strong></p><h3 id="第三部分-广义线性模型-generalized-linear-models5">第三部分广义线性模型 (Generalized Linear Models)<spanclass="math inline">\(^5\)</span></h3><blockquote><p>5 本节展示的内容受以下两份作品的启发：Michael I. Jordan, Learning ingraphical models (unpublished book draft), 以及 McCullagh and Nelder,Generalized Linear Models (2nd ed.)。</p></blockquote><p>到目前为止，我们看过了回归的案例，也看了一个分类案例。在回归的案例中，我们得到的函数是<span class="math inline">\(y|x; \theta ∼ N (\mu,\sigma^2)\)</span>；而分类的案例中，函数是 <spanclass="math inline">\(y|x; \theta ∼Bernoulli(\phi)\)</span>，这里面的<spanclass="math inline">\(\mu\)</span> 和 <spanclass="math inline">\(\phi\)</span> 分别是 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(\theta\)</span>的某种函数。在本节，我们会发现这两种方法都是一个更广泛使用的模型的特例，这种更广泛使用的模型就叫做广义线性模型。我们还会讲一下广义线性模型中的其他模型是如何推出的，以及如何应用到其他的分类和回归问题上。</p><h4 id="指数族-the-exponential-family">8 指数族 (The exponentialfamily)</h4><p>在学习 GLMs 之前，我们要先定义一下指数组分布（exponential familydistributions）。如果一个分布能用下面的方式来写出来，我们就说这类分布属于指数族：</p><p><span class="math display">\[p(y;\eta) =b(y)exp(\eta^TT(y)-a(\eta)) \qquad \text{(6)}\]</span></p><p>上面的式子中，<span class="math inline">\(\eta\)</span>叫做此分布的<strong>自然参数</strong> （naturalparameter，也叫<strong>典范参数 canonical parameter</strong>） ； <spanclass="math inline">\(T(y)\)</span> 叫做<strong>充分统计量（sufficientstatistic）</strong> ，我们目前用的这些分布中通常 <spanclass="math inline">\(T (y) = y\)</span>；而 <spanclass="math inline">\(a(\eta)\)</span> 是一个<strong>对数分割函数（logpartition function）。</strong> <spanclass="math inline">\(e^{−a(\eta)}\)</span>这个量本质上扮演了归一化常数（normalization constant）的角色，也就是确保<span class="math inline">\(p(y; \eta)\)</span> 的总和或者积分等于<spanclass="math inline">\(1\)</span>。</p><p>当给定 <span class="math inline">\(T\)</span>, <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 时，就定义了一个用 <spanclass="math inline">\(\eta\)</span> 进行参数化的分布族（family，或者叫集set）；通过改变 <spanclass="math inline">\(\eta\)</span>，我们就能得到这个分布族中的不同分布。</p><p>现在咱们看到的伯努利（Bernoulli）分布和高斯（Gaussian）分布就都属于指数分布族。伯努利分布的均值是<spanclass="math inline">\(\phi\)</span>，也写作 <spanclass="math inline">\(Bernoulli(\phi)\)</span>，确定的分布是 <spanclass="math inline">\(y \in \{0, 1\}\)</span>，因此有 <spanclass="math inline">\(p(y = 1; \phi) = \phi\)</span>; <spanclass="math inline">\(p(y = 0;\phi) =1−\phi\)</span>。这时候只要修改<spanclass="math inline">\(\phi\)</span>，就能得到一系列不同均值的伯努利分布了。现在我们展示的通过修改<spanclass="math inline">\(\phi\)</span>,而得到的这种伯努利分布，就属于指数分布族；也就是说，只要给定一组<span class="math inline">\(T\)</span>，<spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>，就可以用上面的等式<spanclass="math inline">\((6)\)</span>来确定一组特定的伯努利分布了。</p><p>我们这样来写伯努利分布：</p><p><span class="math display">\[\begin{aligned}p(y;\phi) &amp; = \phi ^y(1-\phi)^{1-y}\\&amp; = exp(y \log \phi + (1-y)\log(1-\phi))\\&amp; = exp( (log (\frac {\phi}{1-\phi}))y+\log (1-\phi) )\\\end{aligned}\]</span></p><p>因此，自然参数（natural parameter）就给出了，即 <spanclass="math inline">\(\eta = log (\frac   \phi {1 − \phi})\)</span>。很有趣的是，如果我们翻转这个定义，用<spanclass="math inline">\(\eta\)</span> 来解 <spanclass="math inline">\(\phi\)</span> 就会得到 <spanclass="math inline">\(\phi = 1/ (1 + e^{−\eta})\)</span>。这正好就是之前我们刚刚见到过的 S型函数(sigmoidfunction)！在我们把逻辑回归作为一种广义线性模型（GLM）的时候还会得到：</p><p><span class="math display">\[\begin{aligned}T(y) &amp;= y \\a( \eta) &amp; = - \log (1- \phi) \\&amp; = \log {(1+ e^ \eta)}\\b(y)&amp;=1\end{aligned}\]</span></p><p>上面这组式子就表明了伯努利分布可以写成等式<spanclass="math inline">\((6)\)</span>的形式，使用一组合适的<spanclass="math inline">\(T\)</span>, <span class="math inline">\(a\)</span>和 <span class="math inline">\(b\)</span>。</p><p>接下来就看看高斯分布吧。还记得吧，在推导线性回归的时候，<spanclass="math inline">\(\sigma^2\)</span> 的值对我们最终选择的 <spanclass="math inline">\(\theta\)</span> 和 <spanclass="math inline">\(h_\theta(x)\)</span> 都没有影响。所以我们可以给<span class="math inline">\(\sigma^2\)</span>取一个任意值。为了简化推导过程，就令<span class="math inline">\(\sigma^2= 1\)</span>。<spanclass="math inline">\(^6\)</span>然后就有了下面的等式：</p><p><span class="math display">\[\begin{aligned}p(y;\mu) &amp;= \frac 1{\sqrt{2\pi}} exp (- \frac  12 (y-\mu)^2) \\&amp; =  \frac 1{\sqrt{2\pi}} exp (- \frac  12 y^2) \cdot exp (\mu y-\frac  12 \mu^2) \\\end{aligned}\]</span></p><blockquote><p>6 如果我们把 <span class="math inline">\(\sigma^2\)</span>留作一个变量，高斯分布就也可以表达成指数分布的形式，其中 <spanclass="math inline">\(\eta \in R^2\)</span> 就是一个二维向量，同时依赖<span class="math inline">\(\mu\)</span> 和 <spanclass="math inline">\(\sigma\)</span>。然而，对于广义线性模型GLMs方面的用途，<span class="math inline">\(\sigma^2\)</span>参数也可以看成是对指数分布族的更泛化的定义： <spanclass="math inline">\(p(y; \eta, \tau ) = b(a, \tau ) exp((\eta^T T (y)− a(\eta))/c(\tau))\)</span>。这里面的<spanclass="math inline">\(\tau\)</span> 叫做<strong>分散度参数（dispersionparameter）</strong>，对于高斯分布， <span class="math inline">\(c(\tau)= \sigma^2\)</span>；不过上文中我们已经进行了简化，所以针对我们要考虑的各种案例，就不需要再进行更加泛化的定义了。</p></blockquote><p>这样，我们就可以看出来高斯分布是属于指数分布族的，可以写成下面这样：</p><p><span class="math display">\[\begin{aligned}\eta &amp; = \mu \\T(y) &amp; = y \\a(\eta) &amp; = \mu ^2 /2\\&amp; = \eta ^2 /2\\b(y) &amp; = (1/ \sqrt {2\pi })exp(-y^2/2)\end{aligned}\]</span></p><p>指数分布族里面还有很多其他的分布： -例如多项式分布（multinomial），这个稍后我们会看到； -泊松分布（Poisson），用于对计数类数据进行建模，后面再问题集里面也会看到；- 伽马和指数分布（the gamma and theexponential），这个用于对连续的、非负的随机变量进行建模，例如时间间隔；- 贝塔和狄利克雷分布（the beta and theDirichlet），这个是用于概率的分布； - 还有很多，这里就不一一列举了。</p><p>在下一节里面，我们就来讲一讲对于建模的一个更通用的“方案”，其中的<spanclass="math inline">\(y\)</span> （给定 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(\theta\)</span>）可以是上面这些分布中的任意一种。</p><h4 id="构建广义线性模型constructing-glms">9构建广义线性模型（Constructing GLMs）</h4><p>设想你要构建一个模型，来估计在给定的某个小时内来到你商店的顾客人数（或者是你的网站的页面访问次数），基于某些确定的特征<span class="math inline">\(x\)</span>，例如商店的促销、最近的广告、天气、今天周几啊等等。我们已经知道泊松分布（Poissondistribution）通常能适合用来对访客数目进行建模。知道了这个之后，怎么来建立一个模型来解决咱们这个具体问题呢？非常幸运的是，泊松分布是属于指数分布族的一个分布，所以我们可以对该问题使用广义线性模型（GeneralizedLinear Model，缩写为GLM）。在本节，我们讲一种对刚刚这类问题构建广义线性模型的方法。</p><p>进一步泛化，设想一个分类或者回归问题，要预测一些随机变量 <spanclass="math inline">\(y\)</span> 的值，作为 <spanclass="math inline">\(x\)</span>的一个函数。要导出适用于这个问题的广义线性模型，就要对我们的模型、给定<span class="math inline">\(x\)</span> 下 <spanclass="math inline">\(y\)</span> 的条件分布来做出以下三个假设：</p><ol type="1"><li><span class="math inline">\(y | x; \theta ∼ ExponentialFamily(\eta)\)</span>，即给定 <span class="math inline">\(x\)</span> 和<span class="math inline">\(\theta, y\)</span>的分布属于指数分布族，是一个参数为 <spanclass="math inline">\(\eta\)</span> 的指数分布。——假设1</li><li>给定 <spanclass="math inline">\(x\)</span>，目的是要预测对应这个给定 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(T(y)\)</span>的期望值。咱们的例子中绝大部分情况都是 <span class="math inline">\(T(y)= y\)</span>，这也就意味着我们的学习假设 <spanclass="math inline">\(h\)</span> 输出的预测值 <spanclass="math inline">\(h(x)\)</span> 要满足 <spanclass="math inline">\(h(x) = E[y|x]\)</span>。 （注意，这个假设通过对<span class="math inline">\(h_\theta(x)\)</span>的选择而满足，在逻辑回归和线性回归中都是如此。例如在逻辑回归中， <spanclass="math inline">\(h_\theta (x) = [p (y = 1|x; \theta)] =[ 0 \cdot p(y = 0|x; \theta)+1\cdot p(y = 1|x;\theta)] =E[y|x;\theta]\)</span>。<strong>译者注：这里的<spanclass="math inline">\(E[y|x\)</span>]应该就是对给定<spanclass="math inline">\(x\)</span>时的<spanclass="math inline">\(y\)</span>值的期望的意思。</strong>）——假设2</li><li>自然参数 <span class="math inline">\(\eta\)</span> 和输入值 <spanclass="math inline">\(x\)</span> 是线性相关的，<spanclass="math inline">\(\eta = \theta^T x\)</span>，或者如果 <spanclass="math inline">\(\eta\)</span> 是有值的向量，则有<spanclass="math inline">\(\eta_i = \theta_i^T x\)</span>。——假设3</li></ol><p>上面的几个假设中，第三个可能看上去证明得最差，所以也更适合把这第三个假设看作是一个我们在设计广义线性模型时候的一种<strong>“设计选择 designchoice”</strong>，而不是一个假设。那么这三个假设/设计，就可以用来推导出一个非常合适的学习算法类别，也就是广义线性模型GLMs，这个模型有很多特别友好又理想的性质，比如很容易学习。此外，这类模型对一些关于<span class="math inline">\(y\)</span>的分布的不同类型建模来说通常效率都很高；例如，我们下面就将要简单介绍一些逻辑回归以及普通最小二乘法这两者如何作为广义线性模型来推出。</p><h5 id="普通最小二乘法ordinary-least-squares">9.1普通最小二乘法（Ordinary Least Squares）</h5><p>我们这一节要讲的是普通最小二乘法实际上是广义线性模型中的一种特例，设想如下的背景设置：目标变量<spanclass="math inline">\(y\)</span>（在广义线性模型的术语也叫做<strong>响应变量responsevariable</strong>）是连续的，然后我们将给定 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(y\)</span> 的分布以高斯分布 <spanclass="math inline">\(N(\mu, \sigma^2)\)</span> 来建模，其中 <spanclass="math inline">\(\mu\)</span> 可以是依赖 <spanclass="math inline">\(x\)</span> 的一个函数。这样，我们就让上面的<spanclass="math inline">\(ExponentialFamily(\eta)\)</span>分布成为了一个高斯分布。在前面内容中我们提到过，在把高斯分布写成指数分布族的分布的时候，有<spanclass="math inline">\(\mu = \eta\)</span>。所以就能得到下面的等式：</p><p><span class="math display">\[\begin{aligned}h_\theta(x)&amp; = E[y|x;\theta] \\&amp; = \mu \\&amp; = \eta \\&amp; = \theta^Tx\\\end{aligned}\]</span></p><p>第一行的等式是基于假设2；第二个等式是基于定理当 <spanclass="math inline">\(y|x; \theta ∼ N (\mu, \sigma ^2)\)</span>，则<span class="math inline">\(y\)</span> 的期望就是 <spanclass="math inline">\(\mu\)</span>；第三个等式是基于假设1，以及之前我们此前将高斯分布写成指数族分布的时候推导出来的性质<span class="math inline">\(\mu =\eta\)</span>；最后一个等式就是基于假设3。</p><h5 id="逻辑回归logistic-regression-1">9.2 逻辑回归（LogisticRegression）</h5><p>接下来咱们再来看看逻辑回归。这里咱们还是看看二值化分类问题，也就是<span class="math inline">\(y \in \{0, 1\}\)</span>。给定了<spanclass="math inline">\(y\)</span>是一个二选一的值，那么很自然就选择伯努利分布（Bernoullidistribution）来对给定 <span class="math inline">\(x\)</span> 的 <spanclass="math inline">\(y\)</span>的分布进行建模了。在我们把伯努利分布写成一种指数族分布的时候，有 <spanclass="math inline">\(\phi = 1/ (1 +e^{−\eta})\)</span>。另外还要注意的是，如果有 <spanclass="math inline">\(y|x; \theta ∼ Bernoulli(\phi)\)</span>，那么 <spanclass="math inline">\(E [y|x; \theta] =\phi\)</span>。所以就跟刚刚推导普通最小二乘法的过程类似，有以下等式：</p><p><span class="math display">\[\begin{aligned}h_\theta(x)&amp; = E[y|x;\theta] \\&amp; = \phi \\&amp; = 1/(1+ e^{-\eta}) \\&amp; = 1/(1+ e^{-\theta^Tx})\\\end{aligned}\]</span></p><p>所以，上面的等式就给了给了假设函数的形式：<spanclass="math inline">\(h_\theta(x) = 1/ (1 + e^{−\theta^Tx})\)</span>。如果你之前好奇咱们是怎么想出来逻辑回归的函数为<spanclass="math inline">\(1/ (1 + e^{−z})\)</span>，这个就是一种解答：一旦我们假设以 <spanclass="math inline">\(x\)</span> 为条件的 <spanclass="math inline">\(y\)</span>的分布是伯努利分布，那么根据广义线性模型和指数分布族的定义，就会得出这个式子。</p><p>再解释一点术语，这里给出分布均值的函数 <spanclass="math inline">\(g\)</span> 是一个关于自然参数的函数，<spanclass="math inline">\(g(\eta) = E[T(y);\eta]\)</span>，这个函数也叫做<strong>规范响应函数（canonical responsefunction），</strong> 它的反函数 <spanclass="math inline">\(g^{−1}\)</span>叫做<strong>规范链接函数（canonical link function）。</strong>因此，对于高斯分布来说，它的规范响应函数正好就是识别函数（identifyfunction）；而对于伯努利分布来说，它的规范响应函数则是逻辑函数（logisticfunction）。<span class="math inline">\(^7\)</span></p><blockquote><p>7 很多教科书用 <span class="math inline">\(g\)</span>表示链接函数，而用反函数<span class="math inline">\(g^{−1}\)</span>来表示响应函数；但是咱们这里用的是反过来的，这是继承了早期的机器学习中的用法，我们这样使用和后续的其他课程能够更好地衔接起来。</p></blockquote><h5 id="softmax-回归">9.3 Softmax 回归</h5><p>咱们再来看一个广义线性模型的例子吧。设想有这样的一个分类问题，其中响应变量<span class="math inline">\(y\)</span> 的取值可以是 <spanclass="math inline">\(k\)</span> 个值当中的任意一个，也就是 <spanclass="math inline">\(y \in \{1, 2, ...,k\}\)</span>。例如，我们这次要进行的分类就比把邮件分成垃圾邮件和正常邮件两类这种二值化分类要更加复杂一些，比如可能是要分成三类，例如垃圾邮件、个人邮件、工作相关邮件。这样响应变量依然还是离散的，但取值就不只有两个了。因此咱们就用多项式分布（multinomialdistribution）来进行建模。</p><p>下面咱们就通过这种多项式分布来推出一个广义线性模型。要实现这一目的，首先还是要把多项式分布也用指数族分布来进行描述。</p><p>要对一个可能有 <span class="math inline">\(k\)</span>个不同输出值的多项式进行参数化，就可以用 <spanclass="math inline">\(k\)</span> 个参数 <spanclass="math inline">\(\phi_1,...,\phi_ k\)</span>来对应各自输出值的概率。不过这么多参数可能太多了，形式上也太麻烦，他们也未必都是互相独立的（比如对于任意一个<spanclass="math inline">\(\phi_ i\)</span>中的值来说，只要知道其他的 <spanclass="math inline">\(k-1\)</span>个值，就能知道这最后一个了，因为总和等于<spanclass="math inline">\(1\)</span>，也就是<spanclass="math inline">\(\sum^k_{i=1} \phi_i =1\)</span>）。所以咱们就去掉一个参数，只用 <spanclass="math inline">\(k-1\)</span> 个：<spanclass="math inline">\(\phi_1,...,\phi_ {k-1}\)</span>来对多项式进行参数化，其中<span class="math inline">\(\phi_i = p (y = i;\phi)，p (y = k; \phi) = 1 −\sum ^{k−1}_{i=1}\phi_i\)</span>。为了表述起来方便，我们还要设 <spanclass="math inline">\(\phi_k = 1 − \sum_{i=1}^{k−1}\phi_i\)</span>，但一定要注意，这个并不是一个参数，而是完全由其他的<span class="math inline">\(k-1\)</span> 个参数来确定的。</p><p>要把一个多项式表达成为指数组分布，还要按照下面的方式定义一个 <spanclass="math inline">\(T (y) \in R^{k−1}\)</span>:</p><p><span class="math display">\[T(1)=    \begin{bmatrix}      1\\      0\\      0\\      \vdots \\      0\\    \end{bmatrix},T(2)=    \begin{bmatrix}      0\\      1\\      0\\      \vdots \\      0\\    \end{bmatrix},T(3)=    \begin{bmatrix}      0\\      0\\      1\\      \vdots \\      0\\    \end{bmatrix},T(k-1)=    \begin{bmatrix}      0\\      0\\      0\\      \vdots \\      1\\    \end{bmatrix},T(k)=    \begin{bmatrix}      0\\      0\\      0\\      \vdots \\      0\\    \end{bmatrix},\]</span></p><p>这次和之前的样例都不一样了，就是不再有 <spanclass="math inline">\(T(y) = y\)</span>；然后，<spanclass="math inline">\(T(y)\)</span> 现在是一个 <spanclass="math inline">\(k – 1\)</span> 维的向量，而不是一个实数了。向量<span class="math inline">\(T(y)\)</span> 中的第 <spanclass="math inline">\(i\)</span> 个元素写成<spanclass="math inline">\((T(y))_i\)</span> 。</p><p>现在介绍一种非常有用的记号。指示函数（indicator function）<spanclass="math inline">\(1\{\cdot  \}\)</span>，如果参数为真，则等于<spanclass="math inline">\(1\)</span>；反之则等于<spanclass="math inline">\(0\)</span>（<span class="math inline">\(1\{True\}= 1, 1\{False\} = 0\)</span>）。例如<span class="math inline">\(1\{2 =3\} = 0\)</span>, 而<span class="math inline">\(1\{3 = 5 − 2\} =1\)</span>。所以我们可以把<span class="math inline">\(T(y)\)</span> 和<span class="math inline">\(y\)</span> 的关系写成 <spanclass="math inline">\((T(y))_i = 1\{y =i\}\)</span>。（往下继续阅读之前，一定要确保你理解了这里的表达式为真！）在此基础上，就有了<spanclass="math inline">\(E[(T(y))_i] = P (y = i) = \phi_i\)</span>。</p><p>现在一切就绪，可以把多项式写成指数族分布了。写出来如下所示：</p><p><span class="math display">\[\begin{aligned}p(y;\phi) &amp;=\phi_1^{1\{y=1\}}\phi_2^{1\{y=2\}}\dots\phi_k^{1\{y=k\}} \\          &amp;=\phi_1^{1\{y=1\}}\phi_2^{1\{y=2\}}\dots\phi_k^{1-\sum_{i=1}^{k-1}1\{y=i\}} \\          &amp;=\phi_1^{(T(y))_1}\phi_2^{(T(y))_2}\dots\phi_k^{1-\sum_{i=1}^{k-1}(T(y))_i } \\          &amp;=exp((T(y))_1 log(\phi_1)+(T(y))_2log(\phi_2)+\dots+(1-\sum_{i=1}^{k-1}(T(y))_i)log(\phi_k)) \\          &amp;= exp((T(y))_1 log(\frac{\phi_1}{\phi_k})+(T(y))_2log(\frac{\phi_2}{\phi_k})+\dots+(T(y))_{k-1}log(\frac{\phi_{k-1}}{\phi_k})+log(\phi_k))\\          &amp;=b(y)exp(\eta^T T(y)-a(\eta))\end{aligned}\]</span></p><p>其中：</p><p><span class="math display">\[\begin{aligned}\eta &amp;=    \begin{bmatrix}      \log (\phi _1/\phi _k)\\      \log (\phi _2/\phi _k)\\      \vdots \\      \log (\phi _{k-1}/\phi _k)\\    \end{bmatrix}, \\a(\eta) &amp;= -\log (\phi _k)\\b(y) &amp;= 1\\\end{aligned}\]</span></p><p>这样咱们就把多项式方程作为一个指数族分布来写了出来。</p><p>与 <span class="math inline">\(i (for\quad i = 1, ...,k)\)</span>对应的链接函数为：</p><p><span class="math display">\[\eta_i =\log \frac  {\phi_i}{\phi_k}\]</span></p><p>为了方便起见，我们再定义 <span class="math inline">\(\eta_k = \log(\phi_k/\phi_k) =0\)</span>。对链接函数取反函数然后推导出响应函数，就得到了下面的等式：</p><p><span class="math display">\[\begin{aligned}e^{\eta_i} &amp;= \frac {\phi_i}{\phi_k}\\\phi_k e^{\eta_i} &amp;= \phi_i  \qquad\text{(7)}\\\phi_k  \sum^k_{i=1} e^{\eta_i}&amp;= \sum^k_{i=1}\phi_i= 1\\\end{aligned}\]</span></p><p>这就说明了<span class="math inline">\(\phi_k = \frac  1 {\sum^k_{i=1}e^{\eta_i}}\)</span>，然后可以把这个关系代入回到等式<spanclass="math inline">\((7)\)</span>，这样就得到了响应函数：</p><p><span class="math display">\[\phi_i = \frac  { e^{\eta_i} }{ \sum^k_{j=1} e^{\eta_j}}\]</span></p><p>上面这个函数从<span class="math inline">\(\eta\)</span> 映射到了<spanclass="math inline">\(\phi\)</span>，称为 <strong>Softmax</strong>函数。</p><p>要完成我们的建模，还要用到前文提到的假设3，也就是 <spanclass="math inline">\(\eta_i\)</span> 是一个 <spanclass="math inline">\(x\)</span> 的线性函数。所以就有了 <spanclass="math inline">\(\eta_i= \theta_i^Tx (for\quad i = 1, ..., k −1)\)</span>，其中的 <span class="math inline">\(\theta_1, ...,\theta_{k−1} \in R^{n+1}\)</span>就是我们建模的参数。为了表述方便，我们这里还是定义<spanclass="math inline">\(\theta_k = 0\)</span>，这样就有 <spanclass="math inline">\(\eta_k = \theta_k^T x =0\)</span>，跟前文提到的相符。因此，我们的模型假设了给定 <spanclass="math inline">\(x\)</span> 的 <spanclass="math inline">\(y\)</span> 的条件分布为：</p><p><span class="math display">\[\begin{aligned}p(y=i|x;\theta) &amp;=  \phi_i \\&amp;= \frac {e^{\eta_i}}{\sum^k_{j=1}e^{\eta_j}}\\&amp;=\frac{e^{\theta_i^Tx}}{\sum^k_{j=1}e^{\theta_j^Tx}}\qquad\text{(8)}\\\end{aligned}\]</span></p><p>这个适用于解决 <span class="math inline">\(y \in\{1, ...,k\}\)</span> 的分类问题的模型，就叫做 <strong>Softmax 回归。</strong>这种回归是对逻辑回归的一种扩展泛化。</p><p>假设（hypothesis） <span class="math inline">\(h\)</span>则如下所示:</p><p><span class="math display">\[\begin{aligned}h_\theta (x) &amp;= E[T(y)|x;\theta]\\&amp;= E \left[    \begin{array}{cc|c}      1(y=1)\\      1(y=2)\\      \vdots \\      1(y=k-1)\\    \end{array}x;\theta\right]\\&amp;= E \left[    \begin{array}{c}      \phi_1\\      \phi_2\\      \vdots \\      \phi_{k-1}\\    \end{array}\right]\\&amp;= E \left[    \begin{array}{ccc}      \frac {exp(\theta_1^Tx)}{\sum^k_{j=1}exp(\theta_j^Tx)} \\      \frac {exp(\theta_2^Tx)}{\sum^k_{j=1}exp(\theta_j^Tx)} \\      \vdots \\      \frac {exp(\theta_{k-1}^Tx)}{\sum^k_{j=1}exp(\theta_j^Tx)} \\    \end{array}\right]\\\end{aligned}\]</span></p><p>也就是说，我们的假设函数会对每一个 <span class="math inline">\(i =1,...,k\)</span> ，给出 <span class="math inline">\(p (y = i|x;\theta)\)</span> 概率的估计值。（虽然咱们在前面假设的这个 <spanclass="math inline">\(h_\theta(x)\)</span> 只有 <spanclass="math inline">\(k-1\)</span> 维，但很明显 <spanclass="math inline">\(p (y = k|x; \theta)\)</span> 可以通过用 <spanclass="math inline">\(1\)</span> 减去其他所有项目概率的和来得到，即<spanclass="math inline">\(1− \sum^{k-1}_{i=1}\phi_i\)</span>。）</p><p>最后，咱们再来讲一下参数拟合。和我们之前对普通最小二乘线性回归和逻辑回归的原始推导类似，如果咱们有一个有<span class="math inline">\(m\)</span> 个训练样本的训练集 <spanclass="math inline">\(\{(x^{(i)}, y^{(i)}); i = 1, ...,m\}\)</span>，然后要研究这个模型的参数 <spanclass="math inline">\(\theta_i\)</span>，我们可以先写出其似然函数的对数：</p><p><span class="math display">\[\begin{aligned}l(\theta)&amp; =\sum^m_{i=1} \log p(y^{(i)}|x^{(i)};\theta)\\&amp;= \sum^m_{i=1}log\prod ^k_{l=1}(\frac{e^{\theta_l^Tx^{(i)}}}{\sum^k_{j=1} e^{\theta_j^Tx^{(i)}}})^{1(y^{(i)}=l)}\\\end{aligned}\]</span></p><p>要得到上面等式的第二行，要用到等式<spanclass="math inline">\((8)\)</span>中的设定 <spanclass="math inline">\(p(y|x; \theta)\)</span>。现在就可以通过对 <spanclass="math inline">\(l(\theta)\)</span> 取最大值得到的 <spanclass="math inline">\(\theta\)</span>而得到对参数的最大似然估计，使用的方法就可以用梯度上升法或者牛顿法了。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DTW (Dynamic Time Warping)</title>
    <link href="/2023/06/24/DTW/"/>
    <url>/2023/06/24/DTW/</url>
    
    <content type="html"><![CDATA[<p>DTW最初用于识别语音的相似性，当前DTW算法常用于计算两个时间序列的相似性，<strong>尤其适用于不同长度、不同节奏的时间序列</strong>## 算法流程 假设有两个序列 <spanclass="math display">\[\mathbf{X}=\{\mathbf{x}_1,\mathbf{x}_{2},\ldots,\mathbf{x}_{n}\}\]</span></p><p><spanclass="math display">\[\mathbf{Y}=\{\mathbf{y}_1,\mathbf{y}_{2},\ldots,\mathbf{y}_{m}\}\]</span> <img src="/img/DTWgrid.gif" /></p><p>首先构建一个<span class="math inline">\(m\timesn\)</span>的二维数组<spanclass="math inline">\(W\)</span>，数组中每个点<spanclass="math inline">\(W(i,j)\)</span>表示<spanclass="math inline">\(\mathbf{X}_{i}\)</span>和<spanclass="math inline">\(\mathbf{Y}_{j}\)</span>之间的累计距离<spanclass="math inline">\(\sqrt{ (\mathbf{X}_{i}-\mathbf{Y}_{j})^2}\)</span>。DTW的核心思想是在这样的一个距离矩阵中从两个序列的起点找到通往两个序列终点的最小距离路径，但是在寻找路径的过程中，必须满足一些约束条件：1. <strong>边界条件</strong>：起点必须是 <spanclass="math inline">\(w(1,1)\)</span> ，终点必须是 <spanclass="math inline">\(w(1,1)\)</span>，要有始有终； 2.<strong>连续性</strong>：意思是下一个满足条件的灰色方块一定是在当前灰色方块的周围一圈；3.<strong>单调性</strong>：下一个满足条件的灰色方块一定在当前灰色方块的右上方，不能回头；假设有两个序列<spanclass="math inline">\(\mathbf{X}=\{1,3,2,4,2\}\)</span>，<spanclass="math inline">\(\mathbf{Y}=\{0,3,4,2,2\}\)</span>，根据欧氏距离可以直接计算得到两个序列之间的距离为：<span class="math display">\[dis = \sqrt{ (1-0)^2+(3-3)^2+(2-4)^2+(4-2)^2+(2-2)^2 }=\sqrt{ 5 }\]</span></p><p>构建距离累计<span class="math inline">\(w\)</span>矩阵： 1.首先构建最左边的一列，<spanclass="math inline">\(W(i,0)=dis(\mathbf{X}_{i}-\mathbf{Y}_{0})+W(i-1,0)\)</span>2. 然后构建最下边一行：<spanclass="math inline">\(W(0,j)=dis(\mathbf{X}_{0},\mathbf{Y}_{j})+W(0,j-1)\)</span>3. 最后构建表格中间的元素：<spanclass="math inline">\(W(i,j)=dis(\mathbf{X}_{i},\mathbf{Y}_{j})+\min(W(i-1,j),W(i,j-1),W(i-1),W(j-1))\)</span>4.然后根据构建的距离累加矩阵从右上角到左下角寻找配准路径，寻找左下三个点钟较小的那个作为下一个节点5. 最后得到配准的结果<spanclass="math inline">\(\{(\mathbf{x}_{1},\mathbf{y}_{1}),(\mathbf{x}_{2},\mathbf{y}_{2}),(\mathbf{x}_{3},\mathbf{y}_{2}),(\mathbf{x}_{4},\mathbf{y}_{3}),(\mathbf{x}_{5},\mathbf{y}_{4}),(\mathbf{x}_{5},\mathbf{y}_{5})\}\)</span></p><p><img src="/img/Pasted%20image%2020230622211506.png" /></p><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># Dynamic Time Warping</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dtw</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-comment"># x and y are both 1D arrays</span><br>    <span class="hljs-comment"># dist_func is a function that takes two arguments and returns a number</span><br>    <span class="hljs-comment"># (e.g. lambda x, y: abs(x - y))</span><br>    <span class="hljs-comment"># initialize DTW matrix</span><br>    DTW = np.zeros((<span class="hljs-built_in">len</span>(x), <span class="hljs-built_in">len</span>(y)))  <br>    <span class="hljs-comment"># fill in first row and column</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        DTW[i, <span class="hljs-number">0</span>] = dist_func(x[i], y[<span class="hljs-number">0</span>])+DTW[i-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y)):<br>        DTW[<span class="hljs-number">0</span>, j] = dist_func(x[<span class="hljs-number">0</span>], y[j])+DTW[<span class="hljs-number">0</span>, j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(x)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(y)):<br>            DTW[i, j] = dist_func(x[i], y[j]) + <span class="hljs-built_in">min</span>(DTW[i-<span class="hljs-number">1</span>, j], DTW[i, j-<span class="hljs-number">1</span>], DTW[i-<span class="hljs-number">1</span>, j-<span class="hljs-number">1</span>])<br>    path = []<br>    i = <span class="hljs-built_in">len</span>(x)-<span class="hljs-number">1</span><br>    j = <span class="hljs-built_in">len</span>(y)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j &gt; <span class="hljs-number">0</span>: <span class="hljs-comment"># if not at the top left</span><br>            path.append((i,j))<br>            <span class="hljs-keyword">if</span> DTW[i-<span class="hljs-number">1</span>, j] == <span class="hljs-built_in">min</span>(DTW[i-<span class="hljs-number">1</span>, j], DTW[i, j-<span class="hljs-number">1</span>], DTW[i-<span class="hljs-number">1</span>, j-<span class="hljs-number">1</span>]):<br>                i -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> DTW[i, j-<span class="hljs-number">1</span>] == <span class="hljs-built_in">min</span>(DTW[i-<span class="hljs-number">1</span>, j], DTW[i, j-<span class="hljs-number">1</span>], DTW[i-<span class="hljs-number">1</span>, j-<span class="hljs-number">1</span>]):<br>                j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                i -= <span class="hljs-number">1</span><br>                j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">0</span>:<br>            path.append((i,j))<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">elif</span> i == <span class="hljs-number">0</span>:<br>            path.append((i,j))<br>            j = j-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> j == <span class="hljs-number">0</span>:<br>            path.append((i,j))<br>            i = i-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> path<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dist_func</span>(<span class="hljs-params">x,y</span>):<br>    result = (x-y)**<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> result<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    x = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br>    y = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<br>    <span class="hljs-built_in">print</span>(dtw(x, y))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DTW</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Command-line</title>
    <link href="/2023/06/05/Command-line/"/>
    <url>/2023/06/05/Command-line/</url>
    
    <content type="html"><![CDATA[<p>当您使用 shell进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p><p>我们已经使用 shell一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</p><p>我们还将学习一些能够改善您的 shell及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用SSH 操作远端机器。</p><h1 id="任务控制">任务控制</h1><p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用<code>find</code> 搜索一个非常大的目录结构）。大多数情况下，我们可以使用<code>Ctrl-C</code>来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p><h2 id="结束进程">结束进程</h2><p>您的 shell 会使用 UNIX提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种<em>软件中断</em>。</p><p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell会发送一个<code>SIGINT</code> 信号到进程。</p><p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code>并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code>信号，通过输入<code>Ctrl-\</code>可以发送该信号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> signal, time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">signum, time</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nI got a SIGINT, but I am not stopping&quot;</span>)<br><br>signal.signal(signal.SIGINT, handler)<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">.1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i), end=<span class="hljs-string">&quot;&quot;</span>)<br>    i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如果我们向这个程序发送两次 <code>SIGINT</code> ，然后再发送一次<code>SIGQUIT</code>，程序会有什么反应？注意 <code>^</code>是我们在终端输入<code>Ctrl</code> 时的表示形式：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python</span> sigint.<span class="hljs-keyword">py</span><br><span class="hljs-number">24</span>^C<br>I got <span class="hljs-keyword">a</span> SIGINT, but I <span class="hljs-keyword">am</span> not stopping<br><span class="hljs-number">26</span>^C<br>I got <span class="hljs-keyword">a</span> SIGINT, but I <span class="hljs-keyword">am</span> not stopping<br><span class="hljs-number">30</span>^\[<span class="hljs-number">1</span>]    <span class="hljs-number">39913</span> <span class="hljs-keyword">quit</span>       <span class="hljs-keyword">python</span> sigint.<span class="hljs-keyword">py</span>ƒ<br></code></pre></td></tr></table></figure><p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code>都常常用来发出和终止程序相关的请求。<code>SIGTERM</code>则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用<ahref="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a>命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p><h2 id="暂停和后台执行进程">暂停和后台执行进程</h2><p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code>会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送<code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop的缩写（即<code>terminal</code>版本的SIGSTOP）。</p><p>我们可以使用 <ahref="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a>或 <ahref="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a>命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p><p><ahref="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a>命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid引用这些任务（也可以用 <ahref="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a>找出 pid）。更加符合直觉的操作是您可以使用百分号 +任务编号（<code>jobs</code>会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用<code>$!</code> 这一特殊参数。</p><p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code>后缀可以让命令在直接在后台运行，这使得您可以直接在 shell中继续做其他操作，不过它此时还是会使用 shell的标准输出，这一点有时会比较恼人（这种情况可以使用 shell重定向处理）。</p><p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code>，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用<ahref="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a>(一个用来忽略 <code>SIGHUP</code> 的封装)来运行程序。针对已经运行的程序，可以使用<code>disown</code>。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p><p>下面这个简单的会话中展示来了些概念的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sleep</span> 1000</span><br>^Z<br>[1]  + 18653 suspended  sleep 1000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> <span class="hljs-built_in">sleep</span> 2000 &amp;</span><br>[2] 18745<br>appending output to nohup.out<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span></span><br>[1]  + suspended  sleep 1000<br>[2]  - running    nohup sleep 2000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">bg</span> %1</span><br>[1]  - 18653 continued  sleep 1000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span></span><br>[1]  - running    sleep 1000<br>[2]  + running    nohup sleep 2000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -STOP %1</span><br>[1]  + 18653 suspended (signal)  sleep 1000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span></span><br>[1]  + suspended (signal)  sleep 1000<br>[2]  - running    nohup sleep 2000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -SIGHUP %1</span><br>[1]  + 18653 hangup     sleep 1000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span></span><br>[2]  + running    nohup sleep 2000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> -SIGHUP %2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span></span><br>[2]  + running    nohup sleep 2000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">kill</span> %2</span><br>[2]  + 18745 terminated  nohup sleep 2000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">jobs</span></span><br><br></code></pre></td></tr></table></figure><p><code>SIGKILL</code>是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p><p>您可以在 <ahref="https://en.wikipedia.org/wiki/Signal_(IPC)">这里</a> 或输入 <ahref="https://www.man7.org/linux/man-pages/man7/signal.7.html"><code>man signal</code></a>或使用 <code>kill -l</code> 来获取更多关于信号的信息。</p><h1 id="终端多路复用">终端多路复用</h1><p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p><p>像 <ahref="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个shell 会话进行交互。</p><p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p><p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code>和其他类似技巧的使用。</p><p>现在最流行的终端多路器是 <ahref="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code>是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p><p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似<code>&lt;C-b&gt; x</code>这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下<code>x</code>。<code>tmux</code> 中对象的继承结构如下： -<strong>会话</strong> -每个会话都是一个独立的工作区，其中包含一个或多个窗口 + <code>tmux</code>开始一个新的会话 + <code>tmux new -s NAME</code>以指定名称开始一个新的会话 + <code>tmux ls</code> 列出当前所有会话 + 在<code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离 +<code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code>来指定具体的会话</p><ul><li><strong>窗口</strong> -相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分<ul><li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用<code>&lt;C-d&gt;</code>关闭</li><li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em>个窗口，注意每个窗口都是有编号的</li><li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li><li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li><li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li><li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li></ul></li><li><strong>面板</strong> - 像 vim中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell<ul><li><code>&lt;C-b&gt; "</code> 水平分割</li><li><code>&lt;C-b&gt; %</code> 垂直分割</li><li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，<方向>指的是键盘上的方向键</li><li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li><li><code>&lt;C-b&gt; [</code>开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li><li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li></ul></li></ul><p>扩展阅读： <ahref="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">这里</a>是一份 <code>tmux</code> 快速入门教程， <ahref="http://linuxcommand.org/lc3_adv_termmux.php">而这一篇</a>文章则更加详细，它包含了 <code>screen</code> 命令。您也许想要掌握 <ahref="https://www.man7.org/linux/man-pages/man1/screen.1.html"><code>screen</code></a>命令，因为在大多数 UNIX 系统中都默认安装有该程序。</p><h1 id="别名">别名</h1><p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell都支持设置别名。shell 的别名相当于一个长命令的缩写，shell会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> alias_name=<span class="hljs-string">&quot;command_to_alias arg1 arg2&quot;</span><br></code></pre></td></tr></table></figure><p>注意， <code>=</code>两边是没有空格的，因为 <ahref="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a>是一个 shell 命令，它只接受一个参数。</p><p>别名有许多很方便的特性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建常用命令的缩写</span><br><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&quot;ls -lh&quot;</span><br><br><span class="hljs-comment"># 能够少输入很多</span><br><span class="hljs-built_in">alias</span> gs=<span class="hljs-string">&quot;git status&quot;</span><br><span class="hljs-built_in">alias</span> gc=<span class="hljs-string">&quot;git commit&quot;</span><br><span class="hljs-built_in">alias</span> v=<span class="hljs-string">&quot;vim&quot;</span><br><br><span class="hljs-comment"># 手误打错命令也没关系</span><br><span class="hljs-built_in">alias</span> sl=<span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 重新定义一些命令行的默认行为</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">mv</span>=<span class="hljs-string">&quot;mv -i&quot;</span>           <span class="hljs-comment"># -i prompts before overwrite</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">mkdir</span>=<span class="hljs-string">&quot;mkdir -p&quot;</span>     <span class="hljs-comment"># -p make parent dirs as needed</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">df</span>=<span class="hljs-string">&quot;df -h&quot;</span>           <span class="hljs-comment"># -h prints human readable format</span><br><br><span class="hljs-comment"># 别名可以组合使用</span><br><span class="hljs-built_in">alias</span> la=<span class="hljs-string">&quot;ls -A&quot;</span><br><span class="hljs-built_in">alias</span> lla=<span class="hljs-string">&quot;la -l&quot;</span><br><br><span class="hljs-comment"># 在忽略某个别名</span><br>\<span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 或者禁用别名</span><br><span class="hljs-built_in">unalias</span> la<br><br><span class="hljs-comment"># 获取别名的定义</span><br><span class="hljs-built_in">alias</span> ll<br><span class="hljs-comment"># 会打印 ll=&#x27;ls -lh&#x27;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，在默认情况下 shell并不会保存别名。为了让别名持续生效，您需要将配置放进 shell的启动文件里，像是<code>.bashrc</code> 或<code>.zshrc</code>，下一节我们就会讲到。</p><h1 id="配置文件dotfiles">配置文件（Dotfiles）</h1><p>很多程序的配置都是通过纯文本格式的被称作<em>点文件</em>的配置文件来完成的（之所以称为点文件，是因为它们的文件名以<code>.</code> 开头，例如<code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p><p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell程序会读取很多文件以加载其配置项。根据 shell本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<ahref="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a>有非常好的资源</p><p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑<code>.bashrc</code> 或 <code>.bash_profile</code>来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p><p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似<code>export PATH="$PATH:/path/to/program/bin"</code>的命令，这样才能确保这些程序能够被 shell 找到。</p><p>还有一些其他的工具也可以通过<em>点文件</em>进行配置：</p><ul><li><code>bash</code> - <code>~/.bashrc</code>,<code>~/.bash_profile</code></li><li><code>git</code> - <code>~/.gitconfig</code></li><li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code>目录</li><li><code>ssh</code> - <code>~/.ssh/config</code></li><li><code>tmux</code> - <code>~/.tmux.conf</code></li></ul><p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其<strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p><ul><li><strong>安装简单</strong>:如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li><li><strong>可以执行</strong>: 您的工具在任何地方都以相同的配置工作</li><li><strong>同步</strong>:在一处更新配置文件，可以同步到其他所有地方</li><li><strong>变更追踪</strong>:您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li></ul><p>配置文件中需要放些什么？您可以通过在线文档和<ahref="https://en.wikipedia.org/wiki/Man_page">帮助手册</a>了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的<ahref="https://github.com/search?o=desc&amp;q=dotfiles&amp;s=stars&amp;type=Repositories">dotfiles仓库</a> —— 其中最受欢迎的那些可以在<ahref="https://github.com/mathiasbynens/dotfiles">这里</a>找到（我们建议您不要直接复制别人的配置）。<ahref="https://dotfiles.github.io/">这里</a> 也有一些非常有用的资源。</p><p>本课程的老师们也在 GitHub 上开源了他们的配置文件： <ahref="https://github.com/anishathalye/dotfiles">Anish</a>, <ahref="https://github.com/jonhoo/configs">Jon</a>, <ahref="https://github.com/jjgo/dotfiles">Jose</a>.</p><h2 id="可移植性">可移植性</h2><p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者shell是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p><p>有一些技巧可以轻松达成这些目的。如果配置文件 if语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-subst">$(uname)</span>&quot;</span> == <span class="hljs-string">&quot;Linux&quot;</span> ]]; <span class="hljs-keyword">then</span> &#123;do_something&#125;; <span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 使用和 shell 相关的配置时先检查当前 shell 类型</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$SHELL</span>&quot;</span> == <span class="hljs-string">&quot;zsh&quot;</span> ]]; <span class="hljs-keyword">then</span> &#123;do_something&#125;; <span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 您也可以针对特定的设备进行配置</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-subst">$(hostname)</span>&quot;</span> == <span class="hljs-string">&quot;myServer&quot;</span> ]]; <span class="hljs-keyword">then</span> &#123;do_something&#125;; <span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>如果配置文件支持 include功能，您也可以多加利用。例如：<code>~/.gitconfig</code>可以这样编写：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[include]</span><br>    <span class="hljs-attr">path</span> = ~/.gitconfig_local<br></code></pre></td></tr></table></figure><p>然后我们可以在日常使用的设备上创建配置文件<code>~/.gitconfig_local</code>来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p><p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在<code>bash</code> 和 <code>zsh</code>中同时启用一些别名，您可以把它们写在 <code>.aliases</code>里，然后在这两个 shell 里应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Test if ~/.aliases exists and source it</span><br><span class="hljs-keyword">if</span> [ -f ~/.aliases ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">source</span> ~/.aliases<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h1 id="远端设备">远端设备</h1><p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全shell（SSH）。和其他工具一样，SSH也是可以高度定制的，也值得我们花时间学习它。</p><p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh foo@bar.mit.edu<br></code></pre></td></tr></table></figure><p>这里我们尝试以用户名 <code>foo</code> 登录服务器<code>bar.mit.edu</code>。服务器可以通过 URL指定（例如<code>bar.mit.edu</code>），也可以使用 IP指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh配置文件使我们可以用类似 <code>ssh bar</code>这样的命令来登录服务器。</p><h2 id="执行命令">执行命令</h2><p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。<code>ssh foobar@server ls</code> 可以直接在用foobar的命令下执行<code>ls</code> 命令。 想要配合管道来使用也可以，<code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端<code>ls</code> 的输出而<code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地<code>ls</code> 输出的结果进行查询。</p><h2 id="ssh-密钥">SSH 密钥</h2><p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是<code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>)等效于您的密码，所以一定要好好保存它。</p><h3 id="密钥生成">密钥生成</h3><p>使用 <ahref="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a>命令可以生成一对密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519<br></code></pre></td></tr></table></figure><p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用<ahref="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a>或 <ahref="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a>，这样就不需要每次都输入该密码了。</p><p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<ahref="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a>介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行<code>ssh-keygen -y -f /path/to/key</code>.</p><h3 id="基于密钥的认证机制">基于密钥的认证机制</h3><p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code>来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> .ssh/id_ed25519 | ssh foobar@remote <span class="hljs-string">&#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br></code></pre></td></tr></table></figure><p>如果支持 <code>ssh-copy-id</code>的话，可以使用下面这种更简单的解决方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote<br></code></pre></td></tr></table></figure><h2 id="通过-ssh-复制文件">通过 SSH 复制文件</h2><p>使用 ssh 复制文件有很多方法：</p><ul><li><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code>命令，然后通过这样的方法利用标准输入实现<code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<ahref="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a>命令会将标准输出写入到一个文件；</li><li><ahref="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a>：当需要拷贝大量的文件或目录时，使用<code>scp</code>命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li><li><ahref="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a>对 <code>scp</code>进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于<code>--partial</code>标记实现断点续传。<code>rsync</code>的语法和<code>scp</code>类似；</li></ul><h2 id="端口转发">端口转发</h2><p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用<code>localhost:PORT</code> 或<code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p><p>此时就需要进行<em>端口转发</em>。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<ahref="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow文章</a>）中的图片。</p><p><strong>本地端口转发</strong> <imgsrc="https://i.stack.imgur.com/a28N8.png" title="本地端口转发"alt="Local Port Forwarding" /></p><p><strong>远程端口转发</strong> <imgsrc="https://i.stack.imgur.com/4iK3b.png" title="远程端口转发"alt="Remote Port Forwarding" /></p><p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口<code>9999</code> 的转发，使用<code>ssh -L 9999:localhost:8888 foobar@remote_server</code>。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p><h2 id="ssh-配置">SSH 配置</h2><p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> my_server=<span class="hljs-string">&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server</span><br></code></pre></td></tr></table></figure><p>不过，更好的方法是使用 <code>~/.ssh/config</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host vm<br>    User foobar<br>    HostName 172.16.174.141<br>    Port 2222<br>    IdentityFile ~/.ssh/id_ed25519<br>    LocalForward 9999 localhost:8888<br><br><span class="hljs-comment"># 在配置文件中也可以使用通配符</span><br>Host *.mit.edu<br>    User foobaz<br></code></pre></td></tr></table></figure><p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，类似<code>scp</code>、<code>rsync</code>和<code>mosh</code>的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p><p>注意，<code>~/.ssh/config</code>文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p><p>服务器侧的配置通常放在<code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p><h2 id="杂项">杂项</h2><p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。<ahref="https://mosh.org/">Mosh</a>（即 mobile shell ）对 ssh进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p><p>有时将一个远端文件夹挂载到本地会比较方便， <ahref="https://github.com/libfuse/sshfs">sshfs</a>可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p><h1 id="shell-框架">Shell &amp; 框架</h1><p>在 shell 工具和脚本那节课中我们已经介绍了 <code>bash</code>shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认shell。但是，它并不是唯一的选项。</p><p>例如，<code>zsh</code> shell 是 <code>bash</code>的超集并提供了一些方便的功能：</p><ul><li>智能替换, <code>**</code></li><li>行内替换/通配符扩展</li><li>拼写纠错</li><li>更好的 tab 补全和选择</li><li>路径展开 (<code>cd /u/lo/b</code> 会被展开为<code>/usr/local/bin</code>)</li></ul><p><strong>框架</strong> 也可以改进您的 shell。比较流行的通用框架包括<ahref="https://github.com/sorin-ionescu/prezto">prezto</a> 或 <ahref="https://ohmyz.sh/">oh-my-zsh</a>。还有一些更精简的框架，它们往往专注于某一个特定功能，例如<ahref="https://github.com/zsh-users/zsh-syntax-highlighting">zsh语法高亮</a> 或 <ahref="https://github.com/zsh-users/zsh-history-substring-search">zsh历史子串查询</a>。 像 <a href="https://fishshell.com/">fish</a> 这样的shell 包含了很多用户友好的功能，其中一些特性包括：</p><ul><li>向右对齐</li><li>命令语法高亮</li><li>历史子串查询</li><li>基于手册页面的选项补全</li><li>更智能的自动补全</li><li>提示符主题</li></ul><p>需要注意的是，使用这些框架可能会降低您 shell的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。</p><h1 id="终端模拟器">终端模拟器</h1><p>和自定义 shell 一样，花点时间选择适合您的<strong>终端模拟器</strong>并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间<ahref="https://anarc.at/blog/2018-04-12-terminal-emulators-1/">比较</a>的信息）</p><p>您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：</p><ul><li>字体选择</li><li>彩色主题</li><li>快捷键</li><li>标签页/面板支持</li><li>回退配置</li><li>性能（像 <a href="https://github.com/jwilm/alacritty">Alacritty</a>或者 <a href="https://sw.kovidgoyal.net/kitty/">kitty</a>这种比较新的终端，它们支持GPU加速）。</li></ul><h1 id="课后练习">课后练习</h1><p>[习题解答](//) ##任务控制</p><ol type="1"><li><p>我们可以使用类似 <code>ps aux | grep</code>这样的命令来获取任务的 pid ，然后您可以基于pid来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行<code>sleep 10000</code> 这个任务。然后用 <code>Ctrl-Z</code>将其切换到后台并使用 <code>bg</code>来继续允许它。现在，使用 <ahref="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a>来查找 pid 并使用 <ahref="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pkill</code></a>结束进程而不需要手动输入pid。(提示：: 使用 <code>-af</code>标记)。</p></li><li><p>如果您希望某个进程结束后再开始另外一个进程，应该如何实现呢？在这个练习中，我们使用 <code>sleep 60 &amp;</code>作为先执行的程序。一种方法是使用 <ahref="http://man7.org/linux/man-pages/man1/wait.1p.html"><code>wait</code></a>命令。尝试启动这个休眠命令，然后待其结束后再执行 <code>ls</code>命令。</p><p>但是，如果我们在不同的 bash会话中进行操作，则上述方法就不起作用了。因为 <code>wait</code>只能对子进程起作用。之前我们没有提过的一个特性是，<code>kill</code>命令成功退出时其状态码为 0 ，其他状态则是非0。<code>kill -0</code>则不会发送信号，但是会在进程不存在时返回一个不为0的状态码。请编写一个bash 函数 <code>pidwait</code> ，它接受一个 pid作为输入参数，然后一直等待直到该进程结束。您需要使用 <code>sleep</code>来避免浪费 CPU 性能。</p></li></ol><h2 id="终端多路复用-1">终端多路复用</h2><ol type="1"><li>请完成这个 <code>tmux</code> <ahref="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">教程</a>参考<ahref="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">这些步骤</a>来学习如何自定义<code>tmux</code>。</li></ol><h2 id="别名-1">别名</h2><ol type="1"><li>创建一个 <code>dc</code> 别名，它的功能是当我们错误的将<code>cd</code> 输入为 <code>dc</code> 时也能正确执行。</li><li>执行<code>history | awk '&#123;$1="";print substr($0,2)&#125;' | sort | uniq -c | sort -n | tail -n 10</code>来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash中生效，如果您使用 ZSH，使用<code>history 1</code> 替换<code>history</code>。</li></ol><h2 id="配置文件">配置文件</h2><p>让我们帮助您进一步学习配置文件：</p><ol type="1"><li>为您的配置文件新建一个文件夹，并设置好版本控制</li><li>在其中添加至少一个配置文件，比如说您的shell，在其中包含一些自定义设置（可以从设置 <code>$PS1</code>开始）。</li><li>建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个shell 脚本对每个文件使用 <code>ln -s</code>，也可以使用<ahref="https://dotfiles.github.io/utilities/">专用工具</a></li><li>在新的虚拟机上测试该安装脚本。</li><li>将您现有的所有配置文件移动到项目仓库里。</li><li>将项目发布到GitHub。</li></ol><h2 id="远端设备-1">远端设备</h2><p>进行下面的练习需要您先安装一个 Linux虚拟机（如果已经安装过则可以直接使用），如果您对虚拟机尚不熟悉，可以参考<ahref="https://hibbard.eu/install-ubuntu-virtual-box/">这篇教程</a>来进行安装。</p><ol type="1"><li>前往 <code>~/.ssh/</code> 并查看是否已经存在 SSH密钥对。如果不存在，请使用<code>ssh-keygen -o -a 100 -t ed25519</code>来创建一个。建议为密钥设置密码然后使用<code>ssh-agent</code>，更多信息可以参考<a href="https://www.ssh.com/ssh/agent">这里</a>；</li><li>在<code>.ssh/config</code>加入下面内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host vm<br>    User username_goes_here<br>    HostName ip_goes_here<br>    IdentityFile ~/.ssh/id_ed25519<br>    LocalForward 9999 localhost:8888<br></code></pre></td></tr></table></figure><ol type="1"><li>使用 <code>ssh-copy-id vm</code> 将您的 ssh 密钥拷贝到服务器。</li><li>使用<code>python -m http.server 8888</code> 在您的虚拟机中启动一个Web 服务器并通过本机的<code>http://localhost:9999</code> 访问虚拟机上的Web 服务器</li><li>使用<code>sudo vim /etc/ssh/sshd_config</code> 编辑 SSH服务器配置，通过修改<code>PasswordAuthentication</code>的值来禁用密码验证。通过修改<code>PermitRootLogin</code>的值来禁用root 登录。然后使用<code>sudo service sshd restart</code>重启<code>ssh</code> 服务器，然后重新尝试。</li><li>(附加题) 在虚拟机中安装 <ahref="https://mosh.org/"><code>mosh</code></a>并启动连接。然后断开服务器/虚拟机的网络适配器。mosh可以恢复连接吗？</li><li>(附加题) 查看<code>ssh</code>的<code>-N</code> 和 <code>-f</code>选项的作用，找出在后台进行端口转发的命令是什么？</li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>course-shell</title>
    <link href="/2023/06/05/course-shell/"/>
    <url>/2023/06/05/course-shell/</url>
    
    <content type="html"><![CDATA[<h1 id="动机">动机</h1><p>作为计算机科学家，我们都知道计算机最擅长帮助我们完成重复性的工作。但是我们却常常忘记这一点也适用于我们使用计算机的方式，而不仅仅是利用计算机程序去帮我们求解问题。在从事与计算机相关的工作时，我们有很多触手可及的工具可以帮助我们更高效的解决问题。但是我们中的大多数人实际上只利用了这些工具中的很少一部分，我们常常只是死记硬背一些如咒语般的命令，或是当我们卡住的时候，盲目地从网上复制粘贴一些命令。</p><p>本课程意在帮你解决这一问题。</p><p>我们希望教会您如何挖掘现有工具的潜力，并向您介绍一些新的工具。也许我们还可以促使您想要去探索（甚至是去开发）更多的工具。我们认为这是大多数计算机科学相关课程中缺少的重要一环。</p><h1 id="课程结构">课程结构</h1><p>本课程包含 11 个时长在一小时左右的讲座，每一个讲座都会关注一个 <ahref="/missing-semester/2020/">特定的主题</a>。尽管这些讲座之间基本上是各自独立的，但随着课程的进行，我们会假定您已经掌握了之前的内容。每个讲座都有在线笔记供查阅，但是课上的很多内容并不会包含在笔记中。因此我们也会把课程录制下来发布到互联网上供大家观看学习。</p><p>我们希望能在这 11个一小时讲座中涵盖大部分必须的内容，因此课程的信息密度是相当大的。为了能帮助您以自己的节奏来掌握讲座内容，每次课程都包含一组练习来帮助您掌握本节课的重点。课后我们会安排答疑的时间来回答您的问题。如果您参加的是在线课程，可以发送邮件到<a href="mailto:missing-semester@mit.edu">missing-semester@mit.edu</a>来联系我们。</p><p>由于时长的限制，我们不可能达到那些专门课程一样的细致程度，我们会适时地将您介绍一些优秀的资源，帮助您深入的理解相关的工具或主题。但是如果您还有一些特别关注的话题，也请联系我们。</p><h1 id="主题-1-the-shell">主题 1: The Shell</h1><h2 id="shell-是什么">shell 是什么？</h2><p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是AR/VR 都已经无处不在。 这些交互接口可以覆盖 80%的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p><p>几乎所有您能够接触到的平台都支持某种形式的shell，有些甚至还提供了多种 shell供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p><p>本节课我们会使用 Bourne Again SHell, 简称 "bash" 。这是被最广泛使用的一种 shell，它的语法和其他的 shell都是类似的。打开shell<em>提示符</em>（您输入指令的地方），您首先需要打开 <em>终端</em>。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p><h2 id="使用-shell">使用 shell</h2><p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ <br></code></pre></td></tr></table></figure><p>这是 shell 最主要的文本接口。它告诉你，你的主机名是<code>missing</code> 并且您当前的工作目录（"current workingdirectory"）或者说您当前所在的位置是 <code>~</code> (表示 "home")。<code>$</code> 符号表示您现在的身份不是 root用户（稍后会介绍）。在这个提示符中，您可以输入 <em>命令</em>，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ date<br>Fri 10 Jan 2020 11:49:31 AM EST<br>missing:~$ <br></code></pre></td></tr></table></figure><p>这里，我们执行了 <code>date</code>这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell等待我们输入其他命令。我们可以在执行命令的同时向程序传递 <em>参数</em>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ echo hello<br>hello<br></code></pre></td></tr></table></figure><p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数<code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为My Photos的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号<code>\</code> 进行处理（<code>My\ Photos</code>）。</p><p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或<code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在shell 中执行命令时，您实际上是在执行一段 shell可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em><code>$PATH</code>，它会列出当 shell接到某条指令时，进行程序搜索的路径：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ echo $PATH<br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>missing:~$ which echo<br>/bin/echo<br>missing:~$ /bin/echo $PATH<br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br></code></pre></td></tr></table></figure><p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行<code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由<code>:</code>所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是<em>可执行程序</em>，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用<code>which</code> 程序。我们也可以绕过<code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</p><h2 id="在shell中导航">在shell中导航</h2><p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用<code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code>代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如：<code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个<em>绝对路径</em>，其他的都是 <em>相对路径</em>。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用<code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code>命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code>表示上级目录：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ pwd<br>/home/missing<br>missing:~$ cd /home<br>missing:/home$ pwd<br>/home<br>missing:/home$ cd ..<br>missing:/$ pwd<br>/<br>missing:/$ cd ./home<br>missing:/home$ pwd<br>/home<br>missing:/home$ cd missing<br>missing:~$ pwd<br>/home/missing<br>missing:~$ ../../bin/echo hello<br>hello<br></code></pre></td></tr></table></figure><p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p><p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p><p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ ls<br>missing:~$ cd ..<br>missing:/home$ ls<br>missing<br>missing:/home$ cd ..<br>missing:/$ ls<br>bin<br>boot<br>dev<br>etc<br>home<br>...<br></code></pre></td></tr></table></figure><p>除非我们利用第一个参数指定目录，否则 <code>ls</code>会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以<code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用<code>-h</code> 或 <code>--help</code>标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code>的输出如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">-l                         use <span class="hljs-keyword">a</span> <span class="hljs-keyword">long</span> listing <span class="hljs-built_in">format</span><br></code></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ ls -l /home<br>drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing<br></code></pre></td></tr></table></figure><p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符<code>d</code> 表示 <code>missing</code>是一个目录。然后接下来的九个字符，每三个字符构成一组。（<code>rwx</code>）.它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>）以及其他所有人具有的权限。其中 <code>-</code>表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code>文件夹（例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code>目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code>权限，也就是说任何人都可以执行这些程序。</p><p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如<code>mv</code>（用于重命名或移动文件）、<code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p><p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试<code>man</code>这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用<code>q</code> 可以退出该程序。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ man ls<br></code></pre></td></tr></table></figure><h2 id="在程序间创建连接">在程序间创建连接</h2><p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。但是，我们也可以重定向这些流！</p><p>最简单的重定向是 <code>&lt; file</code> 和<code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ echo hello &gt; hello.txt<br>missing:~$ cat hello.txt<br>hello<br>missing:~$ cat &lt; hello.txt<br>hello<br>missing:~$ cat &lt; hello.txt &gt; hello2.txt<br>missing:~$ cat hello2.txt<br>hello<br></code></pre></td></tr></table></figure><p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（<em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code>操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console">missing:~$ ls -l / | tail -n1<br>drwxr-xr-x 1 root  root  4096 Jun 20  2019 var<br>missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2<br>219<br></code></pre></td></tr></table></figure><p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p><h2 id="一个功能全面又强大的工具">一个功能全面又强大的工具</h2><p>对于大多数的类 Unix系统，有一类用户是非常特殊的，那就是：根用户（root user）。您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。取而代之的是我们会在需要的时候使用 <code>sudo</code>命令。顾名思义，它的作用是让您可以以 su（super user 或 root的简写）的身份执行一些操作。 当您遇到拒绝访问（permissiondenied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p><p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code>文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code>文件则暴露了一些内核（kernel）参数。因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意Windows 和 macOS 没有这个文件</strong></p><p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code>文件中，它位于</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/sys/</span><span class="hljs-keyword">class</span>/backlight<br></code></pre></td></tr></table></figure><p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="hljs-string">&#x27;*brightness*&#x27;</span></span><br>/sys/class/backlight/thinkpad_screen/brightness<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /sys/class/backlight/thinkpad_screen</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">echo</span> 3 &gt; brightness</span><br>An error occurred while redirecting file &#x27;brightness&#x27;<br>open: Permission denied<br></code></pre></td></tr></table></figure><p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了<code>sudo</code> 命令！关于shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和<code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。<code>echo</code> 等程序并不知道 <code>|</code>的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况，<em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code>前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时shell 不是根用户。</p><p>明白这一点后，我们可以这样操作：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> 3 | sudo <span class="hljs-built_in">tee</span> brightness</span><br></code></pre></td></tr></table></figure><p>因为打开 <code>/sys</code> 文件的是 <code>tee</code>这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。这样您就可以在 <code>/sys</code>中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> 1 | sudo <span class="hljs-built_in">tee</span> /sys/class/leds/input6::scrolllock/brightness</span><br></code></pre></td></tr></table></figure><h1 id="接下来.....">接下来.....</h1><p>学到这里，您掌握的 shell知识已经可以完成一些基础的任务了。您应该已经可以查找感兴趣的文件并使用大多数程序的基本功能了。在下一场讲座中，我们会探讨如何利用 shell及其他工具执行并自动化更复杂的任务。</p><h1 id="课后练习">课后练习</h1><p>[习题解答](//)本课程中的每节课都包含一系列练习题。有些题目是有明确目的的，另外一些则是开放题，例如“尝试使用X 和 Y”，我们强烈建议您一定要动手实践，用于尝试这些内容。此外，我们没有为这些练习题提供答案。如果有任何困难，您可以发送邮件给我们并描述你已经做出的尝试，我们会设法帮您解答。</p><ol start="0" type="1"><li><p>本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是Windows，则您不应该使用 cmd 或是 Powershell；您可以使用<ahref="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystemfor Linux</a>或者是 Linux虚拟机。使用<code>echo $SHELL</code>命令可以查看您的 shell是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。</p></li><li><p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code>的文件夹。</p></li><li><p>用 <code>man</code> 查看程序 <code>touch</code>的使用手册。</p></li><li><p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫<code>semester</code> 的文件。</p></li><li><p>将以下内容一行一行地写入 <code>semester</code> 文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>curl --<span class="hljs-built_in">head</span> --silent https://missing.csail.mit.edu<br></code></pre></td></tr></table></figure> 第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而<code>!</code> 即使被双引号（<code>"</code>）包裹也具有特殊的含义。单引号（<code>'</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考<ahref="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bashquoting 手册</a></p></li><li><p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用<code>ls</code> 命令来获取信息并理解其不能执行的原因。</p></li><li><p>查看 <code>chmod</code> 的手册(例如，使用 <code>man chmod</code>命令)</p></li><li><p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code>能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<ahref="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></p></li><li><p>使用 <code>|</code> 和 <code>&gt;</code> ，将<code>semester</code> 文件输出的最后更改日期信息，写入主目录下的<code>last-modified.txt</code> 的文件中</p></li><li><p>写一段命令来从 <code>/sys</code>中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有sysfs，所以 Mac 用户可以跳过这一题。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>data-wrangling</title>
    <link href="/2023/06/05/data-wrangling/"/>
    <url>/2023/06/05/data-wrangling/</url>
    
    <content type="html"><![CDATA[<p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式?肯定有过，对吧！这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p><p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p><p>例如这样一条命令<code>journalctl | grep -i intel</code>，它会找到所有包含intel(不区分大小写)的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含intel的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p><p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl<br></code></pre></td></tr></table></figure><p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl | grep sshd<br></code></pre></td></tr></table></figure><p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的<code>grep</code> 程序！ <code>ssh</code>太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论<code>ssh</code>的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver <span class="hljs-string">&#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27;</span> | less<br></code></pre></td></tr></table></figure><p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。<code>less</code>为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh myserver <span class="hljs-string">&#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27;</span> &gt; ssh.log</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">less ssh.log</span><br></code></pre></td></tr></table></figure><p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下<code>sed</code> 这个非常强大的工具。</p><p><code>sed</code> 是一个基于文本编辑器<code>ed</code>构建的"流编辑器"。在 <code>sed</code>中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是<code>s</code>，即<em>替换</em>命令，例如我们可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl<br> | grep sshd<br> | grep <span class="hljs-string">&quot;Disconnected from&quot;</span><br> | sed <span class="hljs-string">&#x27;s/.*Disconnected from //&#x27;</span><br></code></pre></td></tr></table></figure><p>上面这段命令中，我们使用了一段简单的<em>正则表达式</em>。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code>命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中<code>REGEX</code> 部分是我们需要使用的正则表达式，而<code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p><h2 id="正则表达式">正则表达式</h2><p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习：<code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是）<code>/</code>开始和结束。大多数的 ASCII字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p><ul><li><code>.</code> 除换行符之外的"任意单个字符"</li><li><code>*</code> 匹配前面字符零次或多次</li><li><code>+</code> 匹配前面字符一次或多次</li><li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和<code>c</code> 中的任意一个</li><li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或<code>RX2</code>的结果</li><li><code>^</code> 行首</li><li><code>$</code> 行尾</li></ul><p><code>sed</code>的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加<code>\</code>才能使其具有特殊含义。或者，您也可以添加<code>-E</code>选项来支持这些匹配。</p><p>回过头我们再看<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含"Disconnectedfrom"的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将"Disconnected from" 作为自己的用户名会怎样呢？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Jan</span> <span class="hljs-number">17</span> <span class="hljs-number">03</span>:<span class="hljs-number">13</span>:<span class="hljs-number">00</span> thesquareplanet.com sshd[<span class="hljs-number">2631</span>]: Disconnected from invalid user Disconnected from <span class="hljs-number">46.97.239.16</span> port <span class="hljs-number">55920</span><span class="hljs-meta"> [preauth]</span><br></code></pre></td></tr></table></figure><p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code>在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">46.97.239.16</span> port <span class="hljs-number">55920</span> <span class="hljs-string">[preauth]</span><br></code></pre></td></tr></table></figure><p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给<code>*</code> 或 <code>+</code> 增加一个<code>?</code>后缀使其变成非贪婪模式，但是很可惜 <code>sed</code>并不支持该后缀。不过，我们可以切换到 perl的命令行模式，该模式支持编写这样的正则表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">perl -pe <span class="hljs-string">&#x27;s/.*?Disconnected from //&#x27;</span><br></code></pre></td></tr></table></figure><p>让我们回到 <code>sed</code>命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code>是最常见的工具。<code>sed</code>还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code>本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p><p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p><p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配<em>一整行</em>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| sed -E <span class="hljs-string">&#x27;s/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//&#x27;</span><br></code></pre></td></tr></table></figure><p>让我们借助正则表达式在线调试工具<ahref="https://regex101.com/r/qqbZqh/2">regex debugger</a>来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（<code>[^ ]+</code>会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀<code>[preauth]</code>，最后再匹配行尾。</p><p>注意，这样做的话，即使用户名是“Disconnectedfrom”，对匹配结果也不会有任何影响，您知道这是为什么吗？</p><p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名<em>保留</em>下来。对此，我们可以使用“捕获组（capturegroups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如<code>\1</code>、<code>\2</code>、<code>\3</code>等等，因此可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| sed -E <span class="hljs-string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br></code></pre></td></tr></table></figure><p>想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章<ahref="https://www.regular-expressions.info/email.html">e-mailaddress</a>，匹配电子邮箱可一点<ahref="https://emailregex.com/">也不简单</a>。网络上还有很多关于如何匹配电子邮箱地址的<ahref="https://stackoverflow.com/questions/201323/how-to-validate-an-email-address-using-a-regular-expression/1917982">讨论</a>。人们还为其编写了<ahref="https://fightingforalostcause.net/content/misc/2006/compare-email-regex.php">测试用例</a>及<ahref="https://mathiasbynens.be/demo/url-regex">测试矩阵</a>。您甚至可以编写一个用于判断一个数<ahref="https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">是否为质数</a>的正则表达式。</p><p>正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。</p><h2 id="回到数据整理">回到数据整理</h2><p>OK，现在我们有如下表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl<br> | grep sshd<br> | grep <span class="hljs-string">&quot;Disconnected from&quot;</span><br> | sed -E <span class="hljs-string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br></code></pre></td></tr></table></figure><p><code>sed</code> 还可以做很多各种各样有趣的事情，例如文本注入：(使用<code>i</code> 命令)，打印特定的行 (使用<code>p</code>命令)，基于索引选择特定行等等。详情请见<code>man sed</code>!</p><p>现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl<br> | grep sshd<br> | grep <span class="hljs-string">&quot;Disconnected from&quot;</span><br> | sed -E <span class="hljs-string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c<br></code></pre></td></tr></table></figure><p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code>会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl<br> | grep sshd<br> | grep <span class="hljs-string">&quot;Disconnected from&quot;</span><br> | sed -E <span class="hljs-string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c<br> | <span class="hljs-built_in">sort</span> -nk1,1 | <span class="hljs-built_in">tail</span> -n10<br></code></pre></td></tr></table></figure><p><code>sort -n</code>会按照数字顺序对输入进行排序（默认情况下是按照字典序排序<code>-k1,1</code>则表示“仅基于以空格分割的第一列进行排序”。<code>,n</code>部分表示“仅排序到第n个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p><p>如果我们希望得到登录次数最少的用户，我们可以使用 <code>head</code>来代替<code>tail</code>。或者使用<code>sort -r</code>来进行倒序排序。</p><p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl<br> | grep sshd<br> | grep <span class="hljs-string">&quot;Disconnected from&quot;</span><br> | sed -E <span class="hljs-string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c<br> | <span class="hljs-built_in">sort</span> -nk1,1 | <span class="hljs-built_in">tail</span> -n10<br> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="hljs-built_in">paste</span> -sd,<br></code></pre></td></tr></table></figure><p>如果您使用的是 MacOS：注意这个命令并不能配合 MacOS 系统默认的 BSD<code>paste</code>使用。参考<ahref="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与shell</a>的习题内容获取更多相关信息。</p><p>我们可以利用<code>paste</code>命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割(<code>-d</code>)，那<code>awk</code>的作用又是什么呢？</p><h2 id="awk----另外一种编辑器">awk -- 另外一种编辑器</h2><p><code>awk</code>其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code>可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p><p>首先， <code>&#123;print $2&#125;</code> 的作用是什么？ <code>awk</code>程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到<code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code>的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p><p>让我们康康，还有什么炫酷的操作可以做。让我们统计一下所有以<code>c</code>开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| awk <span class="hljs-string">&#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27;</span> | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure><p>让我们好好分析一下。首先，注意这次我们为<code>awk</code>指定了一个匹配模式串（也就是<code>&#123;...&#125;</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用<code>wc -l</code> 统计输出结果的行数。</p><p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">BEGIN</span> &#123; rows = <span class="hljs-number">0</span> &#125;<br><span class="hljs-variable">$1</span> == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-variable">$2</span> ~ <span class="hljs-regexp">/^c[^ ]*e$/</span> &#123; rows += <span class="hljs-variable">$1</span> &#125;<br><span class="hljs-keyword">END</span> &#123; print rows &#125;<br></code></pre></td></tr></table></figure><p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（<code>END</code>则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃<code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以<ahref="https://backreference.org/2010/02/10/idiomatic-awk">解决所有问题</a>。至于怎么做，就留给读者们做课后练习吧。</p><h2 id="分析数据">分析数据</h2><p>想做数学计算也是可以的！例如这样，您可以将每行的数字加起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">| <span class="hljs-built_in">paste</span> -sd+ | bc -l<br></code></pre></td></tr></table></figure><p>下面这种更加复杂的表达式也可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2*(<span class="hljs-subst">$(data | paste -sd+)</span>)&quot;</span> | bc -l<br></code></pre></td></tr></table></figure><p>您可以通过多种方式获取统计数据。如果已经安装了R语言，<ahref="https://github.com/nferraz/st"><code>st</code></a>是个不错的选择：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl<br> | grep sshd<br> | grep <span class="hljs-string">&quot;Disconnected from&quot;</span><br> | sed -E <span class="hljs-string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c<br> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | R --slave -e <span class="hljs-string">&#x27;x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)&#x27;</span><br></code></pre></td></tr></table></figure><p>R 也是一种编程语言，它非常适合被用来进行数据分析和<ahref="https://ggplot2.tidyverse.org/">绘制图表</a>。这里我们不会讲的特别详细，您只需要知道<code>summary</code>可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用R语言就可以得到我们想要的统计数据。</p><p>如果您希望绘制一些简单的图表， <code>gnuplot</code>可以帮助到您：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh myserver journalctl<br> | grep sshd<br> | grep <span class="hljs-string">&quot;Disconnected from&quot;</span><br> | sed -E <span class="hljs-string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c<br> | <span class="hljs-built_in">sort</span> -nk1,1 | <span class="hljs-built_in">tail</span> -n10<br> | gnuplot -p -e <span class="hljs-string">&#x27;set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="利用数据整理来确定参数">利用数据整理来确定参数</h2><p>有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合<code>xargs</code> 即可实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rustup toolchain list | grep nightly | grep -vE <span class="hljs-string">&quot;nightly-x86&quot;</span> | sed <span class="hljs-string">&#x27;s/-x86.*//&#x27;</span> | xargs rustup toolchain uninstall<br></code></pre></td></tr></table></figure><h2 id="整理二进制数据">整理二进制数据</h2><p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用ffmpeg从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -<br> | convert - -colorspace gray -<br> | gzip<br> | ssh mymachine <span class="hljs-string">&#x27;gzip -d | tee copy.jpg | env DISPLAY=:0 feh -&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="课后练习">课后练习</h1><p>[习题解答](//)</p><ol type="1"><li><p>学习一下这篇简短的 <ahref="https://regexone.com/">交互式正则表达式教程</a>.</p></li><li><p>统计words文件 (<code>/usr/share/dict/words</code>)中包含至少三个<code>a</code> 且不以<code>'s</code>结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？<code>sed</code>的 <code>y</code>命令，或者 <code>tr</code>程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很有挑战性的问题：哪个组合从未出现过？</p></li><li><p>进行原地替换听上去很有诱惑力，例如：<code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有<code>sed</code>是这样的? 查看 <code>man sed</code>来完成这个问题</p></li><li><p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在Linux上需要用到<code>journalctl</code> ，而在 macOS 上使用<code>log show</code>。找到每次起到开始和结束时的时间戳。在Linux上类似这样操作：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Logs <span class="hljs-keyword">begin</span> <span class="hljs-keyword">at</span> ...<br></code></pre></td></tr></table></figure> 和 <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">systemd[<span class="hljs-number">577</span>]: <span class="hljs-symbol">Startup</span> finished in ...<br></code></pre></td></tr></table></figure> 在 macOS 上, <ahref="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">=== system boot:</span><br></code></pre></td></tr></table></figure><p>和 <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Previous <span class="hljs-keyword">shutdown </span><span class="hljs-built_in">cause</span>: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></p></li><li><p>查看之前三次重启启动信息中不同的部分(参见<code>journalctl</code>的<code>-b</code>选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用<code>sed '0,/STRING/d'</code>来删除<code>STRING</code>匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数(可以使用<code>uniq</code>)。最后，删除所有出现过3次的内容（因为这些内容是三次启动日志中的重复部分）。</p></li><li><p>在网上找一个类似 <ahref="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a>或者<ahref="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a>的数据集。或者从<ahref="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a>找一些。使用<code>curl</code>获取数据集并提取其中两列数据，如果您想要获取的是HTML数据，那么<ahref="https://github.com/EricChiang/pup"><code>pup</code></a>可能会更有帮助。对于JSON类型的数据，可以试试<ahref="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debugging</title>
    <link href="/2023/06/05/debugging-profiling/"/>
    <url>/2023/06/05/debugging-profiling/</url>
    
    <content type="html"><![CDATA[<p>代码不能完全按照您的想法运行，它只能完全按照您的写法运行，这是编程界的一条金科玉律。</p><p>让您的写法符合您的想法是非常困难的。在这节课中，我们会传授给您一些非常有用技术，帮您处理代码中的bug 和程序性能问题。</p><h1 id="调试代码">调试代码</h1><h2 id="打印调试法与日志">打印调试法与日志</h2><p>"最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句" — BrianKernighan, <em>Unix 新手入门</em>。</p><p>调试代码的第一种方法往往是在您发现问题的地方添加一些打印语句，然后不断重复此过程直到您获取了足够的信息并找到问题的根本原因。</p><p>另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势：</p><ul><li>您可以将日志写入文件、socket或者甚至是发送到远端服务器而不仅仅是标准输出；</li><li>日志可以支持严重等级（例如 INFO, DEBUG, WARN,ERROR等)，这使您可以根据需要过滤日志；</li><li>对于新发现的问题，很可能您的日志中已经包含了可以帮助您定位问题的足够的信息。</li></ul><p><a href="/static/files/logger.py">这里</a>是一个包含日志的例程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python logger.py<br><span class="hljs-comment"># Raw output as with just prints</span><br>$ python logger.py <span class="hljs-built_in">log</span><br><span class="hljs-comment"># Log formatted output</span><br>$ python logger.py <span class="hljs-built_in">log</span> ERROR<br><span class="hljs-comment"># Print only ERROR levels and above</span><br>$ python logger.py color<br><span class="hljs-comment"># Color formatted output</span><br></code></pre></td></tr></table></figure><p>有很多技巧可以使日志的可读性变得更好，我最喜欢的一个是技巧是对其进行着色。到目前为止，您应该已经知道，以彩色文本显示终端信息时可读性更好。但是应该如何设置呢？</p><p><code>ls</code> 和 <code>grep</code> 这样的程序会使用 <ahref="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escapecodes</a>，它是一系列的特殊字符，可以使您的 shell改变输出结果的颜色。例如，执行<code>echo -e "\e[38;2;255;0;0mThis is red\e[0m"</code>会打印红色的字符串：<code>This is red</code> 。只要您的终端支持<ahref="https://gist.github.com/XVilka/8346728#terminals--true-color">真彩色</a>。如果您的终端不支持真彩色（例如MacOS 的 Terminal.app），您可以使用支持更加广泛的 16色，例如："(https://www.nginx.com/) web服务器就将其日志存放于<code>/var/log/nginx</code>。</p><p>目前，系统开始使用 <strong>systemlog</strong>，您所有的日志都会保存在这里。大多数（但不是全部的）Linux系统都会使用<code>systemd</code>，这是一个系统守护进程，它会控制您系统中的很多东西，例如哪些服务应该启动并运行。<code>systemd</code>会将日志以某种特殊格式存放于<code>/var/log/journal</code>，您可以使用 <ahref="http://man7.org/linux/man-pages/man1/journalctl.1.html"><code>journalctl</code></a>命令显示这些消息。</p><p>类似地，在 macOS 系统中是<code>/var/log/system.log</code>，但是有更多的工具会使用系统日志，它的内容可以使用<a href="https://www.manpagez.com/man/1/log/"><code>log show</code></a>显示。</p><p>对于大多数的 UNIX 系统，您也可以使用<ahref="http://man7.org/linux/man-pages/man1/dmesg.1.html"><code>dmesg</code></a>命令来读取内核的日志。</p><p>如果您希望将日志加入到系统日志中，您可以使用 <ahref="http://man7.org/linux/man-pages/man1/logger.1.html"><code>logger</code></a>这个 shell 程序。下面这个例子显示了如何使用<code>logger</code>并且如何找到能够将其存入系统日志的条目。</p><p>不仅如此，大多数的编程语言都支持向系统日志中写日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">logger <span class="hljs-string">&quot;Hello Logs&quot;</span><br><span class="hljs-comment"># On macOS</span><br><span class="hljs-built_in">log</span> show --last 1m | grep Hello<br><span class="hljs-comment"># On Linux</span><br>journalctl --since <span class="hljs-string">&quot;1m ago&quot;</span> | grep Hello<br></code></pre></td></tr></table></figure><p>正如我们在数据整理那节课上看到的那样，日志的内容可以非常的多，我们需要对其进行处理和过滤才能得到我们想要的信息。</p><p>如果您发现您需要对 <code>journalctl</code> 和 <code>log show</code>的结果进行大量的过滤，那么此时可以考虑使用它们自带的选项对其结果先过滤一遍再输出。还有一些像<a href="http://lnav.org/"><code>lnav</code></a>这样的工具，它为日志文件提供了更好的展现和浏览方式。</p><h2 id="调试器">调试器</h2><p>当通过打印已经不能满足您的调试需求时，您应该使用调试器。</p><p>调试器是一种可以允许我们和正在执行的程序进行交互的程序，它可以做到：</p><ul><li>当到达某一行时将程序暂停；</li><li>一次一条指令地逐步执行程序；</li><li>程序崩溃后查看变量的值；</li><li>满足特定条件时暂停程序；</li><li>其他高级功能。</li></ul><p>很多编程语言都有自己的调试器。Python 的调试器是<ahref="https://docs.python.org/3/library/pdb.html"><code>pdb</code></a>.</p><p>下面对<code>pdb</code> 支持的命令进行简单的介绍：</p><ul><li><strong>l</strong>(ist) -显示当前行附近的11行或继续执行之前的显示；</li><li><strong>s</strong>(tep) -执行当前行，并在第一个可能的地方停止；</li><li><strong>n</strong>(ext) - 继续执行直到当前函数的下一条语句或者return 语句；</li><li><strong>b</strong>(reak) - 设置断点（基于传入的参数）；</li><li><strong>p</strong>(rint) -在当前上下文对表达式求值并打印结果。还有一个命令是<strong>pp</strong>，它使用 <ahref="https://docs.python.org/3/library/pprint.html"><code>pprint</code></a>打印；</li><li><strong>r</strong>(eturn) - 继续执行直到当前函数返回；</li><li><strong>q</strong>(uit) - 退出调试器。</li></ul><p>让我们使用<code>pdb</code> 来修复下面的 Python代码（参考讲座视频）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bubble_sort</span>(<span class="hljs-params">arr</span>):<br>    n = <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>]:<br>                arr[j] = arr[j+<span class="hljs-number">1</span>]<br>                arr[j+<span class="hljs-number">1</span>] = arr[j]<br>    <span class="hljs-keyword">return</span> arr<br><br><span class="hljs-built_in">print</span>(bubble_sort([<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>]))<br></code></pre></td></tr></table></figure><p>注意，因为 Python 是一种解释型语言，所以我们可以通过 <code>pdb</code>shell 执行命令。 <ahref="https://pypi.org/project/ipdb/"><code>ipdb</code></a>是一种增强型的 <code>pdb</code> ，它使用<ahref="https://ipython.org"><code>IPython</code></a> 作为 REPL并开启了tab 补全、语法高亮、更好的回溯和更好的内省，同时还保留了<code>pdb</code>模块相同的接口。</p><p>对于更底层的编程语言，您可能需要了解一下 <ahref="https://www.gnu.org/software/gdb/"><code>gdb</code></a> (以及它的改进版 <ahref="https://github.com/pwndbg/pwndbg"><code>pwndbg</code></a>) 和 <ahref="https://lldb.llvm.org/"><code>lldb</code></a>。</p><p>它们都对类 C语言的调试进行了优化，它允许您探索任意进程及其机器状态：寄存器、堆栈、程序计数器等。</p><h2 id="专门工具">专门工具</h2><p>即使您需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到您。当您的程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用<ahref="https://en.wikipedia.org/wiki/System_call">系统调用</a>。有一些命令可以帮助您追踪您的程序执行的系统调用。在Linux 中可以使用<ahref="http://man7.org/linux/man-pages/man1/strace.1.html"><code>strace</code></a>，在 macOS 和 BSD 中可以使用 <ahref="http://dtrace.org/blogs/about/"><code>dtrace</code></a>。<code>dtrace</code>用起来可能有些别扭，因为它使用的是它自有的 <code>D</code>语言，但是我们可以使用一个叫做 <ahref="https://www.manpagez.com/man/1/dtruss/"><code>dtruss</code></a>的封装使其具有和 <code>strace</code> (更多信息参考 <ahref="https://8thlight.com/blog/colin-jones/2015/11/06/dtrace-even-better-than-strace-for-osx.html">这里</a>)类似的接口</p><p>下面的例子展现来如何使用 <code>strace</code> 或 <code>dtruss</code>来显示<code>ls</code> 执行时，对<ahref="http://man7.org/linux/man-pages/man2/stat.2.html"><code>stat</code></a>系统调用进行追踪对结果。若需要深入了解 <code>strace</code>，<ahref="https://blogs.oracle.com/linux/strace-the-sysadmins-microscope-v2">这篇文章</a>值得一读。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># On Linux</span><br>sudo strace -e lstat <span class="hljs-built_in">ls</span> -l &gt; /dev/null<br>4<br><span class="hljs-comment"># On macOS</span><br>sudo dtruss -t lstat64_extended <span class="hljs-built_in">ls</span> -l &gt; /dev/null<br></code></pre></td></tr></table></figure><p>有些情况下，我们需要查看网络数据包才能定位问题。像 <ahref="http://man7.org/linux/man-pages/man1/tcpdump.1.html"><code>tcpdump</code></a>和 <a href="https://www.wireshark.org/">Wireshark</a>这样的网络数据包分析工具可以帮助您获取网络数据包的内容并基于不同的条件进行过滤。</p><p>对于 web 开发， Chrome/Firefox 的开发者工具非常方便，功能也很强大： -源码 -查看任意站点的 HTML/CSS/JS 源码； - 实时地修改 HTML, CSS, JS 代码-修改网站的内容、样式和行为用于测试（从这一点您也能看出来，网页截图是不可靠的）；- Javascript shell - 在 JS REPL中执行命令； - 网络 - 分析请求的时间线；- 存储 - 查看 Cookies 和本地应用存储。</p><h2 id="静态分析">静态分析</h2><p>有些问题是您不需要执行代码就能发现的。例如，仔细观察一段代码，您就能发现某个循环变量覆盖了某个已经存在的变量或函数名；或是有个变量在被读取之前并没有被定义。这种情况下 <ahref="https://en.wikipedia.org/wiki/Static_program_analysis">静态分析</a>工具就可以帮我们找到问题。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。</p><p>下面这段 Python 代码中存在几个问题。首先，我们的循环变量<code>foo</code>覆盖了之前定义的函数<code>foo</code>。最后一行，我们还把<code>bar</code>错写成了<code>baz</code>，因此当程序完成<code>sleep</code>(一分钟)后，执行到这一行的时候便会崩溃。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><span class="hljs-keyword">for</span> foo <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(foo)<br>bar = <span class="hljs-number">1</span><br>bar *= <span class="hljs-number">0.2</span><br>time.sleep(<span class="hljs-number">60</span>)<br><span class="hljs-built_in">print</span>(baz)<br></code></pre></td></tr></table></figure><p>静态分析工具可以发现此类的问题。当我们使用<ahref="https://pypi.org/project/pyflakes"><code>pyflakes</code></a>分析代码的时候，我们会得到与这两处 bug 相关的错误信息。<ahref="http://mypy-lang.org/"><code>mypy</code></a>则是另外一个工具，它可以对代码进行类型检查。这里，<code>mypy</code>会经过我们<code>bar</code> 起初是一个 <code>int</code> ，然后变成了<code>float</code>。这些问题都可以在不运行代码的情况下被发现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ pyflakes foobar.py<br>foobar.py:6: redefinition of unused <span class="hljs-string">&#x27;foo&#x27;</span> from line 3<br>foobar.py:11: undefined name <span class="hljs-string">&#x27;baz&#x27;</span><br><br>$ mypy foobar.py<br>foobar.py:6: error: Incompatible types <span class="hljs-keyword">in</span> assignment (expression has <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;int&quot;</span>, variable has <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;Callable[[], Any]&quot;</span>)<br>foobar.py:9: error: Incompatible types <span class="hljs-keyword">in</span> assignment (expression has <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;float&quot;</span>, variable has <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;int&quot;</span>)<br>foobar.py:11: error: Name <span class="hljs-string">&#x27;baz&#x27;</span> is not defined<br>Found 3 errors <span class="hljs-keyword">in</span> 1 file (checked 1 <span class="hljs-built_in">source</span> file)<br></code></pre></td></tr></table></figure><p>在 shell 工具那一节课的时候，我们介绍了 <ahref="https://www.shellcheck.net/"><code>shellcheck</code></a>，这是一个类似的工具，但它是应用于shell 脚本的。</p><p>大多数的编辑器和 IDE都支持在编辑界面显示这些工具的分析结果、高亮有警告和错误的位置。这个过程通常称为 <strong>code linting</strong>。风格检查或安全检查的结果同样也可以进行相应的显示。</p><p>在 vim 中，有 <ahref="https://vimawesome.com/plugin/ale"><code>ale</code></a> 或 <ahref="https://vimawesome.com/plugin/syntastic"><code>syntastic</code></a>可以帮助您做同样的事情。 在 Python 中， <ahref="https://www.pylint.org"><code>pylint</code></a> 和 <ahref="https://pypi.org/project/pep8/"><code>pep8</code></a>是两种用于进行风格检查的工具，而 <ahref="https://pypi.org/project/bandit/"><code>bandit</code></a>工具则用于检查安全相关的问题。</p><p>对于其他语言的开发者来说，静态分析工具可以参考这个列表：<ahref="https://github.com/mre/awesome-static-analysis">Awesome StaticAnalysis</a> (您也许会对 <em>Writing</em> 一节感兴趣) 。对于 linters则可以参考这个列表： <ahref="https://github.com/caramelomartins/awesome-linters">AwesomeLinters</a>。</p><p>对于风格检查和代码格式化，还有以下一些工具可以作为补充：用于 Python的 <a href="https://github.com/psf/black"><code>black</code></a>、用于Go 语言的 <code>gofmt</code>、用于 Rust 的 <code>rustfmt</code> 或是用于JavaScript, HTML 和 CSS 的 <ahref="https://prettier.io/"><code>prettier</code></a>。这些工具可以自动格式化您的代码，这样代码风格就可以与常见的风格保持一致。尽管您可能并不想对代码进行风格控制，标准的代码风格有助于方便别人阅读您的代码，也可以方便您阅读它的代码。</p><h1 id="性能分析">性能分析</h1><p>即使您的代码能够像您期望的一样运行，但是如果它消耗了您全部的 CPU和内存，那么它显然也不是个好程序。算法课上我们通常会介绍大O标记法，但却没教给我们如何找到程序中的热点。鉴于 <ahref="http://wiki.c2.com/?PrematureOptimization">过早的优化是万恶之源</a>，您需要学习性能分析和监控工具，它们会帮助您找到程序中最耗时、最耗资源的部分，这样您就可以有针对性的进行性能优化。</p><h2 id="计时">计时</h2><p>和调试代码类似，大多数情况下我们只需要打印两处代码之间的时间即可发现问题。下面这个例子中，我们使用了Python 的 <ahref="https://docs.python.org/3/library/time.html"><code>time</code></a>模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time, random<br>n = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) * <span class="hljs-number">100</span><br><br><span class="hljs-comment"># 获取当前时间 </span><br>start = time.time()<br><br><span class="hljs-comment"># 执行一些操作</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="hljs-built_in">format</span>(n))<br>time.sleep(n/<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment"># 比较当前时间和起始时间</span><br><span class="hljs-built_in">print</span>(time.time() - start)<br><br><span class="hljs-comment"># Output</span><br><span class="hljs-comment"># Sleeping for 500 ms</span><br><span class="hljs-comment"># 0.5713930130004883</span><br></code></pre></td></tr></table></figure><p>不过，执行时间（wall clocktime）也可能会误导您，因为您的电脑可能也在同时运行其他进程，也可能在此期间发生了等待。对于工具来说，需要区分真实时间、用户时间和系统时间。通常来说，用户时间+系统时间代表了您的进程所消耗的实际CPU （更详细的解释可以参照<ahref="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">这篇文章</a>）。</p><ul><li>真实时间 -从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待I/O或网络）；</li><li><em>User</em> - CPU 执行用户代码所花费的时间；</li><li><em>Sys</em> - CPU 执行系统内核代码所花费的时间。</li></ul><p>例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加 <ahref="http://man7.org/linux/man-pages/man1/time.1.html"><code>time</code></a>前缀。网络不好的情况下您可能会看到下面的输出结果。请求花费了 2s才完成，但是进程仅花费了 15ms 的 CPU 用户时间和 12ms 的 CPU内核时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ time curl https://missing.csail.mit.edu &amp;&gt; /dev/null<br>real    0m2.561s<br>user    0m0.015s<br>sys     0m0.012s<br></code></pre></td></tr></table></figure><h2 id="性能分析工具profilers">性能分析工具（profilers）</h2><h3 id="cpu">CPU</h3><p>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU性能分析工具。 CPU 性能分析工具有两种：追踪分析器（<em>tracing</em>）及采样分析器（<em>sampling</em>）。追踪分析器会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。它们使用这些记录来生成统计信息，显示程序在哪些事情上花费了最多的时间。如果您希望了解更多相关信息，可以参考<ahref="https://jvns.ca/blog/2017/12/17/how-do-ruby---python-profilers-work-">这篇</a>介绍性的文章。</p><p>大多数的编程语言都有一些基于命令行的分析器，我们可以使用它们来分析代码。它们通常可以集成在IDE 中，但是本节课我们会专注于这些命令行工具本身。</p><p>在 Python 中，我们使用 <code>cProfile</code>模块来分析每次函数调用所消耗的时间。在下面的例子中，我们实现了一个基础的 grep 命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-keyword">import</span> sys, re<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grep</span>(<span class="hljs-params">pattern, file</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-built_in">print</span>(file)<br>        <span class="hljs-keyword">for</span> i, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(f.readlines()):<br>            pattern = re.<span class="hljs-built_in">compile</span>(pattern)<br>            <span class="hljs-keyword">match</span> = pattern.search(line)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, line), end=<span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    times = <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>])<br>    pattern = sys.argv[<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(times):<br>        <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> sys.argv[<span class="hljs-number">3</span>:]:<br>            grep(pattern, file)<br></code></pre></td></tr></table></figure><p>我们可以使用下面的命令来对这段代码进行分析。通过它的输出我们可以知道，IO消耗了大量的时间，编译正则表达式也比较耗费时间。因为正则表达式只需要编译一次，我们可以将其移动到for 循环外面来改进性能。</p><figure class="highlight profile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs profile">$ python -m cProfile -s <span class="hljs-keyword">tottime</span> grep.py 1000 &#x27;^(import|\s*def)[^,]*$&#x27; *.py<br><br>[omitted program output]<br><br> <span class="hljs-keyword">ncalls</span>  <span class="hljs-keyword">tottime</span>  percall  <span class="hljs-keyword">cumtime</span>  percall <span class="hljs-keyword">filename</span>:lineno(function)<br>   <span class="hljs-number">8000</span>    <span class="hljs-number">0.266</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.292</span>    <span class="hljs-number">0.000</span> &#123;built-in method io.open&#125;<br>   8000    0.153    0.000    0.894    0.000 grep.py:<span class="hljs-number">5</span>(<span class="hljs-string">grep</span>)<br>  <span class="hljs-number">17000</span>    <span class="hljs-number">0.101</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.101</span>    <span class="hljs-number">0.000</span> &#123;built-in method builtins.print&#125;<br>   8000    0.100    0.000    0.129    0.000 &#123;method &#x27;readlines&#x27; of &#x27;_io._IOBase&#x27; objects&#125;<br>  93000    0.097    0.000    0.111    0.000 re.py:<span class="hljs-number">286</span>(<span class="hljs-string">_compile</span>)<br>  <span class="hljs-number">93000</span>    <span class="hljs-number">0.069</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.069</span>    <span class="hljs-number">0.000</span> &#123;method <span class="hljs-string">&#x27;search&#x27;</span> of <span class="hljs-string">&#x27;_sre.SRE_Pattern&#x27;</span> objects&#125;<br>  <span class="hljs-number">93000</span>    <span class="hljs-number">0.030</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.141</span>    <span class="hljs-number">0.000</span> re.py:<span class="hljs-number">231</span>(<span class="hljs-string">compile</span>)<br>  <span class="hljs-number">17000</span>    <span class="hljs-number">0.019</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.029</span>    <span class="hljs-number">0.000</span> codecs.py:<span class="hljs-number">318</span>(<span class="hljs-string">decode</span>)<br>      <span class="hljs-number">1</span>    <span class="hljs-number">0.017</span>    <span class="hljs-number">0.017</span>    <span class="hljs-number">0.911</span>    <span class="hljs-number">0.911</span> grep.py:<span class="hljs-number">3</span>(<span class="hljs-string">&lt;module&gt;</span>)<br><br>[omitted lines]<br></code></pre></td></tr></table></figure><p>关于 Python 的 <code>cProfile</code>分析器（以及其他一些类似的分析器），需要注意的是它显示的是每次函数调用的时间。看上去可能快到反直觉，尤其是如果您在代码里面使用了第三方的函数库，因为内部函数调用也会被看作函数调用。</p><p>更加符合直觉的显示分析信息的方式是包括每行代码的执行时间，这也是<em>行分析器</em>的工作。例如，下面这段Python 代码会向本课程的网站发起一个请求，然后解析响应返回的页面中的全部URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br><span class="hljs-comment"># 这个装饰器会告诉行分析器 </span><br><span class="hljs-comment"># 我们想要分析这个函数</span><br><span class="hljs-meta">@profile</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_urls</span>():<br>    response = requests.get(<span class="hljs-string">&#x27;https://missing.csail.mit.edu&#x27;</span>)<br>    s = BeautifulSoup(response.content, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>    urls = []<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> s.find_all(<span class="hljs-string">&#x27;a&#x27;</span>):<br>        urls.append(url[<span class="hljs-string">&#x27;href&#x27;</span>])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    get_urls()<br></code></pre></td></tr></table></figure><p>如果我们使用 Python 的 <code>cProfile</code>分析器，我们会得到超过2500行的输出结果，即使对其进行排序，我仍然搞不懂时间到底都花在哪了。如果我们使用<ahref="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a>，它会基于行来显示时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kernprof -l -v a.py<br>Wrote profile results to urls.py.lprof<br>Timer unit: 1e-06 s<br><br>Total time: 0.636188 s<br>File: a.py<br>Function: get_urls at line 5<br><br>Line <span class="hljs-comment">#  Hits         Time  Per Hit   % Time  Line Contents</span><br>==============================================================<br> 5                                           @profile<br> 6                                           def get_urls():<br> 7         1     613909.0 613909.0     96.5      response = requests.get(<span class="hljs-string">&#x27;https://missing.csail.mit.edu&#x27;</span>)<br> 8         1      21559.0  21559.0      3.4      s = BeautifulSoup(response.content, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br> 9         1          2.0      2.0      0.0      urls = []<br>10        25        685.0     27.4      0.1      <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> s.find_all(<span class="hljs-string">&#x27;a&#x27;</span>):<br>11        24         33.0      1.4      0.0          urls.append(url[<span class="hljs-string">&#x27;href&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="内存">内存</h3><p>像 C 或者 C++这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它。为了应对内存类的Bug，我们可以使用类似 <a href="https://valgrind.org/">Valgrind</a>这样的工具来检查内存泄漏问题。</p><p>对于 Python这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。</p><p>下面这个例子及其输出，展示了 <ahref="https://pypi.org/project/memory-profiler/">memory-profiler</a>是如何工作的（注意装饰器和 <code>line-profiler</code> 类似）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@profile</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>():<br>    a = [<span class="hljs-number">1</span>] * (<span class="hljs-number">10</span> ** <span class="hljs-number">6</span>)<br>    b = [<span class="hljs-number">2</span>] * (<span class="hljs-number">2</span> * <span class="hljs-number">10</span> ** <span class="hljs-number">7</span>)<br>    <span class="hljs-keyword">del</span> b<br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    my_func()<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python -m memory_profiler example.py<br>Line <span class="hljs-comment">#    Mem usage  Increment   Line Contents</span><br>==============================================<br>     3                           @profile<br>     4      5.97 MB    0.00 MB   def my_func():<br>     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)<br>     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)<br>     7     13.61 MB -152.59 MB       del b<br>     8     13.61 MB    0.00 MB       <span class="hljs-built_in">return</span> a<br></code></pre></td></tr></table></figure><h3 id="事件分析">事件分析</h3><p>在我们使用<code>strace</code>调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<ahref="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a>命令将 CPU的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p><p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cachelocality）、大量的页错误（pagefaults）或活锁（livelocks）。下面是关于常见命令的简介：</p><ul><li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li><li><code>perf stat COMMAND ARG1 ARG2</code> -收集与某个进程或指令相关的事件；</li><li><code>perf record COMMAND ARG1 ARG2</code> -记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li><li><code>perf report</code> - 格式化并打印 <code>perf.data</code>中的数据。</li></ul><h3 id="可视化">可视化</h3><p>使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。</p><p>对于采样分析器来说，常见的显示 CPU 分析数据的形式是 <ahref="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，火焰图会在Y 轴显示函数调用关系，并在 X轴显示其耗时的比例。火焰图同时还是可交互的，您可以深入程序的某一具体部分，并查看其栈追踪（您可以尝试点击下面的图片）。</p><p><ahref="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg"><imgsrc="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg"alt="FlameGraph" /></a></p><p>调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。在 Python 中您可以使用 <ahref="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a>来生成这些图片。</p><figure><imgsrc="https://upload.wikimedia.org/wikipedia/commons/2/2f/A_Call_Graph_generated_by_pycallgraph.png"alt="Call Graph" /><figcaption aria-hidden="true">Call Graph</figcaption></figure><h2 id="资源监控">资源监控</h2><p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p><p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU占用、内存使用、网络、磁盘使用等。</p><ul><li><strong>通用监控</strong> - 最流行的工具要数 <ahref="https://htop.dev/"><code>htop</code></a>,了，它是 <ahref="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a>的改进版。<code>htop</code>可以显示当前运行进程的多种统计信息。<code>htop</code>有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、<code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。还可以留意一下 <ahref="https://nicolargo.github.io/glances/"><code>glances</code></a>，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <ahref="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a>是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如I/O、网络、 CPU 利用率、上下文切换等等；</li><li><strong>I/O 操作</strong> - <ahref="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a>可以显示实时 I/O占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li><li><strong>磁盘使用</strong> - <ahref="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a>可以显示每个分区的信息，而 <ahref="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a>则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk<strong>u</strong>sage）。<code>-h</code>选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<ahref="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的<code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；</li><li><strong>内存使用</strong> - <ahref="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a>可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code>这样的工具来显示；</li><li><strong>打开文件</strong> - <ahref="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a>可以列出被进程打开的文件信息。当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</li><li><strong>网络连接和配置</strong> - <ahref="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a>能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code>常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用<ahref="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a>命令。注意，<code>netstat</code> 和 <code>ifconfig</code>这两个命令已经被前面那些工具所代替了。</li><li><strong>网络使用</strong> - <ahref="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <ahref="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a>是非常好的用于对网络占用进行监控的交互式命令行工具。</li></ul><p>如果您希望测试一下这些工具，您可以使用 <ahref="https://linux.die.net/man/1/stress"><code>stress</code></a>命令来为系统人为地增加负载。</p><h3 id="专用工具">专用工具</h3><p>有时候，您只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。类似 <ahref="https://github.com/sharkdp/hyperfine"><code>hyperfine</code></a>这样的命令行可以帮您快速进行基准测试。例如，我们在 shell工具和脚本那一节课中我们推荐使用 <code>fd</code> 来代替<code>find</code>。我们这里可以用<code>hyperfine</code>来比较一下它们。</p><p>例如，下面的例子中，我们可以看到<code>fd</code> 比 <code>find</code>要快20倍。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hyperfine --warmup 3 <span class="hljs-string">&#x27;fd -e jpg&#x27;</span> <span class="hljs-string">&#x27;find . -iname &quot;*.jpg&quot;&#x27;</span><br>Benchmark <span class="hljs-comment">#1: fd -e jpg</span><br>  Time (mean ± σ):      51.4 ms ±   2.9 ms    [User: 121.0 ms, System: 160.5 ms]<br>  Range (min … max):    44.2 ms …  60.1 ms    56 runs<br><br>Benchmark <span class="hljs-comment">#2: find . -iname &quot;*.jpg&quot;</span><br>  Time (mean ± σ):      1.126 s ±  0.101 s    [User: 141.1 ms, System: 956.1 ms]<br>  Range (min … max):    0.975 s …  1.287 s    10 runs<br><br>Summary<br>  <span class="hljs-string">&#x27;fd -e jpg&#x27;</span> ran<br>   21.89 ± 2.33 <span class="hljs-built_in">times</span> faster than <span class="hljs-string">&#x27;find . -iname &quot;*.jpg&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>和 debug一样，浏览器也包含了很多不错的性能分析工具，可以用来分析页面加载，让我们可以搞清楚时间都消耗在什么地方（加载、渲染、脚本等等）。更多关于 <ahref="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Profiling_with_the_Built-in_Profiler">Firefox</a>和 <ahref="https://developers.google.com/web/tools/chrome-devtools/rendering-tools">Chrome</a>的信息可以点击链接。</p><h1 id="课后练习">课后练习</h1><p>[习题解答](//) ## 调试 1.使用 Linux 上的 <code>journalctl</code> 或 macOS 上的<code>log show</code>命令来获取最近一天中超级用户的登录信息及其所执行的指令。如果找不到相关信息，您可以执行一些无害的命令，例如<code>sudo ls</code>然后再次查看。</p><ol start="2" type="1"><li><p>学习 <a href="https://github.com/spiside/pdb-tutorial">这份</a><code>pdb</code> 实践教程并熟悉相关的命令。更深入的信息您可以参考<ahref="https://realpython.com/python-debugging-pdb">这份</a>教程。</p></li><li><p>安装 <ahref="https://www.shellcheck.net/"><code>shellcheck</code></a>并尝试对下面的脚本进行检查。这段代码有什么问题吗？请修复相关问题。在您的编辑器中安装一个linter插件，这样它就可以自动地显示相关警告信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-comment">## Example: a typical script with several problems</span><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">ls</span> *.m3u)<br><span class="hljs-keyword">do</span><br>  grep -qi hq.*mp3 <span class="hljs-variable">$f</span> \<br>    &amp;&amp; <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&#x27;Playlist $f contains a HQ file in mp3 format&#x27;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></p></li><li><p>(进阶题) 请阅读 <ahref="https://undo.io/resources/reverse-debugging-whitepaper/">可逆调试</a>并尝试创建一个可以工作的例子（使用 <ahref="https://rr-project.org/"><code>rr</code></a> 或 <ahref="https://morepypy.blogspot.com/2016/07/reverse-debugging-for-python.html"><code>RevPDB</code></a>）。</p></li></ol><h2 id="性能分析-1">性能分析</h2><ol type="1"><li><p><a href="/static/files/sorts.py">这里</a>有一些排序算法的实现。请使用 <ahref="https://docs.python.org/3/library/profile.html"><code>cProfile</code></a>和 <ahref="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a>来比较插入排序和快速排序的性能。两种算法的瓶颈分别在哪里？然后使用<code>memory_profiler</code>来检查内存消耗，为什么插入排序更好一些？然后再看看原地排序版本的快排。附加题：使用<code>perf</code>来查看不同算法的循环次数及缓存命中及丢失情况。</p></li><li><p>这里有一些用于计算斐波那契数列 Python代码，它为计算每个数字都定义了一个函数： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib0</span>(): <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib1</span>(): <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br>s = <span class="hljs-string">&quot;&quot;&quot;def fib&#123;&#125;(): return fib&#123;&#125;() + fib&#123;&#125;()&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">exec</span>(s.<span class="hljs-built_in">format</span>(n, n-<span class="hljs-number">1</span>, n-<span class="hljs-number">2</span>))<br>    <span class="hljs-comment"># from functools import lru_cache</span><br>    <span class="hljs-comment"># for n in range(10):</span><br>    <span class="hljs-comment">#     exec(&quot;fib&#123;&#125; = lru_cache(1)(fib&#123;&#125;)&quot;.format(n, n))</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;fib9()&quot;</span>))<br></code></pre></td></tr></table></figure>将代码拷贝到文件中使其变为一个可执行的程序。首先安装 <ahref="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a>和<ahref="http://graphviz.org/"><code>graphviz</code></a>(如果您能够执行<code>dot</code>,则说明已经安装了 GraphViz.)。并使用<code>pycallgraph graphviz -- ./fib.py</code>来执行代码并查看<code>pycallgraph.png</code> 这个文件。<code>fib0</code>被调用了多少次？我们可以通过记忆法来对其进行优化。将注释掉的部分放开，然后重新生成图片。这回每个<code>fibN</code>函数被调用了多少次？</p></li><li><p>我们经常会遇到的情况是某个我们希望去监听的端口已经被其他进程占用了。让我们通过进程的PID查找相应的进程。首先执行<code>python -m http.server 4444</code> 启动一个最简单的 web服务器来监听 <code>4444</code> 端口。在另外一个终端中，执行<code>lsof | grep LISTEN</code>打印出所有监听端口的进程及相应的端口。找到对应的 PID 然后使用<code>kill &lt;PID&gt;</code> 停止该进程。</p></li><li><p>限制进程资源也是一个非常有用的技术。执行 <code>stress -c 3</code>并使用<code>htop</code> 对 CPU消耗进行可视化。现在，执行<code>taskset --cpu-list 0,2 stress -c 3</code>并可视化。<code>stress</code> 占用了3个 CPU 吗？为什么没有？阅读<ahref="http://man7.org/linux/man-pages/man1/taskset.1.html"><code>man taskset</code></a>来寻找答案。附加题：使用<ahref="http://man7.org/linux/man-pages/man7/cgroups.7.html"><code>cgroups</code></a>来实现相同的操作，限制<code>stress -m</code>的内存使用。</p></li><li><p>(进阶题) <code>curl ipinfo.io</code> 命令或执行 HTTP请求并获取关于您 IP 的信息。打开 <ahref="https://www.wireshark.org/">Wireshark</a> 并抓取 <code>curl</code>发起的请求和收到的回复报文。（提示：可以使用<code>http</code>进行过滤，只显示HTTP 报文）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>editors</title>
    <link href="/2023/06/05/editors/"/>
    <url>/2023/06/05/editors/</url>
    
    <content type="html"><![CDATA[<p>写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的Word 与 Visual Studio Code）。</p><p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p><ul><li>阅读教程（比如这节课以及我们为您提供的资源）</li><li>坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）</li><li>随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有</li></ul><p>如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如打开和编辑文件、保存与退出、浏览缓冲区。当学习时间累计达到20个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</p><h1 id="该学哪个编辑器">该学哪个编辑器？</h1><p>程序员们对自己正在使用的文本编辑器通常有着 <ahref="https://zh.wikipedia.org/wiki/编辑器之战">非常强的执念</a>。</p><p>现在最流行的编辑器是什么？<ahref="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">StackOverflow 的调查</a>（这个调查可能并不如我们想象的那样客观，因为 StackOverflow 的用户并不能代表所有程序员）显示，<ahref="https://code.visualstudio.com">Visual Studio Code</a>是目前最流行的代码编辑器。而 <a href="https://www.vim.org">Vim</a>则是最流行的基于命令行的编辑器。</p><h2 id="vim">Vim</h2><p>这门课的所有教员都使用 Vim 作为编辑器。Vim 有着悠久历史；它始于 1976年的 Vi 编辑器，到现在还在 不断开发中。Vim有很多聪明的设计思想，所以很多其他工具也支持 Vim 模式（比如，140万人安装了 <a href="https://github.com/VSCodeVim/Vim">Vim emulation forVS code</a>）。即使你最后使用 其他编辑器，Vim 也值得学习。</p><p>由于不可能在 50 分钟内教授 Vim 的所有功能，我们会专注于解释 Vim的设计哲学，教你基础知识，并展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p><h1 id="vim-的哲学">Vim 的哲学</h1><p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以，Vim是一个<em>多模态</em>编辑 器：它对于插入文字和操纵文字有不同的模式。Vim是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim的接口本身也是一个程序语言：键入操作（以及其助记名）是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim甚至避免用 上下左右键因为那样需要太多的手指移动。</p><p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p><h1 id="编辑模式">编辑模式</h1><p>Vim的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p><ul><li><strong>正常模式</strong>：在文件中四处移动光标进行修改</li><li><strong>插入模式</strong>：插入文本</li><li><strong>替换模式</strong>：替换文本</li><li><strong>可视化模式</strong>（一般，行，块）：选中文本块</li><li><strong>命令模式</strong>：用于执行命令</li></ul><p>在不同的操作模式下，键盘敲击的含义也不同。比如，<code>x</code>在插入模式会插入字母 <code>x</code>，但是在正常模式会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p><p>在默认设置下，Vim 会在左下角显示当前的模式。Vim启动时的默认模式是正常模式。通常你会把大部分时间花在正常模式和插入模式。</p><p>你可以按下<code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入<code>i</code> 进入插入 模式，<code>R</code>进入替换模式，<code>v</code> 进入可视（一般）模式，<code>V</code>进入可视（行）模式，<code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作<code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p><p>因为你会在使用 Vim 时大量使用 <code>&lt;ESC&gt;</code>键，所以可以考虑把大小写锁定键重定义成 <code>&lt;ESC&gt;</code> 键（<ahref="https://vim.fandom.com/wiki/Map_caps_lock_to_escape_in_macOS">MacOS教程</a>）。</p><h1 id="基本操作">基本操作</h1><h2 id="插入文本">插入文本</h2><p>在正常模式，键入 <code>i</code> 进入插入模式。现在 Vim跟很多其他的编辑器一样，直到你键入 <code>&lt;ESC&gt;</code>返回正常模式。你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p><h2 id="缓存-标签页-窗口">缓存， 标签页， 窗口</h2><p>Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim会话包含一系列标签页，每个标签页包含一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是，缓存和窗口不是一一对应的关系；窗口只是视角。一个缓存可以在<em>多个</em>窗口打开，甚至在同一个标签页内的多个窗口打开。这个功能其实很好用，比如在查看同一个文件的不同部分的时候。</p><p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p><h2 id="命令行">命令行</h2><p>在正常模式下键入 <code>:</code> 进入命令行模式。 在键入<code>:</code> 后，你的光标会立即跳到屏幕下方的命令行。这个模式有很多功能，包括打开，保存，关闭文件，以及 <ahref="https://twitter.com/iamdevloper/status/435555976687923200">退出Vim</a>。</p><ul><li><code>:q</code> 退出（关闭窗口）</li><li><code>:w</code> 保存（写）</li><li><code>:wq</code> 保存然后退出</li><li><code>:e &#123;文件名&#125;</code> 打开要编辑的文件</li><li><code>:ls</code> 显示打开的缓存</li><li><code>:help &#123;标题&#125;</code> 打开帮助文档<ul><li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li><li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li></ul></li></ul><h1 id="vim-的接口其实是一种编程语言">Vim 的接口其实是一种编程语言</h1><p>Vim 最重要的设计思想是 Vim的界面本身是一个程序语言。键入操作（以及他们的助记名）本身是命令，这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p><h2 id="移动">移动</h2><p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim里面移动也被称为 “名词”， 因为它们指向文字块。</p><ul><li>基本移动: <code>hjkl</code> （左， 下， 上， 右）</li><li>词： <code>w</code> （下一个词）， <code>b</code> （词初），<code>e</code> （词尾）</li><li>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符），<code>$</code> （行尾）</li><li>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间），<code>L</code> （屏幕底部）</li><li>翻页： <code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code>（下翻）</li><li>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</li><li>行数： <code>:&#123;行数&#125;&lt;CR&gt;</code> 或者 <code>&#123;行数&#125;G</code>({行数}为行数)</li><li>杂项： <code>%</code> （找到配对，比如括号或者 /* */之类的注释对）</li><li>查找： <code>f&#123;字符&#125;</code>， <code>t&#123;字符&#125;</code>，<code>F&#123;字符&#125;</code>， <code>T&#123;字符&#125;</code><ul><li>查找/到 向前/向后 在本行的{字符}</li><li><code>,</code> / <code>;</code> 用于导航匹配</li></ul></li><li>搜索: <code>/&#123;正则表达式&#125;</code>, <code>n</code> / <code>N</code>用于导航匹配</li></ul><h2 id="选择">选择</h2><p>可视化模式:</p><ul><li>可视化：<code>v</code></li><li>可视化行： <code>V</code></li><li>可视化块：<code>Ctrl+v</code></li></ul><p>可以用移动命令来选中。</p><h2 id="编辑">编辑</h2><p>所有你需要用鼠标做的事，你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”，因为动词可以施动于名词。</p><ul><li><code>i</code> 进入插入模式<ul><li>但是对于操纵/编辑文本，不单想用退格键完成</li></ul></li><li><code>O</code> / <code>o</code> 在之上/之下插入行</li><li><code>d&#123;移动命令&#125;</code> 删除 {移动命令}<ul><li>例如，<code>dw</code> 删除词, <code>d$</code> 删除到行尾,<code>d0</code> 删除到行头。</li></ul></li><li><code>c&#123;移动命令&#125;</code> 改变 {移动命令}<ul><li>例如，<code>cw</code> 改变词</li><li>比如 <code>d&#123;移动命令&#125;</code> 再 <code>i</code></li></ul></li><li><code>x</code> 删除字符（等同于 <code>dl</code>）</li><li><code>s</code> 替换字符（等同于 <code>xi</code>）</li><li>可视化模式 + 操作<ul><li>选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</li></ul></li><li><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</li><li><code>y</code> 复制 / "yank" （其他一些命令比如 <code>d</code>也会复制）</li><li><code>p</code> 粘贴</li><li>更多值得学习的: 比如 <code>~</code> 改变字符的大小写</li></ul><h2 id="计数">计数</h2><p>你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。</p><ul><li><code>3w</code> 向前移动三个词</li><li><code>5j</code> 向下移动5行</li><li><code>7dw</code> 删除7个词</li></ul><h2 id="修饰语">修饰语</h2><p>你可以用修饰语改变“名词”的意义。修饰语有<code>i</code>，表示“内部”或者“在内“，和 <code>a</code>，表示”周围“。</p><ul><li><code>ci(</code> 改变当前括号内的内容</li><li><code>ci[</code> 改变当前方括号内的内容</li><li><code>da'</code> 删除一个单引号字符串， 包括周围的单引号</li></ul><h1 id="演示">演示</h1><p>这里是一个有问题的 <ahref="https://en.wikipedia.org/wiki/Fizz_buzz">fizz buzz</a> 实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fizz_buzz</span>(<span class="hljs-params">limit</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(limit):<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;fizz&#x27;</span>)<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;fizz&#x27;</span>)<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> i % <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    fizz_buzz(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>我们会修复以下问题：</p><ul><li><p>主函数没有被调用</p></li><li><p>从 0 而不是 1 开始</p></li><li><p>在 15 的整数倍的时候在不用行打印 "fizz" 和 "buzz"</p></li><li><p>在 5 的整数倍的时候打印 "fizz"</p></li><li><p>采用硬编码的参数 10 而不是从命令控制行读取参数</p></li><li><p>主函数没有被调用</p><ul><li><code>G</code> 文件尾</li><li><code>o</code> 向下打开一个新行</li><li>输入 "if <strong>name</strong> ..."</li></ul></li><li><p>从 0 而不是 1 开始</p><ul><li>搜索 <code>/range</code></li><li><code>ww</code> 向前移动两个词</li><li><code>i</code> 插入文字， "1, "</li><li><code>ea</code> 在 limit 后插入， "+1"</li></ul></li><li><p>在新的一行 "fizzbuzz"</p><ul><li><code>jj$i</code> 插入文字到行尾</li><li>加入 ", end=''"</li><li><code>jj.</code> 重复第二个打印</li><li><code>jjo</code> 在 if 打开一行</li><li>加入 "else: print()"</li></ul></li><li><p>fizz fizz</p><ul><li><code>ci'</code> 变到 fizz</li></ul></li><li><p>命令控制行参数</p><ul><li><code>ggO</code> 向上打开</li><li>"import sys"</li><li><code>/10</code></li><li><code>ci(</code> to "int(sys.argv[1])"</li></ul></li></ul><p>展示详情请观看课程视频。比较上面用 Vim的操作和你可能使用其他程序的操作。 值得一提的是 Vim需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。</p><h1 id="自定义-vim">自定义 Vim</h1><p>Vim 由一个位于 <code>~/.vimrc</code> 的文本配置文件（包含 Vim脚本命令）。你可能会启用很多基本 设置。</p><p>我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为它修复了一些 Vim 默认设置奇怪行为。 <strong>在<ahref="/2020/files/vimrc">这儿</a> 下载我们的设置，然后将它保存成<code>~/.vimrc</code>.</strong></p><p>Vim能够被重度自定义，花时间探索自定义选项是值得的。你可以参考其他人的在GitHub 上共享的设置文件，比如，你的授课人的 Vim 设置 (<ahref="https://github.com/anishathalye/dotfiles/blob/master/vimrc">Anish</a>,<ahref="https://github.com/jonhoo/configs/blob/master/editor/.config/nvim/init.vim">Jon</a>(uses <a href="https://neovim.io/">neovim</a>), <ahref="https://github.com/JJGO/dotfiles/blob/master/vim/.vimrc">Jose</a>)。有很多好的博客文章也聊到了这个话题。尽量不要复制粘贴别人的整个设置文件，而是阅读和理解它，然后采用对你有用的部分。</p><h1 id="扩展-vim">扩展 Vim</h1><p>Vim有很多扩展插件。跟很多互联网上已经过时的建议相反，你<em>不</em>需要在Vim 使用一个插件 管理器（从 Vim 8.0开始）。你可以使用内置的插件管理系统。只需要创建一个<code>~/.vim/pack/vendor/start/</code>的文件夹，然后把插件放到这里（比如通过 <code>git clone</code>）。</p><p>以下是一些我们最爱的插件：</p><ul><li><a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>:模糊文件查找</li><li><a href="https://github.com/mileszs/ack.vim">ack.vim</a>:代码搜索</li><li><a href="https://github.com/scrooloose/nerdtree">nerdtree</a>:文件浏览器</li><li><ahref="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>:魔术操作</li></ul><p>我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件(<a href="https://github.com/anishathalye/dotfiles">Anish</a>, <ahref="https://github.com/jonhoo/configs">Jon</a>, <ahref="https://github.com/JJGO/dotfiles">Jose</a>)来看看我们使用的其他插件。 浏览 <a href="https://vimawesome.com/">VimAwesome</a> 来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 "bestVim plugins"。</p><h1 id="其他程序的-vim-模式">其他程序的 Vim 模式</h1><p>很多工具提供了 Vim 模式。这些 Vim模式的质量参差不齐；取决于具体工具，有的提供了 很多酷炫的 Vim功能，但是大多数对基本功能支持的很好。</p><h2 id="shell">Shell</h2><p>如果你是一个 Bash 用户，用 <code>set -o vi</code>。如果你用Zsh：<code>bindkey -v</code>。Fish 用<code>fish_vi_key_bindings</code>。另外，不管利用什么 shell，你可以<code>export EDITOR=vim</code>。这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。例如，<code>git</code> 会使用这个编辑器来编辑 commit 信息。</p><h2 id="readline">Readline</h2><p>很多程序使用 <ahref="https://tiswww.case.edu/php/chet/readline/rltop.html">GNUReadline</a> 库来作为 它们的命令控制行界面。Readline 也支持基本的 Vim模式， 可以通过在 <code>~/.inputrc</code> 添加如下行开启：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> editing-<span class="hljs-keyword">mode</span> <span class="hljs-keyword">vi</span><br></code></pre></td></tr></table></figure><p>比如，在这个设置下，Python REPL 会支持 Vim 快捷键。</p><h2 id="其他">其他</h2><p>甚至有 Vim 的网页浏览快捷键 <ahref="http://vim.wikia.com/wiki/Vim_key_bindings_for_web_browsers">browsers</a>,受欢迎的有 用于 Google Chrome 的 <ahref="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en">Vimium</a>和用于 Firefox 的 <ahref="https://github.com/tridactyl/tridactyl">Tridactyl</a>。你甚至可以在 <ahref="https://github.com/lambdalisue/jupyter-vim-binding">Jupyternotebooks</a> 中用 Vim 快捷键。 <ahref="https://reversed.top/2016-08-13/big-list-of-vim-like-software">这个列表</a>中列举了支持类 vim 键位绑定的软件。</p><h1 id="vim-进阶">Vim 进阶</h1><p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你，但是你可以在使用中学习。一个好的对策是: 当你在使用你的编辑器的时候感觉“一定有更好的方法来做这个”， 那么很可能真的有：上网搜寻一下。</p><h2 id="搜索和替换">搜索和替换</h2><p><code>:s</code> （替换）命令（<ahref="http://vim.wikia.com/wiki/Search_and_replace">文档</a>）。</p><ul><li><code>%s/foo/bar/g</code><ul><li>在整个文件中将 foo 全局替换成 bar</li></ul></li><li><code>%s/\[.*\](\(.*\))/\1/g</code><ul><li>将有命名的 Markdown 链接替换成简单 URLs</li></ul></li></ul><h2 id="多窗口">多窗口</h2><ul><li>用 <code>:sp</code> / <code>:vsp</code> 来分割窗口</li><li>同一个缓存可以在多个窗口中显示。</li></ul><h2 id="宏">宏</h2><ul><li><code>q&#123;字符&#125;</code> 来开始在寄存器<code>&#123;字符&#125;</code>中录制宏</li><li><code>q</code>停止录制</li><li><code>@&#123;字符&#125;</code> 重放宏</li><li>宏的执行遇错误会停止</li><li><code>&#123;计数&#125;@&#123;字符&#125;</code>执行一个宏{计数}次</li><li>宏可以递归<ul><li>首先用<code>q&#123;字符&#125;q</code>清除宏</li><li>录制该宏，用 <code>@&#123;字符&#125;</code> 来递归调用该宏（在录制完成之前不会有任何操作）</li></ul></li><li>例子：将 xml 转成 json (<ahref="/2020/files/example-data.xml">file</a>)<ul><li>一个有 "name" / "email" 键对象的数组</li><li>用一个 Python 程序？</li><li>用 sed / 正则表达式<ul><li><code>g/people/d</code></li><li><code>%s/&lt;person&gt;/&#123;/g</code></li><li><code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/"name": "\1",/g</code></li><li>...</li></ul></li><li>Vim 命令 / 宏<ul><li><code>Gdd</code>, <code>ggdd</code> 删除第一行和最后一行</li><li>格式化最后一个元素的宏 （寄存器 <code>e</code>）<ul><li>跳转到有 <code>&lt;name&gt;</code> 的行</li><li><code>qe^r"f&gt;s": "&lt;ESC&gt;f&lt;C"&lt;ESC&gt;q</code></li></ul></li><li>格式化一个<person>的宏<ul><li>跳转到有 <code>&lt;person&gt;</code> 的行</li><li><code>qpS&#123;&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS&#125;,&lt;ESC&gt;q</code></li></ul></li><li>格式化一个<person>标签然后转到另外一个<person>的宏<ul><li>跳转到有 <code>&lt;person&gt;</code> 的行</li><li><code>qq@pjq</code></li></ul></li><li>执行宏到文件尾<ul><li><code>999@q</code></li></ul></li><li>手动移除最后的 <code>,</code> 然后加上 <code>[</code> 和<code>]</code> 分隔符</li></ul></li></ul></li></ul><h1 id="扩展资料">扩展资料</h1><ul><li><code>vimtutor</code> 是一个 Vim 安装时自带的教程</li><li><a href="https://vim-adventures.com/">Vim Adventures</a>是一个学习使用 Vim 的游戏</li><li><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim TipsWiki</a></li><li><a href="https://vimways.org/2019/">Vim Advent Calendar</a> 有很多Vim 小技巧</li><li><a href="http://www.vimgolf.com/">Vim Golf</a> 是用 Vim的用户界面作为程序语言的 <ahref="https://en.wikipedia.org/wiki/Code_golf">code golf</a></li><li><a href="https://vi.stackexchange.com/">Vi/Vim StackExchange</a></li><li><a href="http://vimcasts.org/">Vim Screencasts</a></li><li><a href="https://pragprog.com/titles/dnvim2/">PracticalVim</a>（书籍）</li></ul><h1 id="课后练习">课后练习</h1><p>[习题解答](//) 1. 完成<code>vimtutor</code>。备注：它在一个 <ahref="https://en.wikipedia.org/wiki/VT100">80x24</a>（80 列，24 行）终端窗口看起来效果最好。 1. 下载我们提供的 <ahref="/2020/files/vimrc">vimrc</a>，然后把它保存到<code>~/.vimrc</code>。 通读这个注释详细的文件 （用 Vim!）， 然后观察Vim 在这个新的设置下看起来和使用起来有哪些细微的区别。 1.安装和配置一个插件： <ahref="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>. 1. 用<code>mkdir -p ~/.vim/pack/vendor/start</code> 创建插件文件夹 1.下载这个插件：<code>cd ~/.vim/pack/vendor/start; git clone       https://github.com/ctrlpvim/ctrlp.vim</code>1. 阅读这个插件的 <ahref="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md">文档</a>。尝试用 CtrlP 来在一个工程文件夹里定位一个文件，打开 Vim, 然后用 Vim命令控制行开始 <code>:CtrlP</code>. 1. 自定义 CtrlP：添加 <ahref="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options">configuration</a>到你的 <code>~/.vimrc</code> 来用按 Ctrl-P 打开 CtrlP 1. 练习使用 Vim,在你自己的机器上重做 <a href="#demo">演示</a>。 1. 下个月用 Vim完成<em>所有的</em>文件编辑。每当不够高效的时候，或者你感觉“一定有一个更好的方式”时，尝试求助搜索引擎，很有可能有一个更好的方式。如果你遇到难题，可以来我们的答疑时间或者给我们发邮件。1. 在其他工具中设置 Vim 快捷键 （见上面的操作指南）。 1.进一步自定义你的 <code>~/.vimrc</code> 和安装更多插件。 1. （高阶）用Vim 宏将 XML 转换到 JSON (<ahref="/2020/files/example-data.xml">例子文件</a>)。尝试着先完全自己做，但是在你卡住的时候可以查看上面<ahref="#macros">宏</a> 章节。</p>]]></content>
    
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>metaprogramming</title>
    <link href="/2023/06/05/metaprogramming/"/>
    <url>/2023/06/05/metaprogramming/</url>
    
    <content type="html"><![CDATA[<p>我们这里说的 “元编程（metaprogramming）”是什么意思呢？好吧，对于本文要介绍的这些内容，这是我们能够想到的最能概括它们的词。因为我们今天要讲的东西，更多是关于<em>流程</em>，而不是写代码或更高效的工作。本节课我们会学习构建系统、代码测试以及依赖管理。在您还是学生的时候，这些东西看上去似乎对您来说没那么重要，不过当您开始实习或走进社会的时候，您将会接触到大型的代码库，本节课讲授的这些东西也会变得随处可见。必须要指出的是，“元编程”也有<ahref="https://en.wikipedia.org/wiki/Metaprogramming">用于操作程序的程序</a>"之含义，这和我们今天讲座所介绍的概念是完全不同的。</p><h1 id="构建系统">构建系统</h1><p>如果您使用 LaTeX来编写论文，您需要执行哪些命令才能编译出您想要的论文呢？执行基准测试、绘制图表然后将其插入论文的命令又有哪些？或者，如何编译本课程提供的代码并执行测试呢？</p><p>对于大多数系统来说，不论其是否包含代码，都会包含一个“构建过程”。有时，您需要执行一系列操作。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。有很多事情需要我们完成，您并不是第一个因此感到苦恼的人，幸运的是，有很多工具可以帮助我们完成这些操作。</p><p>这些工具通常被称为"构建系统"，而且这些工具还不少。如何选择工具完全取决于您当前手头上要完成的任务以及项目的规模。从本质上讲，这些工具都是非常类似的。您需要定义<em>依赖</em>、<em>目标</em>和<em>规则</em>。您必须告诉构建系统您具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来。理想的情况下，如果目标的依赖没有发生改动，并且我们可以从之前的构建中复用这些依赖，那么与其相关的构建规则并不会被执行。</p><p><code>make</code>是最常用的构建系统之一，您会发现它通常被安装到了几乎所有基于UNIX的系统中。<code>make</code>并不完美，但是对于中小型项目来说，它已经足够好了。当您执行<code>make</code> 时，它会去参考当前目录下名为 <code>Makefile</code>的文件。所有构建目标、相关依赖和规则都需要在该文件中定义，它看上去是这样的：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-section">paper.pdf: paper.tex plot-data.png</span><br>pdflatex paper.tex<br><br><span class="hljs-section">plot-%.png: %.dat plot.py</span><br>./plot.py -i <span class="hljs-variable">$*</span>.dat -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>这个文件中的指令，即如何使用右侧文件构建左侧文件的规则。或者，换句话说，冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段程序。在<code>make</code> 中，第一条指令还指明了构建的目的，如果您使用不带参数的<code>make</code>，这便是我们最终的构建结果。或者，您可以使用这样的命令来构建其他目标：<code>make plot-data.png</code>。</p><p>规则中的 <code>%</code>是一种模式，它会匹配其左右两侧相同的字符串。例如，如果目标是<code>plot-foo.png</code>， <code>make</code> 会去寻找<code>foo.dat</code> 和 <code>plot.py</code>作为依赖。现在，让我们看看如果在一个空的源码目录中执行<code>make</code>会发生什么？</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>make: *** No rule to make target &#x27;paper.tex&#x27;, needed by &#x27;paper.pdf&#x27;.  Stop.<br></code></pre></td></tr></table></figure><p><code>make</code>会告诉我们，为了构建出<code>paper.pdf</code>，它需要<code>paper.tex</code>，但是并没有一条规则能够告诉它如何构建该文件。让我们构建它吧！</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">touch</span> paper.tex</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>make: *** No rule to make target &#x27;plot-data.png&#x27;, needed by &#x27;paper.pdf&#x27;.  Stop.<br></code></pre></td></tr></table></figure><p>哟，有意思，我们是<strong>有</strong>构建 <code>plot-data.png</code>的规则的，但是这是一条模式规则。因为源文件<code>data.dat</code>并不存在，因此 <code>make</code> 就会告诉您它不能构建<code>plot-data.png</code>，让我们创建这些文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> paper.tex</span><br>\documentclass&#123;article&#125;<br>\usepackage&#123;graphicx&#125;<br>\begin&#123;document&#125;<br>\includegraphics[scale=0.65]&#123;plot-data.png&#125;<br>\end&#123;document&#125;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> plot.py</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/usr/bin/env python</span><br>import matplotlib<br>import matplotlib.pyplot as plt<br>import numpy as np<br>import argparse<br><br>parser = argparse.ArgumentParser()<br>parser.add_argument(&#x27;-i&#x27;, type=argparse.FileType(&#x27;r&#x27;))<br>parser.add_argument(&#x27;-o&#x27;)<br>args = parser.parse_args()<br><br>data = np.loadtxt(args.i)<br>plt.plot(data[:, 0], data[:, 1])<br>plt.savefig(args.o)<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> data.dat</span><br>1 1<br>2 2<br>3 3<br>4 4<br>5 8<br></code></pre></td></tr></table></figure><p>当我们执行 <code>make</code> 时会发生什么？</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>./plot.py -i data.dat -o plot-data.png<br>pdflatex paper.tex<br>... lots of output ...<br></code></pre></td></tr></table></figure><p>看！PDF ！</p><p>如果再次执行 <code>make</code> 会怎样？</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>make: &#x27;paper.pdf&#x27; is up to date.<br></code></pre></td></tr></table></figure><p>什么事情都没做！为什么？好吧，因为它什么都不需要做。make回去检查之前的构建是因其依赖改变而需要被更新。让我们试试修改<code>paper.tex</code> 在重新执行 <code>make</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim paper.tex</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>pdflatex paper.tex<br>...<br></code></pre></td></tr></table></figure><p>注意 <code>make</code> 并<strong>没有</strong>重新构建<code>plot.py</code>，因为没必要；<code>plot-data.png</code>的所有依赖都没有发生改变。</p><h1 id="依赖管理">依赖管理</h1><p>就您的项目来说，它的依赖可能本身也是其他的项目。您也许会依赖某些程序(例如<code>python</code>)、系统包 (例如<code>openssl</code>)或相关编程语言的库(例如 <code>matplotlib</code>)。现在，大多数的依赖可以通过某些<strong>软件仓库</strong>来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。例如Ubuntu 系统下面有Ubuntu软件包仓库，您可以通过<code>apt</code>这个工具来访问， RubyGems 则包含了 Ruby 的相关库，PyPi 包含了 Python库， Arch Linux 用户贡献的库则可以在 Arch User Repository 中找到。</p><p>由于每个仓库、每种工具的运行机制都不太一样，因此我们并不会在本节课深入讲解具体的细节。我们会介绍一些通用的术语，例如<em>版本控制</em>。大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个<em>版本号</em>。通常看上去像8.1.3 或64.1.20192004。版本号一般是数字构成的，但也并不绝对。版本号有很多用途，其中最重要的作用是保证软件能够运行。试想一下，假如我的库要发布一个新版本，在这个版本里面我重命名了某个函数。如果有人在我的库升级版本后，仍希望基于它构建新的软件，那么很可能构建会失败，因为它希望调用的函数已经不复存在了。有了版本控制就可以很好的解决这个问题，我们可以指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建。</p><p>这样还并不理想！如果我们发布了一项和安全相关的升级，它并<em>没有</em>影响到任何公开接口（API），但是处于安全的考虑，依赖它的项目都应该立即升级，那应该怎么做呢？这也是版本号包含多个部分的原因。不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是<ahref="https://semver.org/">语义版本号</a>，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有：</p><ul><li>如果新的版本没有改变 API，请将补丁号递增；</li><li>如果您添加了 API 并且该改动是向后兼容的，请将次版本号递增；</li><li>如果您修改了 API 但是它并不向后兼容，请将主版本号递增。</li></ul><p>这么做有很多好处。现在如果我们的项目是基于您的项目构建的，那么只要最新版本的主版本号只要没变就是安全的，次版本号不低于之前我们使用的版本即可。换句话说，如果我依赖的版本是<code>1.3.7</code>，那么使用<code>1.3.8</code>、<code>1.6.1</code>，甚至是<code>1.3.0</code>都是可以的。如果版本号是<code>2.2.4</code> 就不一定能用了，因为它的主版本号增加了。我们可以将Python 的版本号作为语义版本号的一个实例。您应该知道，Python 2 和 Python3 的代码是不兼容的，这也是为什么 Python的主版本号改变的原因。类似的，使用 Python 3.5 编写的代码在 3.7上可以运行，但是在 3.4 上可能会不行。</p><p>使用依赖管理系统的时候，您可能会遇到锁文件（<em>lockfiles</em>）这一概念。锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含bug）。还有一种极端的依赖锁定叫做<em>vendoring</em>，它会把您的依赖中的所有代码直接拷贝到您的项目中，这样您就能够完全掌控代码的任何修改，同时您也可以将自己的修改添加进去，不过这也意味着如果该依赖的维护者更新了某些代码，您也必须要自己去拉取这些更新。</p><h1 id="持续集成系统">持续集成系统</h1><p>随着您接触到的项目规模越来越大，您会发现修改代码之后还有很多额外的工作要做。您可能需要上传一份新版本的文档、上传编译后的文件到某处、发布代码到pypi，执行测试套件等等。或许您希望每次有人提交代码到 GitHub的时候，他们的代码风格被检查过并执行过某些基准测试？如果您有这方面的需求，那么请花些时间了解一下持续集成。</p><p>持续集成，或者叫做 CI 是一种雨伞术语（umbrellaterm，涵盖了一组术语的术语），它指的是那些“当您的代码变动时，自动运行的东西”，市场上有很多提供各式各样CI 工具的公司，这些工具大部分都是免费或开源的。比较大的有 TravisCI、Azure Pipelines 和 GitHubActions。它们的工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。您可以进行某些设置，这样当测试套件失败时您能够收到通知或者当测试全部通过时，您的仓库主页会显示一个徽标。</p><p>本课程的网站基于 GitHub Pages 构建，这就是一个很好的例子。Pages在每次<code>master</code>有代码更新时，会执行 Jekyll博客软件，然后使您的站点可以通过某个 GitHub域名来访问。对于我们来说这些事情太琐碎了，我现在我们只需要在本地进行修改，然后使用git 提交代码，发布到远端。CI 会自动帮我们处理后续的事情。</p><h2 id="测试简介">测试简介</h2><p>多数的大型软件都有“测试套件”。您可能已经对测试的相关概念有所了解，但是我们觉得有些测试方法和测试术语还是应该再次提醒一下：</p><ul><li>测试套件：所有测试的统称。</li><li>单元测试：一种“微型测试”，用于对某个封装的特性进行测试。</li><li>集成测试：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能<em>协同</em>工作。</li><li>回归测试：一种实现特定模式的测试，用于保证之前引起问题的 bug不会再次出现。</li><li>模拟（Mocking）:使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接”或 “模拟硬盘”。</li></ul><h1 id="课后练习">课后练习</h1><p>[习题解答](//) 1. 大多数的makefiles 都提供了 一个名为 <code>clean</code>的构建目标，这并不是说我们会生成一个名为<code>clean</code>的文件，而是我们可以使用它清理文件，让make 重新构建。您可以理解为它的作用是“撤销”所有构建步骤。在上面的makefile 中为<code>paper.pdf</code>实现一个<code>clean</code>目标。您需要将构建目标设置为<ahref="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">phony</a>。您也许会发现<ahref="https://git-scm.com/docs/git-ls-files"><code>git ls-files</code></a>子命令很有用。其他一些有用的 make 构建目标可以在<ahref="https://www.gnu.org/software/make/manual/html_node/Standard-Targets.html#Standard-Targets">这里</a>找到；</p><ol start="2" type="1"><li><p>指定版本要求的方法很多，让我们学习一下 <ahref="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Rust的构建系统</a>的依赖管理。大多数的包管理仓库都支持类似的语法。对于每种语法(尖号、波浪号、通配符、比较、乘积)，构建一种场景使其具有实际意义；</p></li><li><p>Git 可以作为一个简单的 CI 系统来使用，在任何 git 仓库中的<code>.git/hooks</code>目录中，您可以找到一些文件（当前处于未激活状态），它们的作用和脚本一样，当某些事件发生时便可以自动执行。请编写一个<ahref="https://git-scm.com/docs/githooks#_pre_commit"><code>pre-commit</code></a>钩子，它会在提交前执行<code>make paper.pdf</code>并在出现构建失败的情况拒绝您的提交。这样做可以避免产生包含不可构建版本的提交信息；</p></li><li><p>基于 <a href="https://pages.github.com/">GitHub Pages</a>创建任意一个可以自动发布的页面。添加一个<ahref="https://github.com/features/actions">GitHub Action</a>到该仓库，对仓库中的所有 shell 文件执行 <code>shellcheck</code>(<ahref="https://github.com/marketplace/actions/shellcheck">方法之一</a>)；</p></li><li><p><ahref="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/building-actions">构建属于您的</a>GitHub action，对仓库中所有的<code>.md</code>文件执行<ahref="http://proselint.com/"><code>proselint</code></a> 或 <ahref="https://github.com/btford/write-good"><code>write-good</code></a>，在您的仓库中开启这一功能，提交一个包含错误的文件看看该功能是否生效。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>potpourri</title>
    <link href="/2023/06/05/potpourri/"/>
    <url>/2023/06/05/potpourri/</url>
    
    <content type="html"><![CDATA[<h2 id="目录">目录</h2><ul><li><ahref="#%E4%BF%AE%E6%94%B9%E9%94%AE%E4%BD%8D%E6%98%A0%E5%B0%84">修改键位映射</a></li><li><a href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a></li><li><a href="#fuse">FUSE</a></li><li><a href="#%E5%A4%87%E4%BB%BD">备份</a></li><li><ahref="#API%EF%BC%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%EF%BC%89">API（应用程序接口）</a></li><li><ahref="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A0%87%E5%BF%97%E5%8F%82%E6%95%B0%E5%8F%8A%E6%A8%A1%E5%BC%8F">常见命令行标志参数及模式</a></li><li><ahref="#%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8">窗口管理器</a></li><li><a href="#vpn">VPN</a></li><li><a href="#markdown">Markdown</a></li><li><ahref="#Hammerspoon%20(macOS%E6%A1%8C%E9%9D%A2%E8%87%AA%E5%8A%A8%E5%8C%96)">Hammerspoon(macOS桌面自动化)</a><ul><li><a href="#%E8%B5%84%E6%BA%90">资源</a></li></ul></li><li><ahref="#%E5%BC%80%E6%9C%BA%E5%BC%95%E5%AF%BC%E4%BB%A5%E5%8F%8A%20Live%20USB">开机引导以及Live USB</a></li><li><a href="#docker-vagrant-vms-cloud-openstack">Docker, Vagrant, VMs,Cloud, OpenStack</a></li><li><ahref="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AE%B0%E4%BA%8B%E6%9C%AC%E7%BC%96%E7%A8%8B">交互式记事本编程</a></li><li><a href="#github">GitHub</a></li></ul><h2 id="修改键位映射">修改键位映射</h2><p>作为一名程序员，键盘是你的主要输入工具。它像计算机里的其他部件一样是可配置的，而且值得你在这上面花时间。</p><p>一个很常见的配置是修改键位映射。通常这个功能由在计算机上运行的软件实现。当某一个按键被按下，软件截获键盘发出的按键事件（keypressevent）并使用另外一个事件取代。比如： - 将 Caps Lock 映射为 Ctrl 或者Escape：Caps Lock使用了键盘上一个非常方便的位置而它的功能却很少被用到，所以我们（讲师）非常推荐这个修改；- 将 PrtSc 映射为播放/暂停：大部分操作系统支持播放/暂停键； - 交换 Ctrl和 Meta 键（Windows 的徽标键或者 Mac 的 Command 键）。</p><p>你也可以将键位映射为任意常用的指令。软件监听到特定的按键组合后会运行设定的脚本。- 打开一个新的终端或者浏览器窗口； -输出特定的字符串，比如：一个超长邮件地址或者 MIT ID； -使计算机或者显示器进入睡眠模式。</p><p>甚至更复杂的修改也可以通过软件实现： - 映射按键顺序，比如：按 Shift键五下切换大小写锁定； - 区别映射单点和长按，比如：单点 Caps Lock 映射为Escape，而长按 Caps Lock 映射为 Ctrl； -对不同的键盘或软件保存专用的映射配置。</p><p>下面是一些修改键位映射的软件： - macOS - <ahref="https://pqrs.org/osx/karabiner/">karabiner-elements</a>, <ahref="https://github.com/koekeishiya/skhd">skhd</a> 或者 <ahref="https://folivora.ai/">BetterTouchTool</a> - Linux - <ahref="https://wiki.archlinux.org/index.php/Xmodmap">xmodmap</a> 或者 <ahref="https://github.com/autokey/autokey">Autokey</a> - Windows -控制面板，<a href="https://www.autohotkey.com/">AutoHotkey</a> 或者 <ahref="https://www.randyrants.com/category/sharpkeys/">SharpKeys</a> -QMK - 如果你的键盘支持定制固件，<a href="https://docs.qmk.fm/">QMK</a>可以直接在键盘的硬件上修改键位映射。保留在键盘里的映射免除了在别的机器上的重复配置。</p><h2 id="守护进程">守护进程</h2><p>即便守护进程（daemon）这个词看上去有些陌生，你应该已经大约明白它的概念。大部分计算机都有一系列在后台保持运行，不需要用户手动运行或者交互的进程。这些进程就是守护进程。以守护进程运行的程序名一般以<code>d</code> 结尾，比如 SSH 服务端 <code>sshd</code>，用来监听传入的SSH 连接请求并对用户进行鉴权。</p><p>Linux 中的 <code>systemd</code>（the systemdaemon）是最常用的配置和运行守护进程的方法。运行<code>systemctl status</code>命令可以看到正在运行的所有守护进程。这里面有很多可能你没有见过，但是掌管了系统的核心部分的进程：管理网络、DNS解析、显示系统的图形界面等等。用户使用<code>systemctl</code> 命令和 <code>systemd</code>交互来<code>enable</code>（启用）、<code>disable</code>（禁用）、<code>start</code>（启动）、<code>stop</code>（停止）、<code>restart</code>（重启）、或者<code>status</code>（检查）配置好的守护进程及系统服务。</p><p><code>systemd</code>提供了一个很方便的界面用于配置和启用新的守护进程或系统服务。下面的配置文件使用了守护进程来运行一个简单的Python程序。文件的内容非常直接所以我们不对它详细阐述。<code>systemd</code>配置文件的详细指南可参见 <ahref="https://www.freedesktop.org/software/systemd/man/systemd.service.html">freedesktop.org</a>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># /etc/systemd/system/myapp.service</span><br><span class="hljs-section">[Unit]</span><br><span class="hljs-comment"># 配置文件描述</span><br><span class="hljs-attr">Description</span>=My Custom App<br><span class="hljs-comment"># 在网络服务启动后启动该进程</span><br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-comment"># 运行该进程的用户</span><br><span class="hljs-attr">User</span>=foo<br><span class="hljs-comment"># 运行该进程的用户组</span><br><span class="hljs-attr">Group</span>=foo<br><span class="hljs-comment"># 运行该进程的根目录</span><br><span class="hljs-attr">WorkingDirectory</span>=/home/foo/projects/mydaemon<br><span class="hljs-comment"># 开始该进程的命令</span><br><span class="hljs-attr">ExecStart</span>=/usr/bin/local/python3.<span class="hljs-number">7</span> app.py<br><span class="hljs-comment"># 在出现错误时重启该进程</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-comment"># 相当于Windows的开机启动。即使GUI没有启动，该进程也会加载并运行</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><span class="hljs-comment"># 如果该进程仅需要在GUI活动时运行，这里应写作：</span><br><span class="hljs-comment"># WantedBy=graphical.target</span><br><span class="hljs-comment"># graphical.target在multi-user.target的基础上运行和GUI相关的服务</span><br></code></pre></td></tr></table></figure><p>如果你只是想定期运行一些程序，可以直接使用 <ahref="https://www.man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>。它是一个系统内置的，用来执行定期任务的守护进程。</p><h2 id="fuse">FUSE</h2><p>现在的软件系统一般由很多模块化的组件构建而成。你使用的操作系统可以通过一系列共同的方式使用不同的文件系统上的相似功能。比如当你使用<code>touch</code> 命令创建文件的时候，<code>touch</code>使用系统调用（systemcall）向内核发出请求。内核再根据文件系统，调用特有的方法来创建文件。这里的问题是，UNIX文件系统在传统上是以内核模块的形式实现，导致只有内核可以进行文件系统相关的调用。</p><p><ahref="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a>（用户空间文件系统）允许运行在用户空间上的程序实现文件系统调用，并将这些调用与内核接口联系起来。在实践中，这意味着用户可以在文件系统调用中实现任意功能。</p><p>FUSE 可以用于实现如：一个将所有文件系统操作都使用 SSH转发到远程主机，由远程主机处理后返回结果到本地计算机的虚拟文件系统。这个文件系统里的文件虽然存储在远程主机，对于本地计算机上的软件而言和存储在本地别无二致。<code>sshfs</code>就是一个实现了这种功能的FUSE 文件系统。</p><p>一些有趣的 FUSE 文件系统包括： - <ahref="https://github.com/libfuse/sshfs">sshfs</a>：使用 SSH连接在本地打开远程主机上的文件 - <ahref="https://rclone.org/commands/rclone_mount/">rclone</a>：将Dropbox、Google Drive、Amazon S3、或者 Google Cloud Storage一类的云存储服务挂载为本地文件系统 - <ahref="https://nuetzlich.net/gocryptfs/">gocryptfs</a>：覆盖在加密文件上的文件系统。文件以加密形式保存在磁盘里，但该文件系统挂载后用户可以直接从挂载点访问文件的明文- <ahref="https://keybase.io/docs/kbfs">kbfs</a>：分布式端到端加密文件系统。在这个文件系统里有私密（private），共享（shared），以及公开（public）三种类型的文件夹- <ahref="https://borgbackup.readthedocs.io/en/stable/usage/mount.html">borgbackup</a>：方便用户浏览删除重复数据后的压缩加密备份</p><h2 id="备份">备份</h2><p>任何没有备份的数据都可能在一个瞬间永远消失。复制数据很简单，但是可靠地备份数据很难。下面列举了一些关于备份的基础知识，以及一些常见做法容易掉进的陷阱。</p><p>首先，复制存储在同一个磁盘上的数据不是备份，因为这个磁盘是一个单点故障（singlepoint offailure）。这个磁盘一旦出现问题，所有的数据都可能丢失。放在家里的外置磁盘因为火灾、抢劫等原因可能会和源数据一起丢失，所以是一个弱备份。推荐的做法是将数据备份到不同的地点存储。</p><p>同步方案也不是备份。即使方便如 Dropbox 或者 GoogleDrive，当数据在本地被抹除或者损坏，同步方案可能会把这些“更改”同步到云端。同理，像RAID这样的磁盘镜像方案也不是备份。它不能防止文件被意外删除、损坏、或者被勒索软件加密。</p><p>有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。对备份的数据实施版本控制保证了用户可以从任何记录过的历史版本中恢复数据。在备份中检测并删除重复数据，使其仅备份增量变化可以减少存储开销。在安全性方面，作为用户，你应该考虑别人需要有什么信息或者工具才可以访问或者完全删除你的数据及备份。最后一点，不要盲目信任备份方案。用户应该经常检查备份是否可以用来恢复数据。</p><p>备份不限制于备份在本地计算机上的文件。云端应用的重大发展使得我们很多的数据只存储在云端。当我们无法登录这些应用，在云端存储的网络邮件，社交网络上的照片，流媒体音乐播放列表，以及在线文档等等都会随之丢失。用户应该有这些数据的离线备份，而且已经有项目可以帮助下载并存储它们。</p><p>如果想要了解更多具体内容，请参考本课程2019年关于备份的<ahref="/2019/backups">课堂笔记</a>。</p><h2 id="api应用程序接口">API（应用程序接口）</h2><p>关于如何使用计算机有效率地完成 <em>本地</em>任务，我们这堂课已经介绍了很多方法。这些方法在互联网上其实也适用。大多数线上服务提供的API（应用程序接口）让你可以通过编程方式来访问这些服务的数据。比如，美国国家气象局就提供了一个可以从shell 中获取天气预报的 API。</p><p>这些 API 大多具有类似的格式。它们的结构化 URL 通常使用<code>api.service.com</code>作为根路径，用户可以访问不同的子路径来访问需要调用的操作，以及添加查询参数使API 返回符合查询参数条件的结果。</p><p>以美国天气数据为例，为了获得某个地点的天气数据，你可以发送一个 GET请求（比如使用<code>curl</code>）到<ahref="https://api.weather.gov/points/42.3604,-71.094"><code>https://api.weather.gov/points/42.3604,-71.094</code></a>。返回中会包括一系列用于获取特定信息（比如小时预报、气象观察站信息等）的URL。通常这些返回都是<code>JSON</code>格式，你可以使用<ahref="https://stedolan.github.io/jq/"><code>jq</code></a>等工具来选取需要的部分。</p><p>有些需要认证的 API 通常要求用户在请求中加入某种私密令牌（secrettoken）来完成认证。请阅读你想访问的 API所提供的文档来确定它请求的认证方式，但是其实大多数 API 都会使用 <ahref="https://www.oauth.com/">OAuth</a>。OAuth通过向用户提供一系列仅可用于该 API特定功能的私密令牌进行校验。因为使用了有效 OAuth 令牌的请求在 API看来就是用户本人发出的请求，所以请一定保管好这些私密令牌。否则其他人就可以冒用你的身份进行任何你可以在这个API 上进行的操作。</p><p><a href="https://ifttt.com/">IFTTT</a> 这个网站可以将很多 API整合在一起，让某 API 发生的特定事件触发在其他 API 上执行的任务。IFTTT的全称If This Then That足以说明它的用法，比如在检测到用户的新推文后，自动发布在其他平台。但是你可以对它支持的API 进行任意整合，所以试着来设置一下任何你需要的功能吧！</p><h2 id="常见命令行标志参数及模式">常见命令行标志参数及模式</h2><p>命令行工具的用法千差万别，阅读 <code>man</code>页面可以帮助你理解每种工具的用法。即便如此，下面我们将介绍一下命令行工具一些常见的共同功能。</p><ul><li>大部分工具支持 <code>--help</code>或者类似的标志参数（flag）来显示它们的简略用法。</li><li>会造成不可撤回操作的工具一般会提供“空运行”（dryrun）标志参数，这样用户可以确认工具真实运行时会进行的操作。这些工具通常也会有“交互式”（interactive）标志参数，在执行每个不可撤回的操作前提示用户确认。</li><li><code>--version</code> 或者 <code>-V</code>标志参数可以让工具显示它的版本信息（对于提交软件问题报告非常重要）。</li><li>基本所有的工具支持使用 <code>--verbose</code> 或者 <code>-v</code>标志参数来输出详细的运行信息。多次使用这个标志参数，比如<code>-vvv</code>，可以让工具输出更详细的信息（经常用于调试）。同样，很多工具支持<code>--quiet</code> 标志参数来抑制除错误提示之外的其他输出。</li><li>大多数工具中，使用 <code>-</code>代替输入或者输出文件名意味着工具将从标准输入（standardinput）获取所需内容，或者向标准输出（standard output）输出结果。</li><li>会造成破坏性结果的工具一般默认进行非递归的操作，但是支持使用“递归”（recursive）标志函数（通常是<code>-r</code>）。</li><li>有的时候你可能需要向工具传入一个 <em>看上去</em>像标志参数的普通参数，比如：<ul><li>使用 <code>rm</code> 删除一个叫 <code>-r</code> 的文件；</li><li>在通过一个程序运行另一个程序的时候（<code>ssh machine foo</code>），向内层的程序（<code>foo</code>）传递一个标志参数。</li></ul>这时候你可以使用特殊参数 <code>--</code> 让某个程序 <em>停止处理</em><code>--</code> 后面出现的标志参数以及选项（以 <code>-</code>开头的内容）：<ul><li><code>rm -- -r</code> 会让 <code>rm</code> 将 <code>-r</code>当作文件名；</li><li><code>ssh machine --for-ssh -- foo --for-foo</code> 的<code>--</code> 会让 <code>ssh</code> 知道 <code>--for-foo</code> 不是<code>ssh</code> 的标志参数。</li></ul></li></ul><h2 id="窗口管理器">窗口管理器</h2><p>大部分人适应了 Windows、macOS、以及 Ubuntu默认的“拖拽”式窗口管理器。这些窗口管理器的窗口一般就堆在屏幕上，你可以拖拽改变窗口的位置、缩放窗口、以及让窗口堆叠在一起。这种堆叠式（floating/stacking）管理器只是窗口管理器中的一种。特别在Linux 中，有很多种其他的管理器。</p><p>平铺式（tiling）管理器就是一个常见的替代。顾名思义，平铺式管理器会把不同的窗口像贴瓷砖一样平铺在一起而不和其他窗口重叠。这和<a href="https://github.com/tmux/tmux">tmux</a>管理终端窗口的方式类似。平铺式管理器按照写好的布局显示打开的窗口。如果只打开一个窗口，它会填满整个屏幕。新开一个窗口的时候，原来的窗口会缩小到比如三分之二或者三分之一的大小来腾出空间。打开更多的窗口会让已有的窗口进一步调整。</p><p>就像 tmux那样，平铺式管理器可以让你在完全不使用鼠标的情况下使用键盘切换、缩放、以及移动窗口。它们值得一试！</p><h2 id="vpn">VPN</h2><p>VPN 现在非常火，但我们不清楚这是不是因为<ahref="https://gist.github.com/joepie91/5a9909939e6ce7d09e29">一些好的理由</a>。你应该了解VPN 能提供的功能和它的限制。使用了 VPN的你对于互联网而言，<strong>最好的情况</strong>下也就是换了一个网络供应商（ISP）。所有你发出的流量看上去来源于VPN供应商的网络而不是你的“真实”地址，而你实际接入的网络只能看到加密的流量。</p><p>虽然这听上去非常诱人，但是你应该知道使用 VPN只是把原本对网络供应商的信任放在了 VPN 供应商那里——网络供应商<em>能看到的</em>，VPN 供应商<em>也都能看到</em>。如果相比网络供应商你更信任 VPN供应商，那当然很好。反之，则连接VPN的价值不明确。机场的不加密公共热点确实不可以信任，但是在家庭网络环境里，这个差异就没有那么明显。</p><p>你也应该了解现在大部分包含用户敏感信息的流量已经被 HTTPS 或者 TLS加密。这种情况下你所处的网络环境是否“安全”不太重要：供应商只能看到你和哪些服务器在交谈，却不能看到你们交谈的内容。</p><p>这一切的大前提都是“最好的情况”。曾经发生过 VPN提供商错误使用弱加密或者直接禁用加密的先例。另外，有些恶意的或者带有投机心态的供应商会记录和你有关的所有流量，并很可能会将这些信息卖给第三方。找错一家VPN 经常比一开始就不用 VPN 更危险。</p><p>MIT 向有访问校内资源需求的成员开放自己运营的 <ahref="https://ist.mit.edu/vpn">VPN</a>。如果你也想自己配置一个VPN，可以了解一下 <a href="https://www.wireguard.com/">WireGuard</a>以及 <a href="https://github.com/trailofbits/algo">Algo</a>。</p><h2 id="markdown">Markdown</h2><p>你在职业生涯中大概率会编写各种各样的文档。在很多情况下这些文档需要使用标记来增加可读性，比如：插入粗体或者斜体内容，增加页眉、超链接、以及代码片段。</p><p>在不使用 Word 或者 LaTeX 等复杂工具的情况下，你可以考虑使用 <ahref="https://commonmark.org/help/">Markdown</a>这个轻量化的标记语言（markup language）。你可能已经见过 Markdown或者它的一个变种。很多环境都支持并使用 Markdown 的一些子功能。</p><p>Markdown 致力于将人们编写纯文本时的一些习惯标准化。比如： -用<code>*</code>包围的文字表示强调（<em>斜体</em>），或者用<code>**</code>表示特别强调（<strong>粗体</strong>）；-以<code>#</code>开头的行是标题，<code>#</code>的数量表示标题的级别，比如：<code>##二级标题</code>；-以<code>-</code>开头代表一个无序列表的元素。一个数字加<code>.</code>（比如<code>1.</code>）代表一个有序列表元素；- 反引号<code>`</code>（backtick）包围的文字会以<code>代码字体</code>显示。如果要显示一段代码，可以在每一行前加四个空格缩进，或者使用三个反引号包围整个代码片段：</p><pre><code class="hljs"><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">就像这样<br></code></pre></td></tr></table></figure></code></pre><ul><li>如果要添加超链接，将 <em>需要显示</em>的文字用方括号包围，并在后面紧接着用圆括号包围链接：<code>[显示文字](指向的链接)</code>。</li></ul><p>Markdown不仅容易上手，而且应用非常广泛。实际上本课程的课堂笔记和其他资料都是使用Markdown 编写的。点击<ahref="https://github.com/missing-semester-cn/missing-semester-cn.github.io/blob/master/_2020/potpourri.md">这个链接</a>可以看到本页面的原始Markdown 内容。</p><h2 id="hammerspoon-macos-桌面自动化">Hammerspoon (macOS桌面自动化)</h2><p><a href="https://www.hammerspoon.org/">Hammerspoon</a> 是面向 macOS的一个桌面自动化框架。它允许用户编写和操作系统功能挂钩的 Lua脚本，从而与键盘、鼠标、窗口、文件系统等交互。</p><p>下面是 Hammerspoon 的一些示例应用：</p><ul><li>绑定移动窗口到的特定位置的快捷键</li><li>创建可以自动将窗口整理成特定布局的菜单栏按钮</li><li>在你到实验室以后，通过检测所连接的 WiFi 网络自动静音扬声器</li><li>在你不小心拿了朋友的充电器时弹出警告</li></ul><p>从用户的角度，Hammerspoon 可以运行任意 Lua代码，绑定菜单栏按钮、按键、或者事件。Hammerspoon提供了一个全面的用于和系统交互的库，因此它能没有限制地实现任何功能。你可以从头编写自己的Hammerspoon 配置，也可以结合别人公布的配置来满足自己的需求。</p><h3 id="资源">资源</h3><ul><li><a href="https://www.hammerspoon.org/go/">Getting Started withHammerspoon</a>：Hammerspoon 官方教程</li><li><ahref="https://github.com/Hammerspoon/hammerspoon/wiki/Sample-Configurations">Sampleconfigurations</a>：Hammerspoon 官方示例配置</li><li><ahref="https://github.com/anishathalye/dotfiles-local/tree/mac/hammerspoon">Anish'sHammerspoon config</a>：Anish 的 Hammerspoon 配置</li></ul><h2 id="开机引导以及-live-usb">开机引导以及 Live USB</h2><p>在你的计算机启动时，<ahref="https://en.wikipedia.org/wiki/BIOS">BIOS</a> 或者 <ahref="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a>会在加载操作系统之前对硬件系统进行初始化，这被称为引导（booting）。你可以通过按下计算机提示的键位组合来配置引导，比如<code>Press F9 to configure BIOS. Press F12 to enter boot menu</code>。在BIOS菜单中你可以对硬件相关的设置进行更改，也可以在引导菜单中选择从硬盘以外的其他设备加载操作系统——比如Live USB。</p><p><a href="https://en.wikipedia.org/wiki/Live_USB">Live USB</a>是包含了完整操作系统的闪存盘。Live USB 的用途非常广泛，包括： -作为安装操作系统的启动盘； - 在不将操作系统安装到硬盘的情况下，直接运行Live USB 上的操作系统； - 对硬盘上的相同操作系统进行修复； -恢复硬盘上的数据。</p><p>Live USB 通过在闪存盘上 <em>写入</em>操作系统的镜像制作，而写入不是单纯的往闪存盘上复制 <code>.iso</code>文件。你可以使用 <a href="https://unetbootin.github.io/">UNetbootin</a>、<a href="https://github.com/pbatard/rufus">Rufus</a> 等 Live USB写入工具制作。</p><h2 id="docker-vagrant-vms-cloud-openstack">Docker, Vagrant, VMs, Cloud,OpenStack</h2><p><ahref="https://en.wikipedia.org/wiki/Virtual_machine">虚拟机</a>（VirtualMachine）以及容器化（containerization）等工具可以帮助你模拟一个包括操作系统的完整计算机系统。虚拟机可以用于创建独立的测试或者开发环境，以及用作安全测试的沙盒。</p><p><a href="https://www.vagrantup.com/">Vagrant</a>是一个构建和配置虚拟开发环境的工具。它支持用户在配置文件中写入比如操作系统、系统服务、需要安装的软件包等描述，然后使用<code>vagrant up</code>命令在各种环境（VirtualBox，KVM，Hyper-V等）中启动一个虚拟机。<ahref="https://www.docker.com/">Docker</a>是一个使用容器化概念的类似工具。</p><p>租用云端虚拟机可以享受以下资源的即时访问：</p><ul><li>便宜、常开、且有公共IP地址的虚拟机用来托管网站等服务</li><li>有大量 CPU、磁盘、内存、以及 GPU 资源的虚拟机</li><li>超出用户可以使用的物理主机数量的虚拟机<ul><li>相比物理主机的固定开支，虚拟机的开支一般按运行的时间计算。所以如果用户只需要在短时间内使用大量算力，租用1000台虚拟机运行几分钟明显更加划算。</li></ul></li></ul><p>受欢迎的 VPS 服务商有 <a href="https://aws.amazon.com/">AmazonAWS</a>，<a href="https://cloud.google.com/">Google Cloud</a>、<ahref="https://azure.microsoft.com/">Microsoft Azure</a>以及<ahref="https://www.digitalocean.com/">DigitalOcean</a>。</p><p>MIT CSAIL 的成员可以使用 <ahref="https://tig.csail.mit.edu/shared-computing/open-stack/">CSAILOpenStack instance</a> 申请免费的虚拟机用于研究。</p><h2 id="交互式记事本编程">交互式记事本编程</h2><p><ahref="https://en.wikipedia.org/wiki/Notebook_interface">交互式记事本</a>可以帮助开发者进行与运行结果交互等探索性的编程。现在最受欢迎的交互式记事本环境大概是<ahref="https://jupyter.org/">Jupyter</a>。它的名字来源于所支持的三种核心语言：Julia、Python、R。<ahref="https://www.wolfram.com/mathematica/">Wolfram Mathematica</a>是另外一个常用于科学计算的优秀环境。</p><h2 id="github">GitHub</h2><p><a href="https://github.com/">GitHub</a>是最受欢迎的开源软件开发平台之一。我们课程中提到的很多工具，从 <ahref="https://github.com/vim/vim">vim</a> 到 <ahref="https://github.com/Hammerspoon/hammerspoon">Hammerspoon</a>，都托管在Github上。向你每天使用的开源工具作出贡献其实很简单，下面是两种贡献者们经常使用的方法：</p><ul><li>创建一个<ahref="https://help.github.com/en/github/managing-your-work-on-github/creating-an-issue">议题（issue）</a>。议题可以用来反映软件运行的问题或者请求新的功能。创建议题并不需要创建者阅读或者编写代码，所以它是一个轻量化的贡献方式。高质量的问题报告对于开发者十分重要。在现有的议题发表评论也可以对项目的开发作出贡献。</li><li>使用<ahref="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pullrequest）</a>提交代码更改。由于涉及到阅读和编写代码，提交拉取请求总的来说比创建议题更加深入。拉取请求是请求别人把你自己的代码拉取（且合并）到他们的仓库里。很多开源项目仅允许认证的管理者管理项目代码，所以一般需要<ahref="https://help.github.com/en/github/getting-started-with-github/fork-a-repo">复刻（fork）</a>这些项目的上游仓库（upstreamrepository），在你的 Github账号下创建一个内容完全相同但是由你控制的复刻仓库。这样你就可以在这个复刻仓库自由创建新的分支并推送修复问题或者实现新功能的代码。完成修改以后再回到开源项目的Github 页面<ahref="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request">创建一个拉取请求</a>。</li></ul><p>提交请求后，项目管理者会和你交流拉取请求里的代码并给出反馈。如果没有问题，你的代码会和上游仓库中的代码合并。很多大的开源项目会提供贡献指南，容易上手的议题，甚至专门的指导项目来帮助参与者熟悉这些项目。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QA</title>
    <link href="/2023/06/05/qa/"/>
    <url>/2023/06/05/qa/</url>
    
    <content type="html"><![CDATA[<p>最后一节课，我们回答学生提出的问题:</p><ul><li><ahref="#学习操作系统相关内容的推荐比如进程虚拟内存中断内存管理等">学习操作系统相关内容的推荐，比如进程，虚拟内存，中断，内存管理等</a></li><li><ahref="#你会优先学习的工具有那些">你会优先学习的工具有那些？</a></li><li><a href="#使用-python-vs-bash脚本-vs-其他语言">使用 Python VSBash脚本 VS 其他语言?</a></li><li><ahref="#source-scriptsh-和-scriptsh-有什么区别"><code>source script.sh</code>和 <code>./script.sh</code> 有什么区别?</a></li><li><ahref="#各种软件包和工具存储在哪里引用过程是怎样的-bin-或-lib-是什么">各种软件包和工具存储在哪里？引用过程是怎样的?<code>/bin</code> 或 <code>/lib</code> 是什么？</a></li><li><ahref="#我应该用-apt-get-install-还是-pip-install-去下载软件包呢">我应该用<code>apt-get install</code> 还是 <code>pip install</code>去下载软件包呢?</a></li><li><ahref="#用于提高代码性能简单好用的性能分析工具有哪些">用于提高代码性能，简单好用的性能分析工具有哪些?</a></li><li><a href="#你使用那些浏览器插件">你使用那些浏览器插件?</a></li><li><ahref="#有哪些有用的数据整理工具">有哪些有用的数据整理工具？</a></li><li><ahref="#docker和虚拟机有什么区别">Docker和虚拟机有什么区别?</a></li><li><ahref="#不同操作系统的优缺点是什么我们如何选择比如选择最适用于我们需求的linux发行版">不同操作系统的优缺点是什么，我们如何选择（比如选择最适用于我们需求的Linux发行版)?</a></li><li><a href="#使用-vim-编辑器-vs-emacs-编辑器">使用 Vim 编辑器 VS Emacs编辑器?</a></li><li><ahref="#机器学习应用的提示或技巧">机器学习应用的提示或技巧?</a></li><li><a href="#还有更多的-vim-小窍门吗">还有更多的 Vim小窍门吗？</a></li><li><ahref="#2fa是什么为什么我需要使用它">2FA是什么，为什么我需要使用它?</a></li><li><a href="#对于不同的-web-浏览器有什么评价">对于不同的 Web浏览器有什么评价?</a></li></ul><h2id="学习操作系统相关内容的推荐比如进程虚拟内存中断内存管理等">学习操作系统相关内容的推荐，比如进程，虚拟内存，中断，内存管理等</h2><p>首先，不清楚你是不是真的需要了解这些更底层的话题。当你开始编写更加底层的代码，比如实现或修改内核的时候，这些内容是很重要的。除了其他课程中简要介绍过的进程和信号量之外，大部分话题都不相关。</p><p>学习资源：</p><ul><li><a href="https://pdos.csail.mit.edu/6.828/">MIT's 6.828 class</a> -研究生阶段的操作系统课程（课程资料是公开的）。</li><li>现代操作系统 第四版（<em>Modern Operating Systems 4th ed</em>） -作者是Andrew S. Tanenbaum 这本书对上述很多概念都有很好的描述。</li><li>FreeBSD的设计与实现（<em>The Design and Implementation of theFreeBSD Operating System</em>） - 关于FreeBSD OS不错的资源(注意，FreeBSD OS 不是 Linux)。</li><li>其他的指南例如 <a href="https://os.phil-opp.com/">用 Rust写操作系统</a> 这里用不同的语言逐步实现了内核，主要用于教学的目的。</li></ul><h2 id="你会优先学习的工具有那些">你会优先学习的工具有那些？</h2><p>值得优先学习的内容：</p><ul><li>多去使用键盘，少使用鼠标。这一目标可以通过多加利用快捷键，更换界面等来实现。</li><li>学好编辑器。作为程序员你大部分时间都是在编辑文件，因此值得学好这些技能。</li><li>学习怎样去自动化或简化工作流程中的重复任务。因为这会节省大量的时间。</li><li>学习像 Git 之类的版本控制工具并且知道如何与 GitHub结合，以便在现代的软件项目中协同工作。</li></ul><h2 id="使用-python-vs-bash脚本-vs-其他语言">使用 Python VS Bash脚本 VS其他语言?</h2><p>通常来说，Bash脚本对于简短的一次性脚本有效，比如当你想要运行一系列的命令的时候。但是Bash脚本有一些比较奇怪的地方，这使得大型程序或脚本难以用 Bash 实现：</p><ul><li>Bash对于简单的使用情形没什么问题，但是很难对于所有可能的输入都正确。例如，脚本参数中的空格会导致Bash 脚本出错。</li><li>Bash对于代码重用并不友好。因此，重用你先前已经写好的代码很困难。通常 Bash中没有软件库的概念。</li><li>Bash 依赖于一些像 <code>$?</code> 或 <code>$@</code>的特殊字符指代特殊的值。其他的语言却会显式地引用，比如<code>exitCode</code> 或 <code>sys.args</code>。</li></ul><p>因此，对于大型或者更加复杂的脚本我们推荐使用更加成熟的脚本语言例如Python 和 Ruby。你可以找到很多用这些语言编写的，用来解决常见问题的在线库。如果你发现某种语言实现了你所需要的特定功能库，最好的方式就是直接去使用那种语言。</p><h2id="source-script.sh-和-.script.sh-有什么区别"><code>source script.sh</code>和 <code>./script.sh</code> 有什么区别?</h2><p>这两种情况 <code>script.sh</code>都会在bash会话中被读取和执行，不同点在于哪个会话执行这个命令。 对于<code>source</code> 命令来说，命令是在当前的bash会话中执行的，因此当<code>source</code>执行完毕，对当前环境的任何更改（例如更改目录或是定义函数）都会留存在当前会话中。单独运行 <code>./script.sh</code>时，当前的bash会话将启动新的bash会话（实例），并在新实例中运行命令<code>script.sh</code>。 因此，如果 <code>script.sh</code>更改目录，新的bash会话（实例）会更改目录，但是一旦退出并将控制权返回给父bash会话，父会话仍然留在先前的位置（不会有目录的更改）。同样，如果 <code>script.sh</code> 定义了要在终端中访问的函数，需要用<code>source</code> 命令在当前bash会话中定义这个函数。否则，如果你运行<code>./script.sh</code>，只有新的bash会话（进程）才能执行定义的函数，而当前的shell不能。</p><h2id="各种软件包和工具存储在哪里引用过程是怎样的-bin-或-lib-是什么">各种软件包和工具存储在哪里？引用过程是怎样的?<code>/bin</code> 或 <code>/lib</code> 是什么？</h2><p>根据你在命令行中运行的程序，这些包和工具会全部在 <code>PATH</code>环境变量所列出的目录中查找到， 你可以使用 <code>which</code> 命令(或是<code>type</code> 命令)来检查你的shell在哪里发现了特定的程序。一般来说，特定种类的文件存储有一定的规范，<ahref="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">文件系统，层次结构标准（Filesystem,Hierarchy Standard）</a>可以查到我们讨论内容的详细列表。</p><ul><li><code>/bin</code> - 基本命令二进制文件</li><li><code>/sbin</code> - 基本的系统二进制文件，通常是root运行的</li><li><code>/dev</code> - 设备文件，通常是硬件设备接口文件</li><li><code>/etc</code> - 主机特定的系统配置文件</li><li><code>/home</code> - 系统用户的主目录</li><li><code>/lib</code> - 系统软件通用库</li><li><code>/opt</code> - 可选的应用软件</li><li><code>/sys</code> - 包含系统的信息和配置(<ahref="/2020/course-shell/">第一堂课</a>介绍的)</li><li><code>/tmp</code> - 临时文件( <code>/var/tmp</code> )通常重启时删除</li><li><code>/usr/</code> - 只读的用户数据<ul><li><code>/usr/bin</code> - 非必须的命令二进制文件</li><li><code>/usr/sbin</code> -非必须的系统二进制文件，通常是由root运行的</li><li><code>/usr/local/bin</code> - 用户编译程序的二进制文件</li></ul></li><li><code>/var</code> -变量文件 像日志或缓存</li></ul><h2id="我应该用-apt-get-install-还是-pip-install-去下载软件包呢">我应该用<code>apt-get install</code> 还是 <code>pip install</code>去下载软件包呢?</h2><p>这个问题没有普遍的答案。这与使用系统程序包管理器还是特定语言的程序包管理器来安装软件这一更笼统的问题相关。需要考虑的几件事：</p><ul><li>常见的软件包都可以通过这两种方法获得，但是小众的软件包或较新的软件包可能不在系统程序包管理器中。在这种情况下，使用特定语言的程序包管理器是更好的选择。</li><li>同样，特定语言的程序包管理器相比系统程序包管理器有更多的最新版本的程序包。</li><li>当使用系统软件包管理器时，将在系统范围内安装库。如果出于开发目的需要不同版本的库，则系统软件包管理器可能不能满足你的需要。对于这种情况，大多数编程语言都提供了隔离或虚拟环境，因此你可以用特定语言的程序包管理器安装不同版本的库而不会发生冲突。对于Python，可以使用 virtualenv，对于 Ruby，使用 RVM 。</li><li>根据操作系统和硬件架构，其中一些软件包可能会附带二进制文件或者软件包需要被编译。例如，在树莓派（RaspberryPi）之类的ARM架构计算机中，在软件附带二进制文件和软件包需要被编译的情况下，使用系统包管理器比特定语言包管理器更好。这在很大程度上取决于你的特定设置。你应该仅使用一种解决方案，而不同时使用两种方法，因为这可能会导致难以解决的冲突。我们的建议是尽可能使用特定语言的程序包管理器，并使用隔离的环境（例如Python 的 virtualenv）以避免影响全局环境。</li></ul><h2id="用于提高代码性能简单好用的性能分析工具有哪些">用于提高代码性能，简单好用的性能分析工具有哪些?</h2><p>性能分析方面相当有用和简单工具是<ahref="/2020/debugging-profiling/#timing">printtiming</a>。你只需手动计算代码不同部分之间花费的时间。通过重复执行此操作，你可以有效地对代码进行二分法搜索，并找到花费时间最长的代码段。</p><p>对于更高级的工具， Valgrind 的 <ahref="http://valgrind.org/docs/manual/cl-manual.html">Callgrind</a>可让你运行程序并计算所有的时间花费以及所有调用堆栈（即哪个函数调用了另一个函数）。然后，它会生成带注释的代码版本，其中包含每行花费的时间。但是，它会使程序运行速度降低一个数量级，并且不支持线程。其他的，<ahref="http://www.brendangregg.com/perf.html"><code>perf</code></a>工具和其他特定语言的采样性能分析器可以非常快速地输出有用的数据。<ahref="http://www.brendangregg.com/flamegraphs.html">Flamegraphs</a>是对采样分析器结果的可视化工具。你还可以使用针对特定编程语言或任务的工具。例如，对于Web 开发而言，Chrome 和 Firefox 内置的开发工具具有出色的性能分析器。</p><p>有时，代码中最慢的部分是系统等待磁盘读取或网络数据包之类的事件。在这些情况下，需要检查根据硬件性能估算的理论速度是否不偏离实际数值，也有专门的工具来分析系统调用中的等待时间，包括用于用户程序内核跟踪的<ahref="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">eBPF</a>。如果需要低级的性能分析，<ahref="https://github.com/iovisor/bpftrace"><code>bpftrace</code></a>值得一试。</p><h2 id="你使用那些浏览器插件">你使用那些浏览器插件?</h2><p>我们钟爱的插件主要与安全性与可用性有关： - <ahref="https://github.com/gorhill/uBlock">uBlock Origin</a> - 是一个<ahref="https://github.com/gorhill/uBlock/wiki/Blocking-mode">用途广泛（wide-spectrum）</a>的拦截器，它不仅可以拦截广告，还可以拦截第三方的页面，也可以拦截内部脚本和其他种类资源的加载。如果你打算花更多的时间去配置，前往<ahref="https://github.com/gorhill/uBlock/wiki/Blocking-mode:-medium-mode">中等模式（mediummode）</a>或者 <ahref="https://github.com/gorhill/uBlock/wiki/Blocking-mode:-hard-mode">强力模式（hardmode）</a>。在你调整好设置之前一些网站会停止工作，但是这些配置会显著提高你的网络安全水平。另外，<ahref="https://github.com/gorhill/uBlock/wiki/Blocking-mode:-easy-mode">简易模式（easymode）</a>作为默认模式已经相当不错了，可以拦截大部分的广告和跟踪，你也可以自定义规则来拦截网站对象。- <a href="https://github.com/openstyles/stylus/">Stylus</a> -是Stylish的分支（不要使用Stylish，它会<ahref="https://www.theregister.co.uk/2018/07/05/browsers_pull_stylish_but_invasive_browser_extension/">窃取浏览记录</a>)），这个插件可让你将自定义CSS样式加载到网站。使用Stylus，你可以轻松地自定义和修改网站的外观。可以删除侧边框，更改背景颜色，更改文字大小或字体样式。这可以使你经常访问的网站更具可读性。此外，Stylus可以找到其他用户编写并发布在<ahref="https://userstyles.org/">userstyles.org</a>中的样式。大多数常用的网站都有一个或几个深色主题样式。- 全页屏幕捕获 - 内置于 <ahref="https://screenshots.firefox.com/">Firefox</a> 和 <ahref="https://chrome.google.com/webstore/detail/full-page-screen-capture/fdpohaocaechififmbbbbbknoalclacl?hl=en">Chrome扩展程序</a>中。这些插件提供完整的网站截图，通常比打印要好用。 - <ahref="https://addons.mozilla.org/en-US/firefox/addon/multi-account-containers/">多账户容器</a>-该插件使你可以将Cookie分为“容器”，从而允许你以不同的身份浏览web网页并且/或确保网站无法在它们之间共享信息。- 密码集成管理器 -大多数密码管理器都有浏览器插件，这些插件帮你将登录凭据输入网站的过程不仅方便，而且更加安全。与简单复制粘贴用户名和密码相比，这些插件将首先检查网站域是否与列出的条目相匹配，以防止冒充网站的网络钓鱼窃取登录凭据。</p><h2 id="有哪些有用的数据整理工具">有哪些有用的数据整理工具？</h2><p>在数据整理那一节课程中，我们没有时间讨论一些数据整理工具，包括分别用于JSON和HTML数据的专用解析器，<code>jq</code> 和<code>pup</code>。Perl语言是另一个更高级的可以用于数据整理管道的工具。另一个技巧是使用<code>column -t</code>命令，可以将空格文本（不一定对齐）转换为对齐的文本。</p><p>一般来说，vim和Python是两个不常规的数据整理工具。对于某些复杂的多行转换，vim宏是非常有用的工具。你可以记录一系列操作，并根据需要重复执行多次，例如，在编辑的<ahref="/2020/editors/#macros">讲义</a>(去年 <ahref="/2019/editors/">视频</a>)中，有一个示例是使用vim宏将XML格式的文件转换为JSON。</p><p>对于通常以CSV格式显示的表格数据， Python <ahref="https://pandas.pydata.org/">pandas</a>库是一个很棒的工具。不仅因为它能让复杂操作的定义（如分组依据，联接或过滤器）变得非常容易，而且还便于根据不同属性绘制数据。它还支持导出多种表格格式，包括XLS，HTML 或 LaTeX。另外，R语言(一种有争议的<ahref="http://arrgh.tim-smith.us/">不好</a>的语言）具有很多功能，可以计算数据的统计数字，这在管道的最后一步中非常有用。<ahref="https://ggplot2.tidyverse.org/">ggplot2</a>是R中很棒的绘图库。</p><h2 id="docker和虚拟机有什么区别">Docker和虚拟机有什么区别?</h2><p>Docker基于容器这个更为概括的概念。关于容器和虚拟机之间最大的不同是，虚拟机会执行整个的OS栈，包括内核（即使这个内核和主机内核相同）。与虚拟机不同，容器避免运行其他内核实例，而是与主机分享内核。在Linux环境中，有LXC机制来实现，并且这能使一系列分离的主机像是在使用自己的硬件启动程序，而实际上是共享主机的硬件和内核。因此容器的开销小于完整的虚拟机。</p><p>另一方面，容器的隔离性较弱而且只有在主机运行相同的内核时才能正常工作。例如，如果你在macOS上运行 Docker，Docker 需要启动 Linux虚拟机去获取初始的Linux内核，这样的开销仍然很大。最后，Docker是容器的特定实现，它是为软件部署而定制的。基于这些，它有一些奇怪之处：例如，默认情况下，Docker容器在重启之间不会有以任何形式的存储。</p><h2id="不同操作系统的优缺点是什么我们如何选择比如选择最适用于我们需求的linux发行版">不同操作系统的优缺点是什么，我们如何选择（比如选择最适用于我们需求的Linux发行版)?</h2><p>关于Linux发行版，尽管有相当多的版本，但大部分发行版在大多数使用情况下的表现是相同的。可以使用任何发行版去学习 Linux 与 UNIX 的特性和其内部工作原理。发行版之间的根本区别是发行版如何处理软件包更新。 某些版本，例如 ArchLinux采用滚动更新策略，用了最前沿的软件包（bleeding-edge），但软件可能并不稳定。另外一些发行版（如Debian，CentOS或 UbuntuLTS）其更新策略要保守得多，因此更新的内容会更稳定，但会牺牲一些新功能。我们建议你使用Debian 或 Ubuntu 来获得简单稳定的台式机和服务器体验。</p><p>Mac OS 是介于 Windows 和 Linux之间的一个操作系统，它有很漂亮的界面。但是，Mac OS 是基于BSD 而不是Linux，因此系统的某些部分和命令是不同的。 另一种值得体验的是FreeBSD。虽然某些程序不能在 FreeBSD 上运行，但与 Linux 相比，BSD生态系统的碎片化程度要低得多，并且说明文档更加友好。除了开发Windows应用程序或需要使用某些Windows系统更好支持的功能（例如对游戏的驱动程序支持）外，我们不建议使用Windows。</p><p>对于双系统，我们认为最有效的是 macOS 的bootcamp，长期来看，任何其他组合都可能会出现问题，尤其是当你结合了其他功能比如磁盘加密。</p><h2 id="使用-vim-编辑器-vs-emacs-编辑器">使用 Vim 编辑器 VS Emacs编辑器?</h2><p>我们三个都使用 vim 作为我们的主要编辑器。但是 Emacs也是一个不错的选择，你可以两者都尝试，看看那个更适合你。Emacs 不使用 vim的模式编辑，但是这些功能可以通过 Emacs 插件像<ahref="https://github.com/emacs-evil/evil">Evil</a> 或 <ahref="https://github.com/hlissner/doom-emacs">Doom Emacs</a>来实现。Emacs的优点是可以用Lisp语言进行扩展（Lisp比vim默认的脚本语言vimscript要更好用）。</p><h2 id="机器学习应用的提示或技巧">机器学习应用的提示或技巧?</h2><p>课程的一些经验可以直接用于机器学习程序。就像许多科学学科一样，在机器学习中，你需要进行一系列实验，并检查哪些数据有效，哪些无效。你可以使用 Shell轻松快速地搜索这些实验结果，并且以合理的方式汇总。这意味着需要在限定时间内或使用特定数据集的情况下，检查所有实验结果。通过使用JSON文件记录实验的所有相关参数，使用我们在本课程中介绍的工具，这件事情可以变得极其简单。最后，如果你不使用集群提交你的 GPU作业，那你应该研究如何使该过程自动化，因为这是一项非常耗时的任务，会消耗你的精力。</p><h2 id="还有更多的-vim-小窍门吗">还有更多的 Vim 小窍门吗？</h2><p>更多的窍门：</p><ul><li>插件 -花时间去探索插件。有很多不错的插件修复了vim的缺陷或者增加了能够与现有vim工作流结合的新功能。关于这部分内容，资源是<ahref="https://vimawesome.com/">VimAwesome</a>和其他程序员的dotfiles。</li><li>标记 - 在vim里你可以使用 <code>m&lt;X&gt;</code> 为字母<code>X</code> 做标记，之后你可以通过 <code>'&lt;X&gt;</code>回到标记位置。这可以让你快速定位到文件内或文件间的特定位置。</li><li>导航 - <code>Ctrl+O</code> 和 <code>Ctrl+I</code>命令可以使你在最近访问位置前后移动。</li><li>撤销树 - vim有不错的更改跟踪机制，不同于其他的编辑器，vim存储变更树，因此即使你撤销后做了一些修改，你仍然可以通过撤销树的导航回到初始状态。一些插件比如<a href="https://github.com/sjl/gundo.vim">gundo.vim</a> 和 <ahref="https://github.com/mbbill/undotree">undotree</a>通过图形化来展示撤销树。</li><li>时间撤销 - <code>:earlier</code> 和 <code>:later</code>命令使得你可以用时间而非某一时刻的更改来定位文件。</li><li><ahref="https://vim.fandom.com/wiki/Using_undo_branches#Persistent_undo">持续撤销</a>-是一个默认未被开启的vim的内置功能，它在vim启动之间保存撤销历史，需要配置在<code>.vimrc</code> 目录下的<code>undofile</code> 和<code>undodir</code>，vim会保存每个文件的修改历史。</li><li>热键（Leader Key） -热键是一个用于用户自定义配置命令的特殊按键。这种模式通常是按下后释放这个按键（通常是空格键）并与其他的按键组合去实现一个特殊的命令。插件也会用这些按键增加它们的功能，例如，插件UndoTree使用<code>&lt;Leader&gt; U</code> 去打开撤销树。</li><li>高级文本对象 -文本对象比如搜索也可以用vim命令构成。例如，<code>d/&lt;pattern&gt;</code>会删除下一处匹配 pattern 的字符串，<code>cgn</code>可以用于更改上次搜索的关键字。</li></ul><h2 id="fa是什么为什么我需要使用它">2FA是什么，为什么我需要使用它?</h2><p>双因子验证（Two Factor Authentication2FA）在密码之上为帐户增加了一层额外的保护。为了登录，你不仅需要知道密码，还必须以某种方式“证明”可以访问某些硬件设备。最简单的情形是可以通过接收手机的SMS 来实现（尽管 SMS 2FA 存在 <ahref="https://www.kaspersky.com/blog/2fa-practical-guide/24219/">已知问题</a>）。我们推荐使用<ahref="https://www.yubico.com/">YubiKey</a>之类的<ahref="https://en.wikipedia.org/wiki/Universal_2nd_Factor">U2F</a>方案。</p><h2 id="对于不同的-web-浏览器有什么评价">对于不同的 Web浏览器有什么评价?</h2><p>2020的浏览器现状是，大部分的浏览器都与 Chrome类似，因为它们都使用同样的引擎(Blink)。Microsoft Edge 同样基于 Blink，而Safari 则 基于WebKit(与Blink类似的引擎)，这些浏览器仅仅是更糟糕的 Chrome版本。不管是在性能还是可用性上，Chrome都是一款很不错的浏览器。如果你想要替代品，我们推荐 Firefox。Firefox 与Chrome 的在各方面不相上下，并且在隐私方面更加出色。有一款目前还没有完成的叫 Flow的浏览器，它实现了全新的渲染引擎，有望比现有引擎速度更快。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>security</title>
    <link href="/2023/06/05/security/"/>
    <url>/2023/06/05/security/</url>
    
    <content type="html"><![CDATA[<p>去年的<a href="/2019/security/">这节课</a>我们从计算机 <em>用户</em>的角度探讨了增强隐私保护和安全的方法。今年我们将关注比如散列函数、密钥生成函数、对称/非对称密码体系这些安全和密码学的概念是如何应用于前几节课所学到的工具（Git和SSH）中的。</p><p>本课程不能作为计算机系统安全 (<ahref="https://css.csail.mit.edu/6.858/">6.858</a>) 或者 密码学 (<ahref="https://courses.csail.mit.edu/6.857/">6.857</a>以及6.875)的替代。如果你不是密码学的专家，请不要<ahref="https://www.schneier.com/blog/archives/2015/05/amateurs_produc.html">试图创造或者修改加密算法</a>。从事和计算机系统安全相关的工作同理。</p><p>这节课将对一些基本的概念进行简单（但实用）的说明。虽然这些说明不足以让你学会如何 <em>设计</em>安全系统或者加密协议，但我们希望你可以对现在使用的程序和协议有一个大概了解。</p><h1 id="熵">熵</h1><p><ahref="https://en.wikipedia.org/wiki/Entropy_(information_theory)">熵</a>(Entropy)度量了不确定性并可以用来决定密码的强度。</p><figure><img src="https://imgs.xkcd.com/comics/password_strength.png"alt="XKCD 936: Password Strength" /><figcaption aria-hidden="true">XKCD 936: Password Strength</figcaption></figure><p>正如上面的 <a href="https://xkcd.com/936/">XKCD 漫画</a> 所描述的，"correcthorsebatterystaple" 这个密码比 "Tr0ub4dor&amp;3"更安全——可是熵是如何量化安全性的呢？</p><p>熵的单位是<em>比特</em>。对于一个均匀分布的随机离散变量，熵等于<code>log_2(所有可能的个数，即n)</code>。扔一次硬币的熵是1比特。掷一次（六面）骰子的熵大约为2.58比特。</p><p>一般我们认为攻击者了解密码的模型（最小长度，最大长度，可能包含的字符种类等），但是不了解某个密码是如何随机选择的——比如<a href="https://en.wikipedia.org/wiki/Diceware">掷骰子</a>。</p><p>使用多少比特的熵取决于应用的威胁模型。上面的XKCD漫画告诉我们，大约40比特的熵足以对抗在线穷举攻击（受限于网络速度和应用认证机制）。而对于离线穷举攻击（主要受限于计算速度）, 一般需要更强的密码(比如80比特或更多)。</p><h1 id="散列函数">散列函数</h1><p><ahref="https://en.wikipedia.org/wiki/Cryptographic_hash_function">密码散列函数</a>(Cryptographic hash function)可以将任意大小的数据映射为一个固定大小的输出。除此之外，还有一些其他特性。一个散列函数的大概规范如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">hash(value<span class="hljs-operator">:</span> <span class="hljs-type">array</span><span class="hljs-operator">&lt;</span><span class="hljs-type">byte</span><span class="hljs-operator">&gt;</span>) <span class="hljs-operator">-&gt;</span> vector<span class="hljs-operator">&lt;</span><span class="hljs-type">byte</span>, N<span class="hljs-operator">&gt;</span>  (N对于该函数固定)<br></code></pre></td></tr></table></figure><p><ahref="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a>是Git中使用的一种散列函数，它可以将任意大小的输入映射为一个160比特（可被40位十六进制数表示）的输出。下面我们用<code>sha1sum</code>命令来测试SHA1对几个字符串的输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;hello&#x27;</span> | <span class="hljs-built_in">sha1sum</span></span><br>aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;hello&#x27;</span> | <span class="hljs-built_in">sha1sum</span></span><br>aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;Hello&#x27;</span> | <span class="hljs-built_in">sha1sum</span></span> <br>f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0<br></code></pre></td></tr></table></figure><p>抽象地讲，散列函数可以被认为是一个不可逆，且看上去随机（但具确定性）的函数（这就是<ahref="https://en.wikipedia.org/wiki/Random_oracle">散列函数的理想模型</a>）。一个散列函数拥有以下特性：</p><ul><li>确定性：对于不变的输入永远有相同的输出。</li><li>不可逆性：对于<code>hash(m) = h</code>，难以通过已知的输出<code>h</code>来计算出原始输入<code>m</code>。</li><li>目标碰撞抵抗性/弱无碰撞：对于一个给定输入<code>m_1</code>，难以找到<code>m_2 != m_1</code>且<code>hash(m_1) = hash(m_2)</code>。</li><li>碰撞抵抗性/强无碰撞：难以找到一组满足<code>hash(m_1) = hash(m_2)</code>的输入<code>m_1, m_2</code>（该性质严格强于目标碰撞抵抗性）。</li></ul><p>注：虽然SHA-1还可以用于特定用途，但它已经<ahref="https://shattered.io/">不再被认为</a>是一个强密码散列函数。你可参照<ahref="https://valerieaurora.org/hash.html">密码散列函数的生命周期</a>这个表格了解一些散列函数是何时被发现弱点及破解的。请注意，针对应用推荐特定的散列函数超出了本课程内容的范畴。如果选择散列函数对于你的工作非常重要，请先系统学习信息安全及密码学。</p><h2 id="密码散列函数的应用">密码散列函数的应用</h2><ul><li>Git中的内容寻址存储(Content addressed storage)：<ahref="https://en.wikipedia.org/wiki/Hash_function">散列函数</a>是一个宽泛的概念（存在非密码学的散列函数），那么Git为什么要特意使用密码散列函数？</li><li>文件的信息摘要(Message digest)：像LinuxISO这样的软件可以从非官方的（有时不太可信的）镜像站下载，所以需要设法确认下载的软件和官方一致。官方网站一般会在（指向镜像站的）下载链接旁边备注安装文件的哈希值。用户从镜像站下载安装文件后可以对照公布的哈希值来确定安装文件没有被篡改。</li><li><ahref="https://en.wikipedia.org/wiki/Commitment_scheme">承诺机制</a>(Commitmentscheme)： 假设我希望承诺一个值，但之后再透露它——比如在没有一个可信的、双方可见的硬币的情况下在我的脑海中公平的“扔一次硬币”。我可以选择一个值<code>r = random()</code>，并和你分享它的哈希值<code>h = sha256(r)</code>。这时你可以开始猜硬币的正反：我们一致同意偶数<code>r</code>代表正面，奇数<code>r</code>代表反面。你猜完了以后，我告诉你值<code>r</code>的内容，得出胜负。同时你可以使用<code>sha256(r)</code>来检查我分享的哈希值<code>h</code>以确认我没有作弊。</li></ul><h1 id="密钥生成函数">密钥生成函数</h1><p><ahref="https://en.wikipedia.org/wiki/Key_derivation_function">密钥生成函数</a>(Key Derivation Functions)作为密码散列函数的相关概念，被应用于包括生成固定长度，可以使用在其他密码算法中的密钥等方面。为了对抗穷举法攻击，密钥生成函数通常较慢。</p><h2 id="密钥生成函数的应用">密钥生成函数的应用</h2><ul><li>从密码生成可以在其他加密算法中使用的密钥，比如对称加密算法（见下）。</li><li>存储登录凭证时不可直接存储明文密码。<br>正确的方法是针对每个用户随机生成一个<ahref="https://en.wikipedia.org/wiki/Salt_(cryptography)">盐</a><code>salt = random()</code>，并存储盐，以及密钥生成函数对连接了盐的明文密码生成的哈希值<code>KDF(password + salt)</code>。<br>在验证登录请求时，使用输入的密码连接存储的盐重新计算哈希值<code>KDF(input + salt)</code>，并与存储的哈希值对比。</li></ul><h1 id="对称加密">对称加密</h1><p>说到加密，可能你会首先想到隐藏明文信息。对称加密使用以下几个方法来实现这个功能：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">keygen<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> key  (这是一个随机方法)<br><br>encrypt<span class="hljs-function"><span class="hljs-params">(plaintext: array&lt;byte&gt;, key)</span> -&gt;</span> array&lt;byte&gt;  (输出密文)<br>decrypt<span class="hljs-function"><span class="hljs-params">(ciphertext: array&lt;byte&gt;, key)</span> -&gt;</span> array&lt;byte&gt;  (输出明文)<br></code></pre></td></tr></table></figure><p>加密方法<code>encrypt()</code>输出的密文<code>ciphertext</code>很难在不知道<code>key</code>的情况下得出明文<code>plaintext</code>。<br>解密方法<code>decrypt()</code>有明显的正确性。因为功能要求给定密文及其密钥，解密方法必须输出明文：<code>decrypt(encrypt(m, k), k) = m</code>。</p><p><ahref="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>是现在常用的一种对称加密系统。</p><h2 id="对称加密的应用">对称加密的应用</h2><ul><li>加密不信任的云服务上存储的文件。对称加密和密钥生成函数配合起来，就可以使用密码加密文件：将密码输入密钥生成函数生成密钥<code>key = KDF(passphrase)</code>，然后存储<code>encrypt(file, key)</code>。</li></ul><h1 id="非对称加密">非对称加密</h1><p>非对称加密的“非对称”代表在其环境中，使用两个具有不同功能的密钥：一个是私钥(private key)，不向外公布；另一个是公钥(publickey)，公布公钥不像公布对称加密的共享密钥那样可能影响加密体系的安全性。<br>非对称加密使用以下几个方法来实现加密/解密(encrypt/decrypt)，以及签名/验证(sign/verify)：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">keygen() -&gt; (<span class="hljs-keyword">public</span> key, <span class="hljs-keyword">private</span> key)  (这是一个随机方法)<br><br>encrypt(plaintext: <span class="hljs-built_in">array<span class="hljs-keyword">&lt;byte&gt;</span></span>, <span class="hljs-keyword">public</span> key) -&gt; <span class="hljs-built_in">array<span class="hljs-keyword">&lt;byte&gt;</span></span>  (输出密文)<br>decrypt(ciphertext: <span class="hljs-built_in">array<span class="hljs-keyword">&lt;byte&gt;</span></span>, <span class="hljs-keyword">private</span> key) -&gt; <span class="hljs-built_in">array<span class="hljs-keyword">&lt;byte&gt;</span></span>  (输出明文)<br><br>sign(message: <span class="hljs-built_in">array<span class="hljs-keyword">&lt;byte&gt;</span></span>, <span class="hljs-keyword">private</span> key) -&gt; <span class="hljs-built_in">array<span class="hljs-keyword">&lt;byte&gt;</span></span>  (生成签名)<br>verify(message: <span class="hljs-built_in">array<span class="hljs-keyword">&lt;byte&gt;</span></span>, signature: <span class="hljs-built_in">array<span class="hljs-keyword">&lt;byte&gt;</span></span>, <span class="hljs-keyword">public</span> key) -&gt; <span class="hljs-built_in">bool</span>  (验证签名是否是由和这个公钥相关的私钥生成的)<br></code></pre></td></tr></table></figure><p>非对称的加密/解密方法和对称的加密/解密方法有类似的特征。<br>信息在非对称加密中使用 <em>公钥</em> 加密， 且输出的密文很难在不知道<em>私钥</em> 的情况下得出明文。<br>解密方法<code>decrypt()</code>有明显的正确性。给定密文及私钥，解密方法一定会输出明文：<code>decrypt(encrypt(m, public key), private key) = m</code>。</p><p>对称加密和非对称加密可以类比为机械锁。对称加密就好比一个防盗门：只要是有钥匙的人都可以开门或者锁门。非对称加密好比一个可以拿下来的挂锁。你可以把打开状态的挂锁（公钥）给任何一个人并保留唯一的钥匙（私钥）。这样他们将给你的信息装进盒子里并用这个挂锁锁上以后，只有你可以用保留的钥匙开锁。</p><p>签名/验证方法具有和书面签名类似的特征。<br> 在不知道 <em>私钥</em>的情况下，不管需要签名的信息为何，很难计算出一个可以使<code>verify(message, signature, public key)</code> 返回为真的签名。<br>对于使用私钥签名的信息，验证方法验证和私钥相对应的公钥时一定返回为真：<code>verify(message, sign(message, private key), public key) = true</code>。</p><h2 id="非对称加密的应用">非对称加密的应用</h2><ul><li><ahref="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP电子邮件加密</a>：用户可以将所使用的公钥在线发布，比如：PGP密钥服务器或<ahref="https://keybase.io/">Keybase</a>。任何人都可以向他们发送加密的电子邮件。</li><li>聊天加密：像 <a href="https://signal.org/">Signal</a> 和 <ahref="https://keybase.io/">Keybase</a>使用非对称密钥来建立私密聊天。</li><li>软件签名：Git支持用户对提交(commit)和标签(tag)进行GPG签名。任何人都可以使用软件开发者公布的签名公钥验证下载的已签名软件。</li></ul><h2 id="密钥分发">密钥分发</h2><p>非对称加密面对的主要挑战是，如何分发公钥并对应现实世界中存在的人或组织。</p><p>Signal的信任模型是，信任用户第一次使用时给出的身份(trust on firstuse)，同时支持用户线下(out-of-band)、面对面交换公钥（Signal里的safetynumber）。</p><p>PGP使用的是<ahref="https://en.wikipedia.org/wiki/Web_of_trust">信任网络</a>。简单来说，如果我想加入一个信任网络，则必须让已经在信任网络中的成员对我进行线下验证，比如对比证件。验证无误后，信任网络的成员使用私钥对我的公钥进行签名。这样我就成为了信任网络的一部分。只要我使用签名过的公钥所对应的私钥就可以证明“我是我”。</p><p>Keybase主要使用<ahref="https://keybase.io/blog/chat-apps-softer-than-tofu">社交网络证明(social proof)</a>，和一些别的精巧设计。</p><p>每个信任模型有它们各自的优点：我们（讲师）更倾向于 Keybase使用的模型。</p><h1 id="案例分析">案例分析</h1><h2 id="密码管理器">密码管理器</h2><p>每个人都应该尝试使用密码管理器，比如<ahref="https://keepassxc.org/">KeePassXC</a>、<ahref="https://www.passwordstore.org/">pass</a> 和 <ahref="https://1password.com">1Password</a>)。</p><p>密码管理器会帮助你对每个网站生成随机且复杂（表现为高熵）的密码，并使用你指定的主密码配合密钥生成函数来对称加密它们。</p><p>你只需要记住一个复杂的主密码，密码管理器就可以生成很多复杂度高且不会重复使用的密码。密码管理器通过这种方式降低密码被猜出的可能，并减少网站信息泄露后对其他网站密码的威胁。</p><h2 id="两步验证双因子验证">两步验证（双因子验证）</h2><p><ahref="https://en.wikipedia.org/wiki/Multi-factor_authentication">两步验证</a>(2FA)要求用户同时使用密码（“你知道的信息”）和一个身份验证器（“你拥有的物品”，比如<ahref="https://www.yubico.com/">YubiKey</a>）来消除密码泄露或者<ahref="https://en.wikipedia.org/wiki/Phishing">钓鱼攻击</a>的威胁。</p><h2 id="全盘加密">全盘加密</h2><p>对笔记本电脑的硬盘进行全盘加密是防止因设备丢失而信息泄露的简单且有效方法。Linux的<ahref="https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_a_non-root_file_system">cryptsetup+ LUKS</a>， Windows的<ahref="https://fossbytes.com/enable-full-disk-encryption-windows-10/">BitLocker</a>，或者macOS的<ahref="https://support.apple.com/en-us/HT204837">FileVault</a>都使用一个由密码保护的对称密钥来加密盘上的所有信息。</p><h2 id="聊天加密">聊天加密</h2><p><a href="https://signal.org/">Signal</a>和<ahref="https://keybase.io/">Keybase</a>使用非对称加密对用户提供端到端(End-to-end)安全性。</p><p>获取联系人的公钥非常关键。为了保证安全性，应使用线下方式验证Signal或者Keybase的用户公钥，或者信任Keybase用户提供的社交网络证明。</p><h2 id="ssh">SSH</h2><p>我们在<ahref="/2020/command-line/#remote-machines">之前的一堂课</a>讨论了SSH和SSH密钥的使用。那么我们今天从密码学的角度来分析一下它们。</p><p>当你运行<code>ssh-keygen</code>命令，它会生成一个非对称密钥对：公钥和私钥<code>(public_key, private_key)</code>。生成过程中使用的随机数由系统提供的熵决定。这些熵可以来源于硬件事件(hardwareevents)等。 公钥最终会被分发，它可以直接明文存储。但是为了防止泄露，私钥必须加密存储。<code>ssh-keygen</code>命令会提示用户输入一个密码，并将它输入密钥生成函数产生一个密钥。最终，<code>ssh-keygen</code>使用对称加密算法和这个密钥加密私钥。</p><p>在实际运用中，当服务器已知用户的公钥（存储在<code>.ssh/authorized_keys</code>文件中，一般在用户HOME目录下），尝试连接的客户端可以使用非对称签名来证明用户的身份——这便是<ahref="https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication">挑战应答方式</a>。简单来说，服务器选择一个随机数字发送给客户端。客户端使用用户私钥对这个数字信息签名后返回服务器。服务器随后使用<code>.ssh/authorized_keys</code>文件中存储的用户公钥来验证返回的信息是否由所对应的私钥所签名。这种验证方式可以有效证明试图登录的用户持有所需的私钥。<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&#123;% comment %&#125;<br>extra topics, if there&#x27;s time<br><br>security concepts, tips<br><span class="hljs-bullet">- </span>biometrics<br><span class="hljs-bullet">- </span>HTTPS<br>&#123;% endcomment %&#125;<br></code></pre></td></tr></table></figure></p><h1 id="资源">资源</h1><ul><li><a href="/2019/security/">去年的讲稿</a>:更注重于计算机用户可以如何增强隐私保护和安全</li><li><ahref="https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html">CryptographicRight Answers</a>: 解答了在一些应用环境下“应该使用什么加密？”的问题</li></ul><h1 id="课后练习">课后练习</h1><p>[习题解答](//) 1.<strong>熵</strong> 1.假设一个密码是由四个小写的单词拼接组成，每个单词都是从一个含有10万单词的字典中随机选择，且每个单词选中的概率相同。一个符合这样构造的例子是<code>correcthorsebatterystaple</code>。这个密码有多少比特的熵？1.假设另一个密码是用八个随机的大小写字母或数字组成。一个符合这样构造的例子是<code>rg8Ql34g</code>。这个密码又有多少比特的熵？1. 哪一个密码更强？ 1.假设一个攻击者每秒可以尝试1万个密码，这个攻击者需要多久可以分别破解上述两个密码？1. <strong>密码散列函数</strong> 从<ahref="https://www.debian.org/CD/http-ftp/">Debian镜像站</a>下载一个光盘映像（比如这个来自阿根廷镜像站的<ahref="http://debian.xfree.com.ar/debian-cd/10.2.0/amd64/iso-cd/debian-10.2.0-amd64-netinst.iso">映像</a>）。使用<code>sha256sum</code>命令对比下载映像的哈希值和官方Debian站公布的哈希值。如果你下载了上面的映像，官方公布的哈希值可以参考<ahref="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS">这个文件</a>。1. <strong>对称加密</strong> 使用 <ahref="https://www.openssl.org/">OpenSSL</a>的AES模式加密一个文件:<code>openssl aes-256-cbc -salt -in &#123;源文件名&#125; -out &#123;加密文件名&#125;</code>。使用<code>cat</code>或者<code>hexdump</code>对比源文件和加密的文件，再用<code>openssl aes-256-cbc -d -in &#123;加密文件名&#125; -out    &#123;解密文件名&#125;</code>命令解密刚刚加密的文件。最后使用<code>cmp</code>命令确认源文件和解密后的文件内容相同。1. <strong>非对称加密</strong> 1. 在你自己的电脑上使用更安全的<ahref="https://wiki.archlinux.org/index.php/SSH_keys#Ed25519">ED25519算法</a>生成一组<ahref="https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2">SSH密钥对</a>。为了确保私钥不使用时的安全，一定使用密码加密你的私钥。 1. <ahref="https://www.digitalocean.com/community/tutorials/how-to-use-gpg-to-encrypt-and-sign-messages">配置GPG</a>。1. 给Anish发送一封加密的电子邮件（<ahref="https://keybase.io/anish">Anish的公钥</a>）。 1.使用<code>git commit -S</code>命令签名一个Git提交，并使用<code>git show --show-signature</code>命令验证这个提交的签名。或者，使用<code>git tag -s</code>命令签名一个Git标签，并使用<code>git tag -v</code>命令验证标签的签名。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell-tools</title>
    <link href="/2023/06/05/shell-tools/"/>
    <url>/2023/06/05/shell-tools/</url>
    
    <content type="html"><![CDATA[<p>在这节课中，我们将会展示 bash作为脚本语言的一些基础操作，以及几种最常用的 shell 工具。</p><h1 id="shell-脚本">Shell 脚本</h1><p>到目前为止，我们已经学习来如何在 shell中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p><p>shell 脚本是一种更加复杂度的工具。</p><p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell脚本针对 shell所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是shell脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于bash 脚本，因为它最流行，应用更为广泛。</p><p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为<code>$foo</code>。 需要注意的是，<code>foo = bar</code>（使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code>并将 <code>=</code> 和 <code>bar</code>作为参数。总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p><p>Bash中的字符串通过<code>'</code> 和<code>"</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而<code>"</code>定义的字符串会将变量值进行替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">foo=bar<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$foo</span>&quot;</span><br><span class="hljs-comment"># 打印 bar</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$foo&#x27;</span><br><span class="hljs-comment"># 打印 $foo</span><br></code></pre></td></tr></table></figure><p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>,<code>case</code>, <code>while</code> 和 <code>for</code>这些控制流关键字。同样地， <code>bash</code>也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">mcd</span></span> () &#123;<br>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>$1</code>是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考<ahref="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。 -<code>$0</code> - 脚本名 - <code>$1</code> 到 <code>$9</code> -脚本的参数。 <code>$1</code> 是第一个参数，依此类推。 - <code>$@</code>- 所有参数 - <code>$#</code> - 参数个数 - <code>$?</code> -前一个命令的返回值 - <code>$$</code> - 当前脚本的进程识别码 -<code>!!</code> -完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用<code>sudo !!</code>再尝试一次。 - <code>$_</code> -上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下<code>Esc</code> 之后键入 . 来获取这个值。</p><p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code>来返回错误及错误码，便于脚本以更加友好的方式报告错误。返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p><p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和<code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路<ahref="https://en.wikipedia.org/wiki/Short-circuit_evaluation">运算符</a>（short-circuiting）同一行的多个命令可以用<code>;</code>分隔。程序 <code>true</code>的返回码永远是<code>0</code>，<code>false</code>的返回码永远是<code>1</code>。让我们看几个例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">false</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Oops, fail&quot;</span><br><span class="hljs-comment"># Oops, fail</span><br><br><span class="hljs-literal">true</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Will not be printed&quot;</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Things went well&quot;</span><br><span class="hljs-comment"># Things went well</span><br><br><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Will not be printed&quot;</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-literal">false</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This will always run&quot;</span><br><span class="hljs-comment"># This will always run</span><br></code></pre></td></tr></table></figure><p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过<em>命令替换</em>（<em>command substitution</em>）实现。</p><p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code>这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行<code>for file in $(ls)</code> ，shell首先将调用<code>ls</code>，然后遍历得到的这些返回值。还有一个冷门的类似特性是<em>进程替换</em>（<em>process substitution</em>），<code>&lt;( CMD )</code> 会执行 <code>CMD</code>并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code>替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如，<code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹<code>foo</code> 和 <code>bar</code> 中文件的区别。</p><p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code>搜索字符串<code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Starting program at <span class="hljs-subst">$(date)</span>&quot;</span> <span class="hljs-comment"># date会被替换成日期和时间</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running program <span class="hljs-variable">$0</span> with <span class="hljs-variable">$#</span> arguments with pid $$&quot;</span><br><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    grep foobar <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null<br>    <span class="hljs-comment"># 如果模式没有找到，则grep退出状态为 1</span><br>    <span class="hljs-comment"># 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span><br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$file</span> does not have any foobar, adding one&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>在条件语句中，我们比较 <code>$?</code> 是否等于0。Bash实现了许多类似的比较操作，您可以查看 <ahref="https://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号<code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容<code>sh</code>。 更详细的说明参见<ahref="http://mywiki.wooledge.org/BashFAQ/031">这里</a>。</p><p>当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的<em>通配</em>（<em>globbing</em>）</p><ul><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code>和 <code>*</code>来匹配一个或任意个字符。例如，对于文件<code>foo</code>,<code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和<code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和<code>foo2</code> ，而<code>rm foo*</code>则会删除除了<code>bar</code>之外的所有文件。</li><li>花括号<code>&#123;&#125;</code> -当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">convert image.&#123;png,jpg&#125;<br><span class="hljs-comment"># 会展开为</span><br>convert image.png image.jpg<br><br><span class="hljs-built_in">cp</span> /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath<br><span class="hljs-comment"># 会展开为</span><br><span class="hljs-built_in">cp</span> /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath<br><br><span class="hljs-comment"># 也可以结合通配使用</span><br><span class="hljs-built_in">mv</span> *&#123;.py,.sh&#125; folder<br><span class="hljs-comment"># 会移动所有 *.py 和 *.sh 文件</span><br><br><span class="hljs-built_in">mkdir</span> foo bar<br><br><span class="hljs-comment"># 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span><br><span class="hljs-built_in">touch</span> &#123;foo,bar&#125;/&#123;a..h&#125;<br><span class="hljs-built_in">touch</span> foo/x bar/y<br><span class="hljs-comment"># 比较文件夹 foo 和 bar 中包含文件的不同</span><br>diff &lt;(<span class="hljs-built_in">ls</span> foo) &lt;(<span class="hljs-built_in">ls</span> bar)<br><span class="hljs-comment"># 输出</span><br><span class="hljs-comment"># &lt; x</span><br><span class="hljs-comment"># ---</span><br><span class="hljs-comment"># &gt; y</span><br></code></pre></td></tr></table></figure><!-- Lastly, pipes `|` are a core feature of scripting. Pipes connect one program's output to the next program's input. We will cover them more in detail in the data wrangling lecture. --><p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <ahref="https://github.com/koalaman/shellcheck">shellcheck</a>这样的工具可以帮助你定位sh/bash脚本中的错误。</p><p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段Python 脚本，作用是将输入的参数倒序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/local/bin/python</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(sys.argv[<span class="hljs-number">1</span>:]):<br>    <span class="hljs-built_in">print</span>(arg)<br></code></pre></td></tr></table></figure><p>内核知道去用 python 解释器而不是 shell命令来运行这段脚本，是因为脚本的开头第一行的 <ahref="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p><p>在 <code>shebang</code> 行中使用 <ahref="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a>命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高来您的脚本的可移植性。<code>env</code>会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。例如，使用了<code>env</code>的shebang看上去时这样的<code>#!/usr/bin/env python</code>。</p><p>shell函数和脚本有如下一些不同点：</p><ul><li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含<code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用<ahref="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a>将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li></ul><h1 id="shell-工具">Shell 工具</h1><h2 id="查看命令如何使用">查看命令如何使用</h2><p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如<code>ls -l</code>, <code>mv -i</code> 和<code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p><p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加<code>-h</code>或 <code>--help</code>标记。另外一个更详细的方法则是使用<code>man</code> 命令。<ahref="https://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a>命令是手册（manual）的缩写，它提供了命令的用户手册。</p><p>例如，<code>man rm</code> 会输出命令 <code>rm</code>的说明，同时还有其标记列表，包括之前我们介绍过的<code>-i</code>。事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过<code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p><p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。<a href="https://tldr.sh/">TLDR pages</a>是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p><p>例如，自己就常常在tldr上搜索<ahref="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <ahref="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a>的用法。</p><h2 id="查找文件">查找文件</h2><p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为<ahref="https://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a>的工具，它是 shell上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找所有名称为src的文件夹</span><br>find . -name src -<span class="hljs-built_in">type</span> d<br><span class="hljs-comment"># 查找所有文件夹路径中包含test的python文件</span><br>find . -path <span class="hljs-string">&#x27;*/test/*.py&#x27;</span> -<span class="hljs-built_in">type</span> f<br><span class="hljs-comment"># 查找前一天修改的所有文件</span><br>find . -mtime -1<br><span class="hljs-comment"># 查找所有大小在500k至10M的tar.gz文件</span><br>find . -size +500k -size -10M -name <span class="hljs-string">&#x27;*.tar.gz&#x27;</span><br></code></pre></td></tr></table></figure><p>除了列出所寻找的文件之外，find还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除全部扩展名为.tmp 的文件</span><br>find . -name <span class="hljs-string">&#x27;*.tmp&#x27;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br><span class="hljs-comment"># 查找全部的 PNG 文件并将其转换为 JPG</span><br>find . -name <span class="hljs-string">&#x27;*.png&#x27;</span> -<span class="hljs-built_in">exec</span> convert &#123;&#125; &#123;&#125;.jpg \;<br></code></pre></td></tr></table></figure><p>尽管 <code>find</code>用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式<code>PATTERN</code> 的文件，您需要执行<code>find -name '*PATTERN*'</code>(如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p><p>您当然可以使用 alias 设置别名来简化上述操作，但 shell的哲学之一便是寻找（更好用的）替代方案。 记住，shell最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p><p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a>就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code>搜索的语法是 <code>fd PATTERN</code>。</p><p>大多数人都认为 <code>find</code> 和 <code>fd</code>已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p><p>这就要靠 <ahref="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a>了。 <code>locate</code> 使用一个由 <ahref="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中<code>updatedb</code> 都会通过 <ahref="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code>和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。<ahref="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p><h2 id="查找代码">查找代码</h2><p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p><p>为了实现这一点，很多类UNIX的系统都提供了<ahref="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p><p><code>grep</code>有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有<code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code>将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说，<code>grep -C 5</code>会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code>会递归地进入子目录并搜索所有的文本文件。</p><p>但是，我们有很多办法可以对 <code>grep -R</code>进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p><p>因此也出现了很多它的替代品，包括 <ahref="https://beyondgrep.com/">ack</a>, <ahref="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <ahref="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是ripgrep (<code>rg</code>)，因为它速度快，而且用法非常符合直觉。例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找所有使用了 requests 库的文件</span><br>rg -t py <span class="hljs-string">&#x27;import requests&#x27;</span><br><span class="hljs-comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br>rg -u --files-without-match <span class="hljs-string">&quot;^#!&quot;</span><br><span class="hljs-comment"># 查找所有的foo字符串，并打印其之后的5行</span><br>rg foo -A 5<br><span class="hljs-comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br>rg --stats PATTERN<br></code></pre></td></tr></table></figure><p>与 <code>find</code>/<code>fd</code>一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p><h2 id="查找-shell-命令">查找 shell 命令</h2><p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p><p><code>history</code>命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给<code>grep</code> 进行模式搜索。 <code>history | grep find</code>会打印包含find子串的命令。</p><p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code>对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code>后您可以输入子串来进行匹配，查找历史命令行。</p><p>反复按下就会在所有搜索结果中循环。在 <ahref="https://github.com/zsh-users/zsh-history-substring-search">zsh</a>中，使用方向键上或下也可以完成这项工作。</p><p><code>Ctrl+R</code> 可以配合 <ahref="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a>使用。<code>fzf</code>是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p><p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在<a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a>中也可以使用，它可以极大的提高用户体验。</p><p>你可以修改 shell history的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code>添加 <code>setopt HIST_IGNORE_SPACE</code>。如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或<code>.zhistory</code> 来手动地从历史记录中移除那一项。</p><h2 id="文件夹导航">文件夹导航</h2><p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <ahref="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a>创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<ahref="https://github.com/clvv/fasd"><code>fasd</code></a>和 <ahref="https://github.com/wting/autojump">autojump</a>这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <ahref="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令<code>z</code> 帮助我们快速切换到最常访问的目录。例如，如果您经常访问<code>/home/user/files/cool_project</code>目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于autojump，则使用<code>j cool</code>代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <ahref="https://linux.die.net/man/1/tree"><code>tree</code></a>, <ahref="https://github.com/Canop/broot"><code>broot</code></a>或更加完整的文件管理器，例如 <ahref="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <ahref="https://github.com/ranger/ranger"><code>ranger</code></a>。</p><h1 id="课后练习">课后练习</h1><p>[习题解答](//)</p><ol type="1"><li><p>阅读 <ahref="https://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a>，然后使用<code>ls</code> 命令进行如下操作： <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>所有文件（包括隐藏文件）<br><span class="hljs-bullet">- </span>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)<br><span class="hljs-bullet">- </span>文件以最近访问顺序排序<br><span class="hljs-bullet">- </span>以彩色文本显示输出结果<br></code></pre></td></tr></table></figure>典型输出如下：</p><p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">-rw-r--r--   <span class="hljs-number">1</span> <span class="hljs-keyword">user</span> <span class="hljs-title">group</span> <span class="hljs-number">1.1M</span> Jan <span class="hljs-number">14</span> <span class="hljs-number">09</span>:<span class="hljs-number">53</span> baz<br>drwxr-xr-x   <span class="hljs-number">5</span> <span class="hljs-keyword">user</span> <span class="hljs-title">group</span>  <span class="hljs-number">160</span> Jan <span class="hljs-number">14</span> <span class="hljs-number">09</span>:<span class="hljs-number">53</span> .<br>-rw-r--r--   <span class="hljs-number">1</span> <span class="hljs-keyword">user</span> <span class="hljs-title">group</span>  <span class="hljs-number">514</span> Jan <span class="hljs-number">14</span> <span class="hljs-number">06</span>:<span class="hljs-number">42</span> bar<br>-rw-r--r--   <span class="hljs-number">1</span> <span class="hljs-keyword">user</span> <span class="hljs-title">group</span> <span class="hljs-number">106M</span> Jan <span class="hljs-number">13</span> <span class="hljs-number">12</span>:<span class="hljs-number">12</span> foo<br>drwx------+ <span class="hljs-number">47</span> <span class="hljs-keyword">user</span> <span class="hljs-title">group</span> <span class="hljs-number">1.5</span>K Jan <span class="hljs-number">12</span> <span class="hljs-number">18</span>:<span class="hljs-number">08</span> ..<br></code></pre></td></tr></table></figure> <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">&#123;% comment %&#125;<br><span class="hljs-keyword">ls</span> -lath --<span class="hljs-keyword">color</span>=auto<br>&#123;% endcomment %&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>编写两个bash函数 <code>marco</code> 和 <code>polo</code>执行下面的操作。 每当你执行 <code>marco</code>时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code>时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行<code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件<code>marco.sh</code> 中，并通过<code>source marco.sh</code>命令，（重新）加载函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;% comment %&#125;<br><span class="hljs-title function_">marco</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">export</span> <span class="hljs-variable constant_">MARCO</span>=$(pwd)<br>&#125;<br><span class="hljs-title function_">polo</span>(<span class="hljs-params"></span>) &#123;<br>    cd <span class="hljs-string">&quot;$MARCO&quot;</span><br>&#125;<br>&#123;% endcomment %&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。加分项：报告脚本在失败前共运行了多少次。</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br><br>n=$(( RANDOM % <span class="hljs-number">100</span> ))<br><br><span class="hljs-keyword">if</span> [[ n -eq 42 ]]; <span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Something went wrong&quot;</span><br>   &gt;&amp;2 <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The error was using magic numbers&quot;</span><br>   <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Everything went according to plan&quot;</span><br></code></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;% comment %&#125;<br><span class="hljs-comment">#!/usr/bin/env bash</span><br><br>count=0<br><span class="hljs-keyword">until</span> [[ <span class="hljs-string">&quot;$?&quot;</span> -ne 0 ]];<br><span class="hljs-keyword">do</span><br>count=$((count+<span class="hljs-number">1</span>))<br>./random.sh &amp;&gt; out.txt<br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;found error after <span class="hljs-variable">$count</span> runs&quot;</span><br><span class="hljs-built_in">cat</span> out.txt<br>&#123;% endcomment %&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code>参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code>则需要从参数接受输入。这里我们可以使用<ahref="https://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a>命令，它可以使用标准输入中的内容作为参数。 例如<code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p><p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看<code>xargs</code>的参数<code>-d</code>，译注：MacOS 上的<code>xargs</code>没有<code>-d</code>，<ahref="https://github.com/missing-semester/missing-semester/issues/93">查看这个issue</a>）<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<span class="hljs-comment">% comment %&#125;</span><br>find . -type f -name <span class="hljs-string">&quot;*.html&quot;</span> | xargs -d <span class="hljs-string">&#x27;\n&#x27;</span>  tar -cvzf archive.tar.gz<br>&#123;<span class="hljs-comment">% endcomment %&#125;</span><br>如果您使用的是 <span class="hljs-symbol">MacOS</span>，请注意默认的 <span class="hljs-symbol">BSD</span> <span class="hljs-string">`find`</span> 与 [<span class="hljs-symbol">GNU</span> coreutils](https://en.wikipedia.org/wiki/<span class="hljs-symbol">List_of_GNU_Core_Utilities_commands</span>) 中的是不一样的。你可以为<span class="hljs-string">`find`</span>添加<span class="hljs-string">`-print0`</span>选项，并为<span class="hljs-string">`xargs`</span>添加<span class="hljs-string">`-0`</span>选项。作为 <span class="hljs-symbol">Mac</span> 用户，您需要注意 mac 系统自带的命令行工具和 <span class="hljs-symbol">GNU</span> 中对应的工具是有区别的；如果你想使用 <span class="hljs-symbol">GNU</span> 版本的工具，也可以使用 [brew 来安装](https://formulae.brew.sh/formula/coreutils)。<br></code></pre></td></tr></table></figure></p></li><li><p>（进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>version-control</title>
    <link href="/2023/06/05/version-control/"/>
    <url>/2023/06/05/version-control/</url>
    
    <content type="html"><![CDATA[<p>版本控制系统 (VCSs)是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p><p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p><p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p><ul><li>当前模块是谁编写的？</li><li>这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</li><li>最近的1000个版本中，何时/为什么导致了单元测试失败？</li></ul><p>尽管版本控制系统有很多， 其事实上的标准则是 <strong>Git</strong>。而这篇 <a href="https://xkcd.com/1597/">XKCD 漫画</a> 则反映出了人们对Git 的评价：</p><figure><img src="https://imgs.xkcd.com/comics/git.png" alt="xkcd 1597" /><figcaption aria-hidden="true">xkcd 1597</figcaption></figure><p>因为 Git 接口的抽象泄漏（leakyabstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p><p>尽管 Git的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向您介绍Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p><h1 id="git-的数据模型">Git 的数据模型</h1><p>进行版本控制的方法很多。Git拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p><h2 id="快照">快照</h2><p>Git将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与Blob对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;root&gt;</span> (tree)<br>|<span class="hljs-string"></span><br><span class="hljs-string">+- foo (tree)</span><br><span class="hljs-string"></span>|<span class="hljs-string">  </span>|<br>|<span class="hljs-string">  + bar.txt (blob, contents = &quot;hello world&quot;)</span><br><span class="hljs-string"></span>|<br>+- baz.txt (blob, contents = <span class="hljs-string">&quot;git is wonderful&quot;</span>)<br></code></pre></td></tr></table></figure><p>这个顶层的树包含了两个元素，一个名为 "foo"的树（它本身包含了一个blob对象 "bar.txt"），以及一个 blob 对象"baz.txt"。</p><h2 id="历史记录建模关联快照">历史记录建模：关联快照</h2><p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过处于种种原因，Git并没有采用这样的模型。</p><p>在 Git中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表Git中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p><p>在 Git中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">o</span> &lt;<span class="hljs-literal">--</span> <span class="hljs-comment">o</span> &lt;<span class="hljs-literal">--</span> <span class="hljs-comment">o</span> &lt;<span class="hljs-literal">--</span> <span class="hljs-comment">o</span><br>            <span class="hljs-comment">^</span>  <br>             <span class="hljs-comment">\</span><br>              <span class="hljs-literal">---</span> <span class="hljs-comment">o</span> &lt;<span class="hljs-literal">--</span> <span class="hljs-comment">o</span><br></code></pre></td></tr></table></figure><p>上面是一个 ASCII 码构成的简图，其中的 <code>o</code>表示一次提交（快照）。</p><p>箭头指向了当前提交的父辈（这是一种“在...之前”，而不是“在...之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p><pre class="highlight"><code>o <-- o <-- o <-- o <---- <strong>o</strong>            ^            /             \          v              --- o <-- o</code></pre><p>Git中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p><h2 id="数据模型及其伪代码表示">数据模型及其伪代码表示</h2><p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 文件就是一组数据</span><br><span class="hljs-keyword">type</span> blob = array&lt;<span class="hljs-type">byte</span>&gt;<br><br><span class="hljs-comment">// 一个包含文件和目录的目录</span><br><span class="hljs-keyword">type</span> tree = <span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>, tree | blob&gt;<br><br><span class="hljs-comment">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="hljs-keyword">type</span> commit = <span class="hljs-keyword">struct</span> &#123;<br>    parent: array&lt;commit&gt;<br>    author: <span class="hljs-type">string</span><br>    message: <span class="hljs-type">string</span><br>    snapshot: tree<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一种简洁的历史模型。</p><h2 id="对象和内存寻址">对象和内存寻址</h2><p>Git 中的对象可以是 blob、树或提交：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">type</span> <span class="hljs-keyword">object</span> = blob | tree | <span class="hljs-keyword">commit</span><br></code></pre></td></tr></table></figure><p>Git 在储存数据时，所有的对象都会基于它们的 <ahref="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a> 进行寻址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">objects = <span class="hljs-built_in">map</span>&lt;string, <span class="hljs-built_in">object</span>&gt;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">store</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):<br>    <span class="hljs-built_in">id</span> = sha1(<span class="hljs-built_in">object</span>)<br>    objects[<span class="hljs-built_in">id</span>] = <span class="hljs-built_in">object</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"><span class="hljs-built_in">id</span></span>):<br>    <span class="hljs-keyword">return</span> objects[<span class="hljs-built_in">id</span>]<br></code></pre></td></tr></table></figure><p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p><p>例如，<a href="#snapshots">上面</a>例子中的树（可以通过<code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code>来进行可视化），看上去是这样的：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">100644 </span>blob <span class="hljs-number">4448</span>adbf7ecd394f42ae135bbeed9676e894af85    baz.txt<br><span class="hljs-symbol">040000 </span>tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo<br></code></pre></td></tr></table></figure><p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt</code> (blob)和 <code>foo</code> (树)。如果我们用<code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看baz.txt 的内容，会得到以下信息：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">git <span class="hljs-keyword">is</span> wonderful<br></code></pre></td></tr></table></figure><h2 id="引用">引用</h2><p>现在，所有的快照都可以通过它们的 SHA-1哈希值来标记了。但这也太不方便了，谁也记不住一串 40位的十六进制字符。</p><p>针对这一问题，Git的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code>引用通常会指向主分支的最新一次提交。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">references = <span class="hljs-built_in">map</span>&lt;string, string&gt;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_reference</span>(<span class="hljs-params">name, <span class="hljs-built_in">id</span></span>):<br>    references[name] = <span class="hljs-built_in">id</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_reference</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> references[name]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_reference</span>(<span class="hljs-params">name_or_id</span>):<br>    <span class="hljs-keyword">if</span> name_or_id <span class="hljs-keyword">in</span> references:<br>        <span class="hljs-keyword">return</span> load(references[name_or_id])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> load(name_or_id)<br></code></pre></td></tr></table></figure><p>这样，Git 就可以使用诸如 "master"这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p><p>有一个细节需要我们注意，通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在Git 中，我们当前的位置有一个特殊的索引，它就是 "HEAD"。</p><h2 id="仓库">仓库</h2><p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和<code>引用</code>。</p><p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的<code>git</code>命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p><p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将‘master’ 引用指向提交 <code>5d83f9e</code>时，有什么命令可以完成该操作（针对这个具体问题，您可以使用<code>git checkout master; git reset --hard 5d83f9e</code>）</p><h1 id="暂存区">暂存区</h1><p>Git中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p><p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照”的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但Git不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复bug 相关的代码而丢弃所有的打印语句。</p><p>Git 处理这些场景的方法是使用一种叫做 “暂存区（stagingarea）”的机制，它允许您指定下次快照中要包括那些改动。</p><h1 id="git-的命令行接口">Git 的命令行接口</h1><p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐您阅读 <ahref="https://git-scm.com/book/zh/v2">Pro Git中文版</a>或可以观看本讲座的视频来学习。</p><h2 id="基础">基础</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs d">&#123;% comment %&#125;<br><br>The <span class="hljs-string">`git init`</span> command initializes a <span class="hljs-keyword">new</span> Git repository, <span class="hljs-keyword">with</span> repository<br>metadata being stored <span class="hljs-keyword">in</span> the <span class="hljs-string">`.git`</span> directory:<br></code></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> myproject</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> myproject</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br>Initialized empty Git repository in /home/missing-semester/myproject/.git/<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br><br>No commits yet<br><br>nothing to commit (create/copy files and use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p>How do we interpret this output? "No commits yet" basically means ourversion history is empty. Let's fix that.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello, git&quot;</span> &gt; hello.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add hello.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)<br><br>        new file:   hello.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;Initial commit&#x27;</span></span><br>[master (root-commit) 4515d17] Initial commit<br> 1 file changed, 1 insertion(+)<br> create mode 100644 hello.txt<br></code></pre></td></tr></table></figure><p>With this, we've <code>git add</code>ed a file to the staging area,and then <code>git commit</code>ed that change, adding a simple commitmessage "Initial commit". If we didn't specify a <code>-m</code> option,Git would open our text editor to allow us type a commit message.</p><p>Now that we have a non-empty version history, we can visualize thehistory. Visualizing the history as a DAG can be especially helpful inunderstanding the current status of the repo and connecting it with yourunderstanding of the Git data model.</p><p>The <code>git log</code> command visualizes history. By default, itshows a flattened version, which hides the graph structure. If you use acommand like <code>git log --all --graph --decorate</code>, it will showyou the full version history of the repository, visualized in graphform.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --all --graph --decorate</span><br>* commit 4515d17a167bdef0a91ee7d50d75b12c9c2652aa (HEAD -&gt; master)<br>  Author: Missing Semester &lt;missing-semester@mit.edu&gt;<br>  Date:   Tue Jan 21 22:18:36 2020 -0500<br><br>      Initial commit<br></code></pre></td></tr></table></figure><p>This doesn't look all that graph-like, because it only contains asingle node. Let's make some more changes, author a new commit, andvisualize the history once more.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;another line&quot;</span> &gt;&gt; hello.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        modified:   hello.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add hello.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>        modified:   hello.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&#x27;Add a line&#x27;</span></span><br>[master 35f60a8] Add a line<br> 1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure><p>Now, if we visualize the history again, we'll see some of the graphstructure:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">*</span> <span class="hljs-keyword">commit</span> <span class="hljs-number">35</span>f60a825be0106036dd2fbc7657598eb7b04c67 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> master)<br><span class="hljs-operator">|</span> Author: Missing Semester <span class="hljs-operator">&lt;</span>missing<span class="hljs-operator">-</span>semester<span class="hljs-variable">@mit</span>.edu<span class="hljs-operator">&gt;</span><br><span class="hljs-operator">|</span> <span class="hljs-type">Date</span>:   Tue Jan <span class="hljs-number">21</span> <span class="hljs-number">22</span>:<span class="hljs-number">26</span>:<span class="hljs-number">20</span> <span class="hljs-number">2020</span> <span class="hljs-number">-0500</span><br><span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>     <span class="hljs-keyword">Add</span> a line<br><span class="hljs-operator">|</span><br><span class="hljs-operator">*</span> <span class="hljs-keyword">commit</span> <span class="hljs-number">4515</span>d17a167bdef0a91ee7d50d75b12c9c2652aa<br>  Author: Anish Athalye <span class="hljs-operator">&lt;</span>me<span class="hljs-variable">@anishathalye</span>.com<span class="hljs-operator">&gt;</span><br>  <span class="hljs-type">Date</span>:   Tue Jan <span class="hljs-number">21</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> <span class="hljs-number">-0500</span><br><br>      <span class="hljs-keyword">Initial</span> <span class="hljs-keyword">commit</span><br></code></pre></td></tr></table></figure><p>Also, note that it shows the current HEAD, along with the currentbranch (master).</p><p>We can look at old versions using the <code>git checkout</code>command.</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout 4515d17  <span class="hljs-comment"># previous commit hash; yours will be different</span></span><br>Note: checking out &#x27;4515d17&#x27;.<br><br>You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.<br><br>If you want to create a new branch to retain commits you create, you may<br>do so (now or later) by using -b with the checkout command again. Example:<br><br>  git checkout -b &lt;new-branch-name&gt;<br><br>HEAD is now at 4515d17 Initial commit<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> hello.txt</span><br>hello, git<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout master</span><br>Previous HEAD position was 4515d17 Initial commit<br>Switched to branch &#x27;master&#x27;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> hello.txt</span><br>hello, git<br>another line<br></code></pre></td></tr></table></figure><p>Git can show you how files have evolved (differences, or diffs) usingthe <code>git diff</code> command:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff 4515d17 hello.txt</span><br>diff --git c/hello.txt w/hello.txt<br>index 94bab17..f0013b2 100644<br>--- c/hello.txt<br>+++ w/hello.txt<br>@@ -1 +1,2 @@<br> hello, git<br> +another line<br></code></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">endcomment</span></span> %&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</li><li><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为<code>.git</code> 的目录下</li><li><code>git status</code>: 显示当前的仓库状态</li><li><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</li><li><code>git commit</code>: 创建一个新的提交<ul><li>如何编写 <ahref="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li><li>为何要 <ahref="https://chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li></ul></li><li><code>git log</code>: 显示历史日志</li><li><code>git log --all --graph --decorate</code>:可视化历史记录（有向无环图）</li><li><code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</li><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>:显示某个文件两个版本之间的差异</li><li><code>git checkout &lt;revision&gt;</code>: 更新 HEAD和目前的分支</li></ul><h2 id="分支和合并">分支和合并</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">&#123;% comment %&#125;<br><br><span class="hljs-keyword">Branching </span>allows you to <span class="hljs-string">&quot;fork&quot;</span> version history. It can <span class="hljs-keyword">be </span>helpful for working<br>on independent features <span class="hljs-keyword">or </span><span class="hljs-keyword">bug </span>fixes in parallel. The `git <span class="hljs-keyword">branch` </span>command can<br><span class="hljs-keyword">be </span>used to create new <span class="hljs-keyword">branches; </span>`git checkout -<span class="hljs-keyword">b </span>&lt;<span class="hljs-keyword">branch </span>name&gt;` creates <span class="hljs-keyword">and</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">branch </span><span class="hljs-keyword">and </span>checks it out.<br><br>Merging is the opposite of <span class="hljs-keyword">branching: </span>it allows you to combine forked version<br>histories, e.g. merging a feature <span class="hljs-keyword">branch </span><span class="hljs-keyword">back </span>into master. The `git merge`<br>command is used for merging.<br><br>&#123;% endcomment %&#125;<br></code></pre></td></tr></table></figure><ul><li><code>git branch</code>: 显示分支</li><li><code>git branch &lt;name&gt;</code>: 创建分支</li><li><code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支<ul><li>相当于<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li></ul></li><li><code>git merge &lt;revision&gt;</code>: 合并到当前分支</li><li><code>git mergetool</code>: 使用工具来处理合并冲突</li><li><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</li></ul><h2 id="远端操作">远端操作</h2><ul><li><code>git remote</code>: 列出远端</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>:添加一个远端</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>:将对象传送至远端并更新远端引用</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>:创建本地和远端分支的关联关系</li><li><code>git fetch</code>: 从远端获取对象/索引</li><li><code>git pull</code>: 相当于 <code>git fetch; git merge</code></li><li><code>git clone</code>: 从远端下载仓库</li></ul><h2 id="撤销">撤销</h2><ul><li><code>git commit --amend</code>: 编辑提交的内容或信息</li><li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li><li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li><li><code>git restore</code>: git2.32版本后取代git reset进行许多撤销操作</li></ul><h1 id="git-高级操作">Git 高级操作</h1><ul><li><code>git config</code>: Git 是一个 <ahref="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</li><li><code>git clone --depth=1</code>: 浅克隆（shallowclone），不包括完整的版本历史信息</li><li><code>git add -p</code>: 交互式暂存</li><li><code>git rebase -i</code>: 交互式变基</li><li><code>git blame</code>: 查看最后修改某行的人</li><li><code>git stash</code>: 暂时移除工作目录下的修改内容</li><li><code>git bisect</code>: 通过二分查找搜索历史记录</li><li><code>.gitignore</code>: <ahref="https://git-scm.com/docs/gitignore">指定</a> 故意不追踪的文件</li></ul><h1 id="杂项">杂项</h1><ul><li><strong>图形用户界面</strong>: Git 的 <ahref="https://git-scm.com/downloads/guis">图形用户界面客户端</a>有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</li><li><strong>Shell 集成</strong>: 将 Git 状态集成到您的 shell中会非常方便。(<ahref="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <ahref="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<ahref="https://github.com/ohmyzsh/ohmyzsh">Oh MyZsh</a>这样的框架中一般以及集成了这一功能</li><li><strong>编辑器集成</strong>: 和上面一条类似，将 Git集成到编辑器中好处多多。<ahref="https://github.com/tpope/vim-fugitive">fugitive.vim</a> 是 Vim中集成 GIt 的常用插件</li><li><strong>工作流</strong>:我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例( 有<ahref="https://nvie.com/posts/a-successful-git-branching-model/">很多</a><ahref="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a><ahref="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</li><li><strong>GitHub</strong>: Git 并不等同于 GitHub。 在 GitHub中您需要使用一个被称作<ahref="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pullrequest）</a>的方法来向其他项目贡献代码</li><li><strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像 <ahref="https://about.gitlab.com/">GitLab</a> 和 <ahref="https://bitbucket.org/">BitBucket</a> 这样的平台。</li></ul><h1 id="资源">资源</h1><ul><li><a href="https://git-scm.com/book/en/v2">Pro Git</a>，<strong>强烈推荐</strong>！学习前五章的内容可以教会您流畅使用 Git的绝大多数技巧，因为您已经理解了 Git的数据模型。后面的章节提供了很多有趣的高级主题。（<ahref="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li><li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a>，简短的介绍了如何从 Git 错误中恢复；</li><li><ahref="https://eagain.net/articles/git-for-computer-scientists/">Git forComputer Scientists</a> ，简短的介绍了 Git的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li><li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Gitfrom the Bottom Up</a>详细的介绍了 Git的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li><li><ahref="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">Howto explain git in simple words</a>；</li><li><a href="https://learngitbranching.js.org/">Learn Git Branching</a>通过基于浏览器的游戏来学习 Git ；</li></ul><h1 id="课后练习">课后练习</h1><p>[习题解答](//) 1.如果您之前从来没有用过 Git，推荐您阅读 <ahref="https://git-scm.com/book/en/v2">Pro Git</a> 的前几章，或者完成像<a href="https://learngitbranching.js.org/">Learn GitBranching</a>这样的教程。重点关注 Git 命令和数据模型相关内容； 2. Fork<ahref="https://github.com/missing-semester/missing-semester">本课程网站的仓库</a>1. 将版本历史可视化并进行探索 2. 是谁最后修改了<code>README.md</code>文件？（提示：使用 <code>git log</code>命令并添加合适的参数） 3. 最后一次修改<code>_config.yml</code> 文件中<code>collections:</code> 行时的提交信息是什么？（提示：使用<code>git blame</code> 和 <code>git show</code>） 3. 使用 Git时的一个常见错误是提交本不应该由 Git管理的大文件，或是将含有敏感信息的文件提交给 Git。尝试向仓库中添加一个文件并添加提交信息，然后将其从历史中删除 ( <ahref="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">这篇文章也许会有帮助</a>)；4. 从 GitHub 上克隆某个仓库，修改一些文件。当您使用<code>git stash</code> 会发生什么？当您执行<code>git log --all --oneline</code> 时会显示什么？通过<code>git stash pop</code> 命令来撤销 <code>git stash</code>操作，什么时候会用到这一技巧？ 5. 与其他的命令行工具一样，Git也提供了一个名为 <code>~/.gitconfig</code> 配置文件 (或 dotfile)。请在<code>~/.gitconfig</code> 中创建一个别名，使您在运行<code>git graph</code> 时，您可以得到<code>git log --all --graph --decorate --oneline</code> 的输出结果； 6.您可以通过执行<code>git config --global core.excludesfile ~/.gitignore_global</code>在 <code>~/.gitignore_global</code> 中创建全局忽略规则。配置您的全局gitignore 文件来自动忽略系统或编辑器的临时文件，例如<code>.DS_Store</code>； 7. 克隆 <ahref="https://github.com/missing-semester/missing-semester">本课程网站的仓库</a>，找找有没有错别字或其他可以改进的地方，在GitHub 上发起拉取请求（Pull Request）；</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The Missing Semester of Your CS Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP泛型编程</title>
    <link href="/2023/03/31/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/03/31/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="c泛型编程">C++泛型编程</h1><ul><li>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</li></ul><h2 id="模板">1 模板</h2><h3 id="模板的概念">1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p><p>例如生活中的模板</p><p>一寸照片模板：</p><figure><img src="/img/1547105026929.png" alt="1547105026929" /><figcaption aria-hidden="true">1547105026929</figcaption></figure><p>PPT模板：</p><figure><img src="/img/1547103297864.png" alt="1547103297864" /><figcaption aria-hidden="true">1547103297864</figcaption></figure><figure><img src="/img/1547103359158.png" alt="1547103359158" /><figcaption aria-hidden="true">1547103359158</figcaption></figure><p>模板的特点：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h3 id="函数模板">1.2 函数模板</h3><ul><li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li><li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></li></ul><h4 id="函数模板语法">1.2.1 函数模板语法</h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>函数声明或定义<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template --- 声明创建模板</p><p>typename --- 表面其后面的符号是一种数据类型，可以用class代替</p><p>T --- 通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">//交换整型函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapInt</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-comment">//交换浮点型函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapDouble</span><span class="hljs-params">(<span class="hljs-type">double</span>&amp; a, <span class="hljs-type">double</span>&amp; b)</span> </span>&#123;<br><span class="hljs-type">double</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-comment">//利用模板提供通用的交换函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">//swapInt(a, b);</span><br><br><span class="hljs-comment">//利用模板实现交换</span><br><span class="hljs-comment">//1、自动类型推导</span><br><span class="hljs-built_in">mySwap</span>(a, b);<br><br><span class="hljs-comment">//2、显示指定类型</span><br><span class="hljs-built_in">mySwap</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="函数模板注意事项">1.2.2 函数模板注意事项</h4><p>注意事项：</p><ul><li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li><li>模板必须要确定出T的数据类型，才可以使用</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//利用模板提供通用的交换函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><br><span class="hljs-comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br><span class="hljs-built_in">mySwap</span>(a, b); <span class="hljs-comment">// 正确，可以推导出一致的T</span><br><span class="hljs-comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span><br>&#125;<br><br><br><span class="hljs-comment">// 2、模板必须要确定出T的数据类型，才可以使用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span><br><span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="函数模板案例">1.2.3 函数模板案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//交换的函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(T &amp;a, T&amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-comment">// 也可以替换成typename</span><br><span class="hljs-comment">//利用选择排序，进行对数组从大到小的排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-type">int</span> max = i; <span class="hljs-comment">//最大数的下标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[max] &lt; arr[j])<br>&#123;<br>max = j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (max != i) <span class="hljs-comment">//如果最大数的下标不是i，交换两者</span><br>&#123;<br><span class="hljs-built_in">mySwap</span>(arr[max], arr[i]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//测试char数组</span><br><span class="hljs-type">char</span> charArr[] = <span class="hljs-string">&quot;bdcfeagh&quot;</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(charArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>);<br><span class="hljs-built_in">mySort</span>(charArr, num);<br><span class="hljs-built_in">printArray</span>(charArr, num);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//测试int数组</span><br><span class="hljs-type">int</span> intArr[] = &#123; <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span> &#125;;<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">sizeof</span>(intArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><span class="hljs-built_in">mySort</span>(intArr, num);<br><span class="hljs-built_in">printArray</span>(intArr, num);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：模板可以提高代码复用，需要熟练掌握</p><h4 id="普通函数与函数模板的区别">1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAdd01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">myAdd02</span><span class="hljs-params">(T a, T b)</span>  </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="hljs-comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span><br><br><span class="hljs-comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span><br><br><span class="hljs-built_in">myAdd02</span>&lt;<span class="hljs-type">int</span>&gt;(a, c); <span class="hljs-comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p><h4 id="普通函数与函数模板的调用规则">1.2.5普通函数与函数模板的调用规则</h4><p>调用规则如下：</p><ol type="1"><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//普通函数与函数模板调用规则</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T a, T b)</span> </span><br><span class="hljs-function"></span>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;调用的模板&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(T a, T b, T c)</span> </span><br><span class="hljs-function"></span>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="hljs-comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">myPrint</span>(a, b); <span class="hljs-comment">//调用普通函数</span><br><br><span class="hljs-comment">//2、可以通过空模板参数列表来强制调用函数模板</span><br>myPrint&lt;&gt;(a, b); <span class="hljs-comment">//调用函数模板</span><br><br><span class="hljs-comment">//3、函数模板也可以发生重载</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">myPrint</span>(a, b, c); <span class="hljs-comment">//调用重载的函数模板</span><br><br><span class="hljs-comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span><br><span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">char</span> c2 = <span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-built_in">myPrint</span>(c1, c2); <span class="hljs-comment">//调用函数模板</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4 id="模板的局限性">1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><p><strong>例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123; <br>   a = b;<br>   &#125;<br></code></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-keyword">if</span>(a &gt; b) &#123; ... &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//普通函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a == b)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span><br><span class="hljs-comment">//具体化优先于常规模板</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(Person &amp;p1, Person &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//内置数据类型可以直接使用通用的函数模板</span><br><span class="hljs-type">bool</span> ret = <span class="hljs-built_in">myCompare</span>(a, b);<br><span class="hljs-keyword">if</span> (ret)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a == b &quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a != b &quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-comment">//自定义数据类型，不会调用普通的函数模板</span><br><span class="hljs-comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span><br><span class="hljs-type">bool</span> ret = <span class="hljs-built_in">myCompare</span>(p1, p2);<br><span class="hljs-keyword">if</span> (ret)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h3 id="类模板">1.3 类模板</h3><h4 id="类模板语法">1.3.1 类模板语法</h4><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>类<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template --- 声明创建模板</p><p>typename --- 表面其后面的符号是一种数据类型，可以用class代替</p><p>T --- 通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">//类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(NameType name, AgeType age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;mName = name;<br><span class="hljs-keyword">this</span>-&gt;mAge = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">&quot; age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>NameType mName;<br>AgeType mAge;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 指定NameType 为string类型，AgeType 为 int类型</span><br>Person&lt;string, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">P1</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">999</span>);<br>P1.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4 id="类模板与函数模板区别">1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p><ol type="1"><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">//类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt; <br><span class="hljs-keyword">class</span> Person<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(NameType name, AgeType age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;mName = name;<br><span class="hljs-keyword">this</span>-&gt;mAge = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">&quot; age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>NameType mName;<br>AgeType mAge;<br>&#125;;<br><br><span class="hljs-comment">//1、类模板没有自动类型推导的使用方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span><br>Person &lt;string ,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">//必须使用显示指定类型的方式，使用类模板</span><br>p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-comment">//2、类模板在模板参数列表中可以有默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person &lt;string&gt; <span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-number">999</span>); <span class="hljs-comment">//类模板中的模板参数列表 可以指定默认参数</span><br>p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4 id="类模板中成员函数创建时机">1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person1 show&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person2 show&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>T obj;<br><br><span class="hljs-comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; obj.<span class="hljs-built_in">showPerson1</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123; obj.<span class="hljs-built_in">showPerson2</span>(); &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyClass&lt;Person1&gt; m;<br><br>m.<span class="hljs-built_in">fun1</span>();<br><br><span class="hljs-comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4 id="类模板对象做函数参数">1.3.4 类模板对象做函数参数</h4><p>学习目标：</p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ol type="1"><li>指定传入的类型 --- 直接显示对象的数据类型</li><li>参数模板化 --- 将对象中的参数变为模板进行传递</li><li>整个类模板化 --- 将这个对象类型 模板化进行传递</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">//类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt; <br><span class="hljs-keyword">class</span> Person<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(NameType name, AgeType age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;mName = name;<br><span class="hljs-keyword">this</span>-&gt;mAge = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mName &lt;&lt; <span class="hljs-string">&quot; age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mAge &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>NameType mName;<br>AgeType mAge;<br>&#125;;<br><br><span class="hljs-comment">//1、指定传入的类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson1</span><span class="hljs-params">(Person&lt;string, <span class="hljs-type">int</span>&gt; &amp;p)</span> </span><br><span class="hljs-function"></span>&#123;<br>p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printPerson1</span>(p);<br>&#125;<br><br><span class="hljs-comment">//2、参数模板化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson2</span><span class="hljs-params">(Person&lt;T1, T2&gt;&amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>p.<span class="hljs-built_in">showPerson</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-number">90</span>);<br><span class="hljs-built_in">printPerson2</span>(p);<br>&#125;<br><br><span class="hljs-comment">//3、整个类模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson3</span><span class="hljs-params">(T &amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>p.<span class="hljs-built_in">showPerson</span>();<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;唐僧&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-built_in">printPerson3</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-built_in">test03</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4 id="类模板与继承">1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br>T m;<br>&#125;;<br><br><span class="hljs-comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-comment">//必须指定一个类型</span><br>&#123;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son c;<br>&#125;<br><br><span class="hljs-comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> :<span class="hljs-keyword">public</span> Base&lt;T2&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son2</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son2&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; child1;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4 id="类模板成员函数类外实现">1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//类模板中成员函数类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//成员函数类内声明</span><br><span class="hljs-built_in">Person</span>(T1 name, T2 age);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>T1 m_Name;<br>T2 m_Age;<br>&#125;;<br><br><span class="hljs-comment">//构造函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br><span class="hljs-comment">//成员函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">showPerson</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br>p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p><h4 id="类模板分文件编写">1.3.7 类模板分文件编写</h4><p>学习目标：</p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><strong>示例：</strong></p><p>person.hpp中代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(T1 name, T2 age);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>T1 m_Name;<br>T2 m_Age;<br>&#125;;<br><br><span class="hljs-comment">//构造函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br><span class="hljs-comment">//成员函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">showPerson</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>类模板分文件编写.cpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//#include &quot;person.h&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.cpp&quot;</span> <span class="hljs-comment">//解决方式1，包含cpp源文件</span></span><br><br><span class="hljs-comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.hpp&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br>p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p><h4 id="类模板与友元">1.3.8 类模板与友元</h4><p>学习目标：</p><ul><li>掌握类模板配合友元函数的类内和类外实现</li></ul><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span><br><span class="hljs-comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson2</span><span class="hljs-params">(Person&lt;T1, T2&gt; &amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-comment">//1、全局函数配合友元   类内实现</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printPerson</span><span class="hljs-params">(Person&lt;T1, T2&gt; &amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-comment">//全局函数配合友元  类外实现</span><br><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Person</span>(T1 name, T2 age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br><br><span class="hljs-keyword">private</span>:<br>T1 m_Name;<br>T2 m_Age;<br><br>&#125;;<br><br><span class="hljs-comment">//1、全局函数在类内实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-built_in">printPerson</span>(p);<br>&#125;<br><br><br><span class="hljs-comment">//2、全局函数在类外实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person &lt;string, <span class="hljs-type">int</span> &gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-built_in">printPerson2</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h4 id="类模板案例">1.3.9 类模板案例</h4><p>案例描述: 实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><strong>示例：</strong></p><p>myArray.hpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <br><span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">MyArray</span>(<span class="hljs-type">int</span> capacity)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Capacity = capacity;<br><span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;<br>pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];<br>&#125;<br><br><span class="hljs-comment">//拷贝构造</span><br><span class="hljs-built_in">MyArray</span>(<span class="hljs-type">const</span> MyArray &amp; arr)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;<br><span class="hljs-keyword">this</span>-&gt;m_Size = arr.m_Size;<br><span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;m_Size; i++)<br>&#123;<br><span class="hljs-comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span><br><span class="hljs-comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span><br><span class="hljs-keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//重载= 操作符  防止浅拷贝问题</span><br>MyArray&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyArray&amp; myarray) &#123;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;pAddress != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;pAddress;<br><span class="hljs-keyword">this</span>-&gt;m_Capacity = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;<br><span class="hljs-keyword">this</span>-&gt;m_Size = myarray.m_Size;<br><span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_Capacity];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;m_Size; i++) &#123;<br><span class="hljs-keyword">this</span>-&gt;pAddress[i] = myarray[i];<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//重载[] 操作符  arr[0]</span><br>T&amp; <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;pAddress[index]; <span class="hljs-comment">//不考虑越界，用户自己去处理</span><br>&#125;<br><br><span class="hljs-comment">//尾插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Capacity == <span class="hljs-keyword">this</span>-&gt;m_Size)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;pAddress[<span class="hljs-keyword">this</span>-&gt;m_Size] = val;<br><span class="hljs-keyword">this</span>-&gt;m_Size++;<br>&#125;<br><br><span class="hljs-comment">//尾删法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Size == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;m_Size--;<br>&#125;<br><br><span class="hljs-comment">//获取数组容量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_Capacity;<br>&#125;<br><br><span class="hljs-comment">//获取数组大小</span><br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">getSize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_Size;<br>&#125;<br><br><br><span class="hljs-comment">//析构</span><br>~<span class="hljs-built_in">MyArray</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;pAddress != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;pAddress;<br><span class="hljs-keyword">this</span>-&gt;pAddress = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">this</span>-&gt;m_Capacity = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;m_Size = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T * pAddress;  <span class="hljs-comment">//指向一个堆空间，这个空间存储真正的数据</span><br><span class="hljs-type">int</span> m_Capacity; <span class="hljs-comment">//容量</span><br><span class="hljs-type">int</span> m_Size;   <span class="hljs-comment">// 大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>类模板案例—数组类封装.cpp中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myArray.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printIntArray</span><span class="hljs-params">(MyArray&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); i++) &#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//测试内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">MyArray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>array1.<span class="hljs-built_in">Push_back</span>(i);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printIntArray</span>(array1);<br>cout &lt;&lt; <span class="hljs-string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-function">MyArray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array2</span><span class="hljs-params">(array1)</span></span>;<br>array2.<span class="hljs-built_in">Pop_back</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printIntArray</span>(array2);<br>cout &lt;&lt; <span class="hljs-string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//测试自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;&#125; <br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPersonArray</span><span class="hljs-params">(MyArray&lt;Person&gt;&amp; personArr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; personArr.<span class="hljs-built_in">getSize</span>(); i++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建数组</span><br><span class="hljs-function">MyArray&lt;Person&gt; <span class="hljs-title">pArray</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;韩信&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;妲己&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;王昭君&quot;</span>, <span class="hljs-number">15</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">24</span>)</span></span>;<br><br><span class="hljs-comment">//插入数据</span><br>pArray.<span class="hljs-built_in">Push_back</span>(p1);<br>pArray.<span class="hljs-built_in">Push_back</span>(p2);<br>pArray.<span class="hljs-built_in">Push_back</span>(p3);<br>pArray.<span class="hljs-built_in">Push_back</span>(p4);<br>pArray.<span class="hljs-built_in">Push_back</span>(p5);<br><br><span class="hljs-built_in">printPersonArray</span>(pArray);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>能够利用所学知识点实现通用的数组</p><h2 id="stl初识">2 STL初识</h2><h3 id="stl的诞生">2.1 STL的诞生</h3><ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li><li>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></li></ul><h3 id="stl基本概念">2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm)迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="stl六大组件">2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol type="1"><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="stl中容器算法迭代器">2.4 STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p><strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr class="header"><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr class="odd"><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr class="even"><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr class="odd"><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr class="even"><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、--，</td></tr><tr class="odd"><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="容器算法迭代器初识">2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="vector存放内置数据类型">2.5.1 vector存放内置数据类型</h4><p>容器： <code>vector</code></p><p>算法： <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-comment">//向容器中放数据</span><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span><br><span class="hljs-comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span><br><span class="hljs-comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span><br><span class="hljs-comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pBegin = v.<span class="hljs-built_in">begin</span>();<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pEnd = v.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-comment">//第一种遍历方式：</span><br><span class="hljs-keyword">while</span> (pBegin != pEnd) &#123;<br>cout &lt;&lt; *pBegin &lt;&lt; endl;<br>pBegin++;<br>&#125;<br><br><br><span class="hljs-comment">//第二种遍历方式：</span><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//第三种遍历方式：</span><br><span class="hljs-comment">//使用STL提供标准遍历算法  头文件 algorithm</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), MyPrint);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector存放自定义数据类型">2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) &#123;<br>mName = name;<br>mAge = age;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string mName;<br><span class="hljs-type">int</span> mAge;<br>&#125;;<br><span class="hljs-comment">//存放对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;Person&gt; v;<br><br><span class="hljs-comment">//创建数据</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;eee&quot;</span>, <span class="hljs-number">50</span>)</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br>v.<span class="hljs-built_in">push_back</span>(p5);<br><br><span class="hljs-keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="hljs-string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;<br><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//放对象指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;Person*&gt; v;<br><br><span class="hljs-comment">//创建数据</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;eee&quot;</span>, <span class="hljs-number">50</span>)</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(&amp;p1);<br>v.<span class="hljs-built_in">push_back</span>(&amp;p2);<br>v.<span class="hljs-built_in">push_back</span>(&amp;p3);<br>v.<span class="hljs-built_in">push_back</span>(&amp;p4);<br>v.<span class="hljs-built_in">push_back</span>(&amp;p5);<br><br><span class="hljs-keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>Person * p = (*it);<br>cout &lt;&lt; <span class="hljs-string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="hljs-string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br>  <br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector容器嵌套容器">2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">//容器嵌套容器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt;  v;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>vector&lt;<span class="hljs-type">int</span>&gt; v3;<br>vector&lt;<span class="hljs-type">int</span>&gt; v4;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>v2.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">2</span>);<br>v3.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">3</span>);<br>v4.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-comment">//将容器元素插入到vector v中</span><br>v.<span class="hljs-built_in">push_back</span>(v1);<br>v.<span class="hljs-built_in">push_back</span>(v2);<br>v.<span class="hljs-built_in">push_back</span>(v3);<br>v.<span class="hljs-built_in">push_back</span>(v4);<br><br><br><span class="hljs-keyword">for</span> (vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator vit = (*it).<span class="hljs-built_in">begin</span>(); vit != (*it).<span class="hljs-built_in">end</span>(); vit++) &#123;<br>cout &lt;&lt; *vit &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stl--常用容器">3 STL- 常用容器</h2><h3 id="string容器">3.1 string容器</h3><h4 id="string基本概念">3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="string构造函数">3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code> //创建一个空的字符串 例如: string str;<code>string(const char* s);</code> //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>//使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code> //使用n个字符c初始化</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">//string构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s1; <span class="hljs-comment">//创建空字符串，调用无参构造函数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(str)</span></span>; <span class="hljs-comment">//把c_string转换成了string</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;<br><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;<br><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="string赋值操作">3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code> //char*类型字符串赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>//把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>//字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>//把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>//把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>//把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>//用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//赋值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str1;<br>str1 = <span class="hljs-string">&quot;hello world&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br>string str2;<br>str2 = str1;<br>cout &lt;&lt; <span class="hljs-string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br><br>string str3;<br>str3 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br><br>string str4;<br>str4.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello c++&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;<br><br>string str5;<br>str5.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello c++&quot;</span>,<span class="hljs-number">5</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;<br><br><br>string str6;<br>str6.<span class="hljs-built_in">assign</span>(str5);<br>cout &lt;&lt; <span class="hljs-string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>string str7;<br>str7.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;x&#x27;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>string的赋值方式很多，<code>operator=</code> 这种方式是比较实用的</p><h4 id="string字符串拼接">3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>//重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>//重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>//重载+=操作符</li><li><code>string&amp; append(const char *s);</code>//把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>//把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>//同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//字符串拼接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str1 = <span class="hljs-string">&quot;我&quot;</span>;<br><br>str1 += <span class="hljs-string">&quot;爱玩游戏&quot;</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br>str1 += <span class="hljs-string">&#x27;:&#x27;</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br>string str2 = <span class="hljs-string">&quot;LOL DNF&quot;</span>;<br><br>str1 += str2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br>string str3 = <span class="hljs-string">&quot;I&quot;</span>;<br>str3.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; love &quot;</span>);<br>str3.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;game abcde&quot;</span>, <span class="hljs-number">4</span>);<br><span class="hljs-comment">//str3.append(str2);</span><br>str3.<span class="hljs-built_in">append</span>(str2, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span><br>cout &lt;&lt; <span class="hljs-string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="string查找和替换">3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>//查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const;</code>//查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code>//从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code>//查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>//查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>//查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>//从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code>//查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code>//替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code>//替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//查找和替换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//查找</span><br>string str1 = <span class="hljs-string">&quot;abcdefgde&quot;</span>;<br><br><span class="hljs-type">int</span> pos = str1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;de&quot;</span>);<br><br><span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;<br>&#125;<br><br><br>pos = str1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;de&quot;</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//替换</span><br>string str1 = <span class="hljs-string">&quot;abcdefgde&quot;</span>;<br>str1.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;1111&quot;</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><span class="hljs-comment">//test02();</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="string字符串比较">3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回 0</p><p>&gt; 返回 1</p><p>&lt; 返回 -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const;</code>//与字符串s比较</li><li><code>int compare(const char *s) const;</code> //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//字符串比较</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;aello&quot;</span>;<br><br><span class="hljs-type">int</span> ret = s1.<span class="hljs-built_in">compare</span>(s2);<br><br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="string字符存取">3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n);</code> //通过[]方式取字符</li><li><code>char&amp; at(int n);</code> //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; str[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; str.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><br><span class="hljs-comment">//字符修改</span><br>str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>str.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;x&#x27;</span>;<br>cout &lt;&lt; str &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="string插入和删除">3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);</code>//插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code>//插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>//在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>//删除从Pos开始的n个字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//字符串插入和删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;111&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;<br><br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">//从1号位置开始3个字符</span><br>cout &lt;&lt; str &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4 id="string子串">3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>//返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//子串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>string str = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>string subStr = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;<br><br>string email = <span class="hljs-string">&quot;hello@sina.com&quot;</span>;<br><span class="hljs-type">int</span> pos = email.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;@&quot;</span>);<br>string username = email.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos);<br>cout &lt;&lt; <span class="hljs-string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3 id="vector容器">3.2 vector容器</h3><h4 id="vector基本概念">3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul><figure><img src="/img/clip_image0021.jpg" alt="说明: 2015-11-10_151152" /><figcaption aria-hidden="true">说明: 2015-11-10_151152</figcaption></figure><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="vector构造函数">3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v;</code>//采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code> //将v[begin(),end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1; <span class="hljs-comment">//无参构造</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1.begin(), v1.end())</span></span>;<br><span class="hljs-built_in">printVector</span>(v2);<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-built_in">printVector</span>(v3);<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3)</span></span>;<br><span class="hljs-built_in">printVector</span>(v4);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="vector赋值操作">3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li><li><code>assign(beg, end);</code> //将[beg,end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//赋值操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1; <span class="hljs-comment">//无参构造</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>v2 = v1;<br><span class="hljs-built_in">printVector</span>(v2);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v3;<br>v3.<span class="hljs-built_in">assign</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printVector</span>(v3);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v4;<br>v4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printVector</span>(v4);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="vector容量和大小">3.2.4 vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty();</code> //判断容器是否为空</p></li><li><p><code>capacity();</code> //容器的容量</p></li><li><p><code>size();</code> //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p><code>//如果容器变短，则末尾超出容器长度的元素被删除。</code></p></li><li><p><code>resize(int num, elem);</code>//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p><code>//如果容器变短，则末尾超出容器长度的元素被删除</code></p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><span class="hljs-keyword">if</span> (v1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1不为空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span><br>v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>,<span class="hljs-number">10</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br><br><span class="hljs-comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span><br>v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空 --- empty</li><li>返回元素个数 --- size</li><li>返回容器容量 --- capacity</li><li>重新指定大小 --- resize</li></ul><h4 id="vector插入和删除">3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code> //尾部插入元素ele</li><li><code>pop_back();</code> //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>//迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code> //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//插入和删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-comment">//尾插</span><br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br><span class="hljs-comment">//尾删</span><br>v1.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">printVector</span>(v1);<br><span class="hljs-comment">//插入</span><br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br><br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">printVector</span>(v1);<br><br><span class="hljs-comment">//删除</span><br>v1.<span class="hljs-built_in">erase</span>(v1.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printVector</span>(v1);<br><br><span class="hljs-comment">//清空</span><br>v1.<span class="hljs-built_in">erase</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>());<br>v1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printVector</span>(v1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插 --- push_back</li><li>尾删 --- pop_back</li><li>插入 --- insert (位置迭代器)</li><li>删除 --- erase （位置迭代器）</li><li>清空 --- clear</li></ul><h4 id="vector数据存取">3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; v1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; v1.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="vector互换容器">3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code> // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v1);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>&#123;<br>v2.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printVector</span>(v2);<br><br><span class="hljs-comment">//互换容器</span><br>cout &lt;&lt; <span class="hljs-string">&quot;互换后&quot;</span> &lt;&lt; endl;<br>v1.<span class="hljs-built_in">swap</span>(v2);<br><span class="hljs-built_in">printVector</span>(v1);<br><span class="hljs-built_in">printVector</span>(v2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//收缩内存</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v); <span class="hljs-comment">//匿名对象</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="vector预留空间">3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-comment">//预留空间</span><br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">if</span> (p != &amp;v[<span class="hljs-number">0</span>]) &#123;<br>p = &amp;v[<span class="hljs-number">0</span>];<br>num++;<br>&#125;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br>  <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h3 id="deque容器">3.3 deque容器</h3><h4 id="deque容器基本概念">3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><figure><img src="/img/clip_image002-1547547642923.jpg"alt="说明: 2015-11-19_204101" /><figcaption aria-hidden="true">说明: 2015-11-19_204101</figcaption></figure><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><figure><img src="/img/clip_image002-1547547896341.jpg"alt="clip_image002-1547547896341" /><figcaption aria-hidden="true">clip_image002-1547547896341</figcaption></figure><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="deque构造函数">3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT; //默认构造形式</li><li><code>deque(beg, end);</code> //构造函数将[beg,end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//deque构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>deque&lt;<span class="hljs-type">int</span>&gt; d1; <span class="hljs-comment">//无参构造函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d2</span><span class="hljs-params">(d1.begin(),d1.end())</span></span>;<br><span class="hljs-built_in">printDeque</span>(d2);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">d3</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br><span class="hljs-built_in">printDeque</span>(d3);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;d4 = d3;<br><span class="hljs-built_in">printDeque</span>(d4);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="deque赋值操作">3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&amp; operator=(const deque &amp;deq);</code>//重载等号操作符</li><li><code>assign(beg, end);</code> //将[beg,end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//赋值操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;d2;<br>d2 = d1;<br><span class="hljs-built_in">printDeque</span>(d2);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;d3;<br>d3.<span class="hljs-built_in">assign</span>(d1.<span class="hljs-built_in">begin</span>(), d1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printDeque</span>(d3);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;d4;<br>d4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printDeque</span>(d4);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="deque大小操作">3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code> //判断容器是否为空</p></li><li><p><code>deque.size();</code> //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p><code>//如果容器变短，则末尾超出容器长度的元素被删除。</code></p></li><li><p><code>deque.resize(num, elem);</code>//重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p><code>//如果容器变短，则末尾超出容器长度的元素被删除。</code></p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//大小操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">//判断容器是否为空</span><br><span class="hljs-keyword">if</span> (d1.<span class="hljs-built_in">empty</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;d1为空!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//统计大小</span><br>cout &lt;&lt; <span class="hljs-string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//重新指定大小</span><br>d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">printDeque</span>(d1);<br><br>d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">printDeque</span>(d1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空 --- empty</li><li>返回元素个数 --- size</li><li>重新指定个数 --- resize</li></ul><h4 id="deque-插入和删除">3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code> //在容器尾部添加一个数据</li><li><code>push_front(elem);</code> //在容器头部插入一个数据</li><li><code>pop_back();</code> //删除容器最后一个数据</li><li><code>pop_front();</code> //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><code>insert(pos,elem);</code>//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code>//在pos位置插入n个elem数据，无返回值。</li><li><code>insert(pos,beg,end);</code>//在pos位置插入[beg,end)区间的数据，无返回值。</li><li><code>clear();</code> //清空容器的所有数据</li><li><code>erase(beg,end);</code>//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>//删除pos位置的数据，返回下一个数据的位置。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//两端操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d;<br><span class="hljs-comment">//尾插</span><br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><span class="hljs-comment">//头插</span><br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-built_in">printDeque</span>(d);<br><br><span class="hljs-comment">//尾删</span><br>d.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">//头删</span><br>d.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-built_in">printDeque</span>(d);<br>&#125;<br><br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d;<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><span class="hljs-built_in">printDeque</span>(d);<br><br>d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">printDeque</span>(d);<br><br>d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>,<span class="hljs-number">10000</span>);<br><span class="hljs-built_in">printDeque</span>(d);<br><br>deque&lt;<span class="hljs-type">int</span>&gt;d2;<br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br>d.<span class="hljs-built_in">insert</span>(d.<span class="hljs-built_in">begin</span>(), d2.<span class="hljs-built_in">begin</span>(), d2.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printDeque</span>(d);<br><br>&#125;<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d;<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><span class="hljs-built_in">printDeque</span>(d);<br><br>d.<span class="hljs-built_in">erase</span>(d.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printDeque</span>(d);<br><br>d.<span class="hljs-built_in">erase</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());<br>d.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printDeque</span>(d);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-comment">//test02();</span><br><br>    <span class="hljs-built_in">test03</span>();<br>  <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插 --- push_back</li><li>尾删 --- pop_back</li><li>头插 --- push_front</li><li>头删 --- pop_front</li></ul><h4 id="deque-数据存取">3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//数据存取</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>deque&lt;<span class="hljs-type">int</span>&gt; d;<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d.<span class="hljs-built_in">size</span>(); i++) &#123;<br>cout &lt;&lt; d[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d.<span class="hljs-built_in">size</span>(); i++) &#123;<br>cout &lt;&lt; d.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;front:&quot;</span> &lt;&lt; d.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;back:&quot;</span> &lt;&lt; d.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="deque-排序">3.3.7 deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>//对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>deque&lt;<span class="hljs-type">int</span>&gt; d;<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-built_in">printDeque</span>(d);<br><span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printDeque</span>(d);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><h3 id="案例-评委打分">3.4 案例-评委打分</h3><h4 id="案例描述">3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4 id="实现步骤">3.4.2 实现步骤</h4><ol type="1"><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//选手类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> score)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Score = score;<br>&#125;<br><br>string m_Name; <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> m_Score;  <span class="hljs-comment">//平均分</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createPerson</span><span class="hljs-params">(vector&lt;Person&gt;&amp;v)</span></span><br><span class="hljs-function"></span>&#123;<br>string nameSeed = <span class="hljs-string">&quot;ABCDE&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>string name = <span class="hljs-string">&quot;选手&quot;</span>;<br>name += nameSeed[i];<br><br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br><br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(name, score)</span></span>;<br><br><span class="hljs-comment">//将创建的person对象 放入到容器中</span><br>v.<span class="hljs-built_in">push_back</span>(p);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//打分</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(vector&lt;Person&gt;&amp;v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br><span class="hljs-comment">//将评委的分数 放入到deque容器中</span><br>deque&lt;<span class="hljs-type">int</span>&gt;d;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> score = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">41</span> + <span class="hljs-number">60</span>;  <span class="hljs-comment">// 60 ~ 100</span><br>d.<span class="hljs-built_in">push_back</span>(score);<br>&#125;<br><br><span class="hljs-comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//cout &lt;&lt; endl;</span><br><br><span class="hljs-comment">//排序</span><br><span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">//去除最高和最低分</span><br>d.<span class="hljs-built_in">pop_back</span>();<br>d.<span class="hljs-built_in">pop_front</span>();<br><br><span class="hljs-comment">//取平均分</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (deque&lt;<span class="hljs-type">int</span>&gt;::iterator dit = d.<span class="hljs-built_in">begin</span>(); dit != d.<span class="hljs-built_in">end</span>(); dit++)<br>&#123;<br>sum += *dit; <span class="hljs-comment">//累加每个评委的分数</span><br>&#125;<br><br><span class="hljs-type">int</span> avg = sum / d.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-comment">//将平均分 赋值给选手身上</span><br>it-&gt;m_Score = avg;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showScore</span><span class="hljs-params">(vector&lt;Person&gt;&amp;v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//随机数种子</span><br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><br><span class="hljs-comment">//1、创建5名选手</span><br>vector&lt;Person&gt;v;  <span class="hljs-comment">//存放选手容器</span><br><span class="hljs-built_in">createPerson</span>(v);<br><br><span class="hljs-comment">//测试</span><br><span class="hljs-comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//2、给5名选手打分</span><br><span class="hljs-built_in">setScore</span>(v);<br><br><span class="hljs-comment">//3、显示最后得分</span><br><span class="hljs-built_in">showScore</span>(v);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>选取不同的容器操作数据，可以提升代码的效率</p><h3 id="stack容器">3.5 stack容器</h3><h4 id="stack-基本概念">3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First InLast Out,FILO)的数据结构，它只有一个出口</p><figure><img src="/img/clip_image002-1547604555425.jpg"alt="说明: 2015-11-15_195707" /><figcaption aria-hidden="true">说明: 2015-11-15_195707</figcaption></figure><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为 --- <strong>入栈</strong> <code>push</code></p><p>栈中弹出数据称为 --- <strong>出栈</strong> <code>pop</code></p><p>生活中的栈：</p><figure><img src="/img/clip_image0022.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/img/clip_image002-1547605111510.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="stack-常用接口">3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code> //stack采用模板类实现，stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>//重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> //向栈顶添加元素</li><li><code>pop();</code> //从栈顶移除第一个元素</li><li><code>top();</code> //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-comment">//栈容器常用接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建栈容器 栈容器必须符合先进后出</span><br>stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br><span class="hljs-comment">//向栈中添加元素，叫做 压栈 入栈</span><br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-comment">//输出栈顶元素</span><br>cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><span class="hljs-comment">//弹出栈顶元素</span><br>s.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈 --- push</li><li>出栈 --- pop</li><li>返回栈顶 --- top</li><li>判断栈是否为空 --- empty</li><li>返回栈大小 --- size</li></ul><h3 id="queue-容器">3.6 queue 容器</h3><h4 id="queue-基本概念">3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First InFirst Out,FIFO)的数据结构，它有两个出口</p><figure><img src="/img/clip_image002-1547606475892.jpg"alt="说明: 2015-11-15_214429" /><figcaption aria-hidden="true">说明: 2015-11-15_214429</figcaption></figure><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 --- <strong>入队</strong> <code>push</code></p><p>队列中出数据称为 --- <strong>出队</strong> <code>pop</code></p><p>生活中的队列：</p><figure><img src="/img/1547606785041.png" alt="1547606785041" /><figcaption aria-hidden="true">1547606785041</figcaption></figure><h4 id="queue-常用接口">3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>//queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>//重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code> //往队尾添加元素</li><li><code>pop();</code> //从队头移除第一个元素</li><li><code>back();</code> //返回最后一个元素</li><li><code>front();</code> //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//创建队列</span><br>queue&lt;Person&gt; q;<br><br><span class="hljs-comment">//准备数据</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;唐僧&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">1000</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-number">900</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;沙僧&quot;</span>, <span class="hljs-number">800</span>)</span></span>;<br><br><span class="hljs-comment">//向队列中添加元素  入队操作</span><br>q.<span class="hljs-built_in">push</span>(p1);<br>q.<span class="hljs-built_in">push</span>(p2);<br>q.<span class="hljs-built_in">push</span>(p3);<br>q.<span class="hljs-built_in">push</span>(p4);<br><br><span class="hljs-comment">//队列不提供迭代器，更不支持随机访问</span><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-comment">//输出队头元素</span><br>cout &lt;&lt; <span class="hljs-string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="hljs-built_in">front</span>().m_Name <br>              &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="hljs-built_in">front</span>().m_Age &lt;&lt; endl;<br>    <br>cout &lt;&lt; <span class="hljs-string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>().m_Name  <br>              &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>().m_Age &lt;&lt; endl;<br>    <br>cout &lt;&lt; endl;<br><span class="hljs-comment">//弹出队头元素</span><br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>入队 --- push</li><li>出队 --- pop</li><li>返回队头元素 --- front</li><li>返回队尾元素 --- back</li><li>判断队是否为空 --- empty</li><li>返回队列大小 --- size</li></ul><h3 id="list容器">3.7 list容器</h3><h4 id="list基本概念">3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><figure><img src="/img/clip_image002-1547608564071.jpg"alt="说明: 2015-11-15_225145" /><figcaption aria-hidden="true">说明: 2015-11-15_225145</figcaption></figure><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="list构造函数">3.7.2 list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>//list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code> //构造函数将[beg,end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code> //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;L1;<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-built_in">printList</span>(L1);<br><br>list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">L2</span>(L1.<span class="hljs-built_in">begin</span>(),L1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printList</span>(L2);<br><br>list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">L3</span>(L2);<br><span class="hljs-built_in">printList</span>(L3);<br><br>list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">L4</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">printList</span>(L4);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="list-赋值和交换">3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code> //将[beg,end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>//重载等号操作符</li><li><code>swap(lst);</code> //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//赋值和交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;L1;<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printList</span>(L1);<br><br><span class="hljs-comment">//赋值</span><br>list&lt;<span class="hljs-type">int</span>&gt;L2;<br>L2 = L1;<br><span class="hljs-built_in">printList</span>(L2);<br><br>list&lt;<span class="hljs-type">int</span>&gt;L3;<br>L3.<span class="hljs-built_in">assign</span>(L2.<span class="hljs-built_in">begin</span>(), L2.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printList</span>(L3);<br><br>list&lt;<span class="hljs-type">int</span>&gt;L4;<br>L4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printList</span>(L4);<br><br>&#125;<br><br><span class="hljs-comment">//交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>list&lt;<span class="hljs-type">int</span>&gt;L1;<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br>list&lt;<span class="hljs-type">int</span>&gt;L2;<br>L2.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前： &quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printList</span>(L1);<br><span class="hljs-built_in">printList</span>(L2);<br><br>cout &lt;&lt; endl;<br><br>L1.<span class="hljs-built_in">swap</span>(L2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后： &quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printList</span>(L1);<br><span class="hljs-built_in">printList</span>(L2);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：list赋值和交换操作能够灵活运用即可</p><h4 id="list-大小操作">3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size();</code> //返回容器中元素的个数</p></li><li><p><code>empty();</code> //判断容器是否为空</p></li><li><p><code>resize(num);</code>//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p><code>//如果容器变短，则末尾超出容器长度的元素被删除。</code></p></li><li><p><code>resize(num, elem);</code>//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p><code>//如果容器变短，则末尾超出容器长度的元素被删除。</code></p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//大小操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;L1;<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-keyword">if</span> (L1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;L1为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;L1不为空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//重新指定大小</span><br>L1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">printList</span>(L1);<br><br>L1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">printList</span>(L1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空 --- empty</li><li>返回元素个数 --- size</li><li>重新指定个数 --- resize</li></ul><h4 id="list-插入和删除">3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//插入和删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt; L;<br><span class="hljs-comment">//尾插</span><br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br><span class="hljs-comment">//头插</span><br>L.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>L.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>L.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">300</span>);<br><br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//尾删</span><br>L.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//头删</span><br>L.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//插入</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = L.<span class="hljs-built_in">begin</span>();<br>L.<span class="hljs-built_in">insert</span>(++it, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//删除</span><br>it = L.<span class="hljs-built_in">begin</span>();<br>L.<span class="hljs-built_in">erase</span>(++it);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//移除</span><br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br><span class="hljs-built_in">printList</span>(L);<br>L.<span class="hljs-built_in">remove</span>(<span class="hljs-number">10000</span>);<br><span class="hljs-built_in">printList</span>(L);<br>  <br>    <span class="hljs-comment">//清空</span><br>L.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printList</span>(L);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插 --- push_back</li><li>尾删 --- pop_back</li><li>头插 --- push_front</li><li>头删 --- pop_front</li><li>插入 --- insert</li><li>删除 --- erase</li><li>移除 --- remove</li><li>清空 --- clear</li></ul><h4 id="list-数据存取">3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code> //返回第一个元素。</li><li><code>back();</code> //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-comment">//数据存取</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;L1;<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br><br><span class="hljs-comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span><br><span class="hljs-comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span><br>cout &lt;&lt; <span class="hljs-string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//list容器的迭代器是双向迭代器，不支持随机访问</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = L1.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素 --- front</li><li>返回最后一个元素 --- back</li></ul><h4 id="list-反转和排序">3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code> //反转链表</li><li><code>sort();</code> //链表排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; L)</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> val1 , <span class="hljs-type">int</span> val2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val1 &gt; val2;<br>&#125;<br><br><span class="hljs-comment">//反转和排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt; L;<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">90</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">70</span>);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//反转容器的元素</span><br>L.<span class="hljs-built_in">reverse</span>();<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//排序</span><br>L.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">//默认的排序规则 从小到大</span><br><span class="hljs-built_in">printList</span>(L);<br><br>L.<span class="hljs-built_in">sort</span>(myCompare); <span class="hljs-comment">//指定规则，从大到小</span><br><span class="hljs-built_in">printList</span>(L);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>反转 --- reverse</li><li>排序 --- sort （成员函数）</li></ul><h4 id="排序案例">3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age , <span class="hljs-type">int</span> height) &#123;<br>m_Name = name;<br>m_Age = age;<br>m_Height = height;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br>string m_Name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> m_Age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> m_Height;   <span class="hljs-comment">//身高</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ComparePerson</span><span class="hljs-params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (p1.m_Age == p2.m_Age) &#123;<br><span class="hljs-keyword">return</span> p1.m_Height  &gt; p2.m_Height;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span>  p1.m_Age &lt; p2.m_Age;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>list&lt;Person&gt; L;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">35</span> , <span class="hljs-number">175</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;曹操&quot;</span>, <span class="hljs-number">45</span> , <span class="hljs-number">180</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;孙权&quot;</span>, <span class="hljs-number">40</span> , <span class="hljs-number">170</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">25</span> , <span class="hljs-number">190</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">35</span> , <span class="hljs-number">160</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">35</span> , <span class="hljs-number">200</span>)</span></span>;<br><br>L.<span class="hljs-built_in">push_back</span>(p1);<br>L.<span class="hljs-built_in">push_back</span>(p2);<br>L.<span class="hljs-built_in">push_back</span>(p3);<br>L.<span class="hljs-built_in">push_back</span>(p4);<br>L.<span class="hljs-built_in">push_back</span>(p5);<br>L.<span class="hljs-built_in">push_back</span>(p6);<br><br><span class="hljs-keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age <br>              &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;<br>L.<span class="hljs-built_in">sort</span>(ComparePerson); <span class="hljs-comment">//排序</span><br><br><span class="hljs-keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="hljs-built_in">begin</span>(); it != L.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age <br>              &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li><li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li></ul><h3 id="set-multiset-容器">3.8 set/ multiset 容器</h3><h4 id="set基本概念">3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="set构造和赋值">3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code> //默认构造函数：</li><li><code>set(const set &amp;st);</code> //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>//重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//构造和赋值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">//拷贝构造</span><br>set&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">s2</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br><br><span class="hljs-comment">//赋值</span><br>set&lt;<span class="hljs-type">int</span>&gt;s3;<br>s3 = s2;<br><span class="hljs-built_in">printSet</span>(s3);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="set大小和交换">3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1不为空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br>set&lt;<span class="hljs-type">int</span>&gt; s2;<br><br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">100</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">300</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">200</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">400</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printSet</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后&quot;</span> &lt;&lt; endl;<br>s1.<span class="hljs-built_in">swap</span>(s2);<br><span class="hljs-built_in">printSet</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小 --- size</li><li>判断是否为空 --- empty</li><li>交换容器 --- swap</li></ul><h4 id="set插入和删除">3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code> //在容器中插入元素。</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code>//删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</li><li><code>erase(elem);</code> //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; &amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//插入和删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><span class="hljs-comment">//插入</span><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">//删除</span><br>s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printSet</span>(s1);<br><br>s1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">30</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">//清空</span><br><span class="hljs-comment">//s1.erase(s1.begin(), s1.end());</span><br>s1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printSet</span>(s1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>插入 --- insert</li><li>删除 --- erase</li><li>清空 --- clear</li></ul><h4 id="set查找和统计">3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>//查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-comment">//查找和统计</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><span class="hljs-comment">//插入</span><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">//查找</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator pos = s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">30</span>);<br><br><span class="hljs-keyword">if</span> (pos != s1.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到元素&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//统计</span><br><span class="hljs-type">int</span> num = s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">30</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>查找 --- find （返回的是迭代器）</li><li>统计 --- count （对于set，结果为0或者1）</li></ul><h4 id="set和multiset区别">3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-comment">//set和multiset区别</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s;<br>pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt;  ret = s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (ret.second) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>ret = s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (ret.second) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;<br>&#125;<br>  <br><span class="hljs-comment">//multiset</span><br>multiset&lt;<span class="hljs-type">int</span>&gt; ms;<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">for</span> (multiset&lt;<span class="hljs-type">int</span>&gt;::iterator it = ms.<span class="hljs-built_in">begin</span>(); it != ms.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="pair对组创建">3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//对组创建</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(string(<span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-number">20</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;<br><br>pair&lt;string, <span class="hljs-type">int</span>&gt; p2 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-number">10</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="set容器排序">3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong> set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;  <br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-comment">//默认从小到大</span><br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s1.<span class="hljs-built_in">begin</span>(); it != s1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//指定排序规则</span><br>set&lt;<span class="hljs-type">int</span>,MyCompare&gt; s2;<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>, MyCompare&gt;::iterator it = s2.<span class="hljs-built_in">begin</span>(); it != s2.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">comparePerson</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p1, <span class="hljs-type">const</span> Person &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//按照年龄进行排序  降序</span><br><span class="hljs-keyword">return</span> p1.m_Age &gt; p2.m_Age;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;Person, comparePerson&gt; s;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">23</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">27</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">21</span>)</span></span>;<br><br>s.<span class="hljs-built_in">insert</span>(p1);<br>s.<span class="hljs-built_in">insert</span>(p2);<br>s.<span class="hljs-built_in">insert</span>(p3);<br>s.<span class="hljs-built_in">insert</span>(p4);<br><br><span class="hljs-keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="map-multimap容器">3.9 map/ multimap容器</h3><h4 id="map基本概念">3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="map构造和赋值">3.9.2 map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code> //map默认构造函数:</li><li><code>map(const map &amp;mp);</code> //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>//重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m; <span class="hljs-comment">//默认构造</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><span class="hljs-built_in">printMap</span>(m);<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<span class="hljs-built_in">m2</span>(m); <span class="hljs-comment">//拷贝构造</span><br><span class="hljs-built_in">printMap</span>(m2);<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m3;<br>m3 = m2; <span class="hljs-comment">//赋值</span><br><span class="hljs-built_in">printMap</span>(m3);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="map大小和交换">3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><br><span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;m为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;m不为空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m2;<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">100</span>));<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">200</span>));<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">6</span>, <span class="hljs-number">300</span>));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printMap</span>(m);<br><span class="hljs-built_in">printMap</span>(m2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后&quot;</span> &lt;&lt; endl;<br>m.<span class="hljs-built_in">swap</span>(m2);<br><span class="hljs-built_in">printMap</span>(m);<br><span class="hljs-built_in">printMap</span>(m2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小 --- size</li><li>判断是否为空 --- empty</li><li>交换容器 --- swap</li></ul><h4 id="map插入和删除">3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code> //在容器中插入元素。</li><li><code>clear();</code> //清除所有元素</li><li><code>erase(pos);</code>//删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</li><li><code>erase(key);</code> //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//插入</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br><span class="hljs-comment">//第一种插入方式</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br><span class="hljs-comment">//第二种插入方式</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br><span class="hljs-comment">//第三种插入方式</span><br>m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><span class="hljs-comment">//第四种插入方式</span><br>m[<span class="hljs-number">4</span>] = <span class="hljs-number">40</span>; <br><span class="hljs-built_in">printMap</span>(m);<br><br><span class="hljs-comment">//删除</span><br>m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printMap</span>(m);<br><br>m.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">printMap</span>(m);<br><br><span class="hljs-comment">//清空</span><br>m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>(),m.<span class="hljs-built_in">end</span>());<br>m.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printMap</span>(m);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><p>map插入方式很多，记住其一即可</p></li><li><p>插入 --- insert</p></li><li><p>删除 --- erase</p></li><li><p>清空 --- clear</p></li></ul><h4 id="map查找和统计">3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>//查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code> //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-comment">//查找和统计</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m; <br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><br><span class="hljs-comment">//查找</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator pos = m.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">if</span> (pos != m.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="hljs-string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到元素&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//统计</span><br><span class="hljs-type">int</span> num = m.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>查找 --- find （返回的是迭代器）</li><li>统计 --- count （对于map，结果为0或者1）</li></ul><h4 id="map容器排序">3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//默认从小到大排序</span><br><span class="hljs-comment">//利用仿函数实现从大到小排序</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt; m;<br><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">4</span>, <span class="hljs-number">40</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">5</span>, <span class="hljs-number">50</span>));<br><br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="案例-员工分组">3.10 案例-员工分组</h3><h4 id="案例描述-1">3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入 key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="实现步骤-1">3.10.2 实现步骤</h4><ol type="1"><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span><br><span class="hljs-comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span><br><span class="hljs-comment">- 随机给10名员工分配部门和工资</span><br><span class="hljs-comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span><br><span class="hljs-comment">- 分部门显示员工信息</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CEHUA  0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEISHU 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YANFA  2</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>string m_Name;<br><span class="hljs-type">int</span> m_Salary;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createWorker</span><span class="hljs-params">(vector&lt;Worker&gt;&amp;v)</span></span><br><span class="hljs-function"></span>&#123;<br>string nameSeed = <span class="hljs-string">&quot;ABCDEFGHIJ&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>Worker worker;<br>worker.m_Name = <span class="hljs-string">&quot;员工&quot;</span>;<br>worker.m_Name += nameSeed[i];<br><br>worker.m_Salary = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10000</span> + <span class="hljs-number">10000</span>; <span class="hljs-comment">// 10000 ~ 19999</span><br><span class="hljs-comment">//将员工放入到容器中</span><br>v.<span class="hljs-built_in">push_back</span>(worker);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//员工分组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGroup</span><span class="hljs-params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="hljs-type">int</span>,Worker&gt;&amp;m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br><span class="hljs-comment">//产生随机部门编号</span><br><span class="hljs-type">int</span> deptId = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>; <span class="hljs-comment">// 0 1 2 </span><br><br><span class="hljs-comment">//将员工插入到分组中</span><br><span class="hljs-comment">//key部门编号，value具体员工</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(deptId, *it));<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showWorkerByGourp</span><span class="hljs-params">(multimap&lt;<span class="hljs-type">int</span>,Worker&gt;&amp;m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 0  A  B  C   1  D  E   2  F G ...</span><br>cout &lt;&lt; <span class="hljs-string">&quot;策划部门：&quot;</span> &lt;&lt; endl;<br><br>multimap&lt;<span class="hljs-type">int</span>,Worker&gt;::iterator pos = m.<span class="hljs-built_in">find</span>(CEHUA);<br><span class="hljs-type">int</span> count = m.<span class="hljs-built_in">count</span>(CEHUA); <span class="hljs-comment">// 统计具体人数</span><br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="hljs-string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;美术部门： &quot;</span> &lt;&lt; endl;<br>pos = m.<span class="hljs-built_in">find</span>(MEISHU);<br>count = m.<span class="hljs-built_in">count</span>(MEISHU); <span class="hljs-comment">// 统计具体人数</span><br>index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="hljs-string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;研发部门： &quot;</span> &lt;&lt; endl;<br>pos = m.<span class="hljs-built_in">find</span>(YANFA);<br>count = m.<span class="hljs-built_in">count</span>(YANFA); <span class="hljs-comment">// 统计具体人数</span><br>index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="hljs-string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><br><span class="hljs-comment">//1、创建员工</span><br>vector&lt;Worker&gt;vWorker;<br><span class="hljs-built_in">createWorker</span>(vWorker);<br><br><span class="hljs-comment">//2、员工分组</span><br>multimap&lt;<span class="hljs-type">int</span>, Worker&gt;mWorker;<br><span class="hljs-built_in">setGroup</span>(vWorker, mWorker);<br><br><br><span class="hljs-comment">//3、分组显示员工</span><br><span class="hljs-built_in">showWorkerByGourp</span>(mWorker);<br><br><span class="hljs-comment">////测试</span><br><span class="hljs-comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul><h2 id="stl--函数对象">4 STL- 函数对象</h2><h3 id="函数对象">4.1 函数对象</h3><h4 id="函数对象概念">4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="函数对象使用">4.1.2 函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用,可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span><br>&#123;<br><span class="hljs-keyword">public</span> :<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 + v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyAdd myAdd;<br>cout &lt;&lt; <span class="hljs-built_in">myAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//2、函数对象可以有自己的状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyPrint</span>()<br>&#123;<br>count = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; test &lt;&lt; endl;<br>count++; <span class="hljs-comment">//统计使用次数</span><br>&#125;<br><br><span class="hljs-type">int</span> count; <span class="hljs-comment">//内部自己的状态</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyPrint myPrint;<br><span class="hljs-built_in">myPrint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">myPrint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">myPrint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//3、函数对象可以作为参数传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPrint</span><span class="hljs-params">(MyPrint &amp;mp , string test)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">mp</span>(test);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyPrint myPrint;<br><span class="hljs-built_in">doPrint</span>(myPrint, <span class="hljs-string">&quot;Hello C++&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><span class="hljs-comment">//test02();</span><br><span class="hljs-built_in">test03</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="谓词">4.2 谓词</h3><h4 id="谓词概念">4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="一元谓词">4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">//1.一元谓词</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GreaterFive</span>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="二元谓词">4.2.3 二元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">//二元谓词</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> num1 &gt; num2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-comment">//默认从小到大</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//使用函数对象改变算法策略，排序从大到小</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MyCompare</span>());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><h3 id="内建函数对象">4.3 内建函数对象</h3><h4 id="内建函数对象意义">4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件<code>#include&lt;functional&gt;</code></li></ul><h4 id="算术仿函数">4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>//加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>//减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>//乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>//除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>//取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>//取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-comment">//negate</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>negate&lt;<span class="hljs-type">int</span>&gt; n;<br>cout &lt;&lt; <span class="hljs-built_in">n</span>(<span class="hljs-number">50</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//plus</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>plus&lt;<span class="hljs-type">int</span>&gt; p;<br>cout &lt;&lt; <span class="hljs-built_in">p</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件<code>#include &lt;functional&gt;</code></p><h4 id="关系仿函数">4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>//等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>//不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>//大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>//大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code> //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>//小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//自己实现仿函数</span><br><span class="hljs-comment">//sort(v.begin(), v.end(), MyCompare());</span><br><span class="hljs-comment">//STL内建仿函数  大于仿函数</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="逻辑仿函数">4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>//逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>//逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>//逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">bool</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();it!= v.<span class="hljs-built_in">end</span>();it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span><br>vector&lt;<span class="hljs-type">bool</span>&gt; v2;<br>v2.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),  v2.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">logical_not</span>&lt;<span class="hljs-type">bool</span>&gt;());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it = v2.<span class="hljs-built_in">begin</span>(); it != v2.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：逻辑仿函数实际应用较少，了解即可</p><h2 id="stl--常用算法">5 STL- 常用算法</h2><p><strong>概述</strong>:</p><ul><li>算法主要是由头文件 <code>&lt;algorithm&gt;</code><code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li></ul><h3 id="常用遍历算法">5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code> //遍历容器</li><li><code>transform</code> //搬运容器到另一个容器中</li></ul><h4 id="for_each">5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);</code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print01</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">//函数对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">print02</span> <br>&#123;<br> <span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//for_each算法基本用法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) <br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">//遍历算法</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), print01);<br>cout &lt;&lt; endl;<br><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print02</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="transform">5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">//常用遍历算法  搬运 transform</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransForm</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;vTarget; <span class="hljs-comment">//目标容器</span><br><br>vTarget.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 目标容器需要提前开辟空间</span><br><br><span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">TransForm</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), vTarget.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MyPrint</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="常用查找算法">5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code> //查找元素</li><li><code>find_if</code> //按条件查找元素</li><li><code>adjacent_find</code> //查找相邻重复元素</li><li><code>binary_search</code> //二分查找法</li><li><code>count</code> //统计元素个数</li><li><code>count_if</code> //按条件统计元素个数</li></ul><h4 id="find">5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//查找容器中是否有 5 这个元素</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>);<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有找到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) <br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><span class="hljs-comment">//重载==</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person&amp; p) <br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age) <br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;Person&gt; v;<br><br><span class="hljs-comment">//创建数据</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br><br>vector&lt;Person&gt;::iterator it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), p2);<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有找到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="find_if">5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//内置数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterFive</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有找到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greater20</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Person &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> p.m_Age &gt; <span class="hljs-number">20</span>;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;Person&gt; v;<br><br><span class="hljs-comment">//创建数据</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br><br>vector&lt;Person&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Greater20</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有找到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="adjacent_find">5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);</code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//查找相邻重复元素</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找不到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="binary_search">5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);</code></p><p>// 查找指定的元素，查到 返回true 否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">//二分查找</span><br><span class="hljs-type">bool</span> ret = <span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span> (ret)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="count">5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);</code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">//内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person &amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;Person&gt; v;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;曹操&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br>v.<span class="hljs-built_in">push_back</span>(p5);<br>  <br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;诸葛亮&quot;</span>,<span class="hljs-number">35</span>)</span></span>;<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), p);<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载<code>operator==</code></p><h4 id="count_if">5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);</code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greater4</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">4</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Greater4</span>());<br><br>cout &lt;&lt; <span class="hljs-string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeLess35</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> p.m_Age &lt; <span class="hljs-number">35</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;Person&gt; v;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;曹操&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br><br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br>v.<span class="hljs-built_in">push_back</span>(p5);<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">AgeLess35</span>());<br>cout &lt;&lt; <span class="hljs-string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p><h3 id="常用排序算法">5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code> //对容器内元素进行排序</li><li><code>random_shuffle</code> //洗牌 指定范围内的元素随机调整次序</li><li><code>merge</code> // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code> // 反转指定范围的元素</li></ul><h4 id="sort">5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">//sort默认从小到大排序</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//从大到小排序</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myPrint);<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="random_shuffle">5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌 指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);</code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>;i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//打乱顺序</span><br><span class="hljs-built_in">random_shuffle</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="merge">5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2容器2开始迭代器 // end2 容器2结束迭代器 // dest目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span> ; i++) <br>    &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vtarget;<br><span class="hljs-comment">//目标容器需要提前开辟空间</span><br>vtarget.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>() + v2.<span class="hljs-built_in">size</span>());<br><span class="hljs-comment">//合并  需要两个有序序列</span><br><span class="hljs-built_in">merge</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vtarget.<span class="hljs-built_in">begin</span>());<br>for_each(vtarget.<span class="hljs-built_in">begin</span>(), vtarget.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p><h4 id="reverse">5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);</code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;反转前： &quot;</span> &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;反转后： &quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p><h3 id="常用拷贝和替换算法">5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code> // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code> // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code> //容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code> // 互换两个容器的元素</li></ul><h4 id="copy">5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>v2.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">copy</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>());<br><br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="replace">5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;替换前：&quot;</span> &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//将容器中的20 替换成 2000</span><br>cout &lt;&lt; <span class="hljs-string">&quot;替换后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">replace</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">20</span>,<span class="hljs-number">2000</span>);<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>replace会替换区间内满足条件的元素</p><h4 id="replace_if">5.4.3 replace_if</h4><p><strong>功能描述:</strong></p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplaceGreater30</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">30</span>;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;替换前：&quot;</span> &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//将容器中大于等于的30 替换成 3000</span><br>cout &lt;&lt; <span class="hljs-string">&quot;替换后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">replace_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ReplaceGreater30</span>(), <span class="hljs-number">3000</span>);<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="swap">5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);</code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">100</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前： &quot;</span> &lt;&lt; endl;<br>for_each(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后： &quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">swap</span>(v1, v2);<br>for_each(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p><h3 id="常用算术生成算法">5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为<code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><code>accumulate</code> // 计算容器元素累计总和</li><li><code>fill</code> // 向容器中添加元素</li></ul><h4 id="accumulate">5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);</code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-type">int</span> total = <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>accumulate使用时头文件注意是numeric，这个算法很实用</p><h4 id="fill">5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);</code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//填充</span><br><span class="hljs-built_in">fill</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">100</span>);<br><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>利用fill可以将容器区间内元素填充为指定的值</p><h3 id="常用集合算法">5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>set_intersection</code> // 求两个容器的交集</li><li><code>set_union</code> // 求两个容器的并集</li><li><code>set_difference</code> // 求两个容器的差集</li></ul><h4 id="set_intersection">5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2容器2开始迭代器 // end2 容器2结束迭代器 // dest目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vTarget;<br><span class="hljs-comment">//取两个里面较小的值给目标容器开辟空间</span><br>vTarget.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">min</span>(v1.<span class="hljs-built_in">size</span>(), v2.<span class="hljs-built_in">size</span>()));<br><br><span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <br>        <span class="hljs-built_in">set_intersection</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="set_union">5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2容器2开始迭代器 // end2 容器2结束迭代器 // dest目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vTarget;<br><span class="hljs-comment">//取两个容器的和给目标容器开辟空间</span><br>vTarget.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>() + v2.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <br>        <span class="hljs-built_in">set_union</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="set_difference">5.6.3 set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器 // end1 容器1结束迭代器 // beg2容器2开始迭代器 // end2 容器2结束迭代器 // dest目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vTarget;<br><span class="hljs-comment">//取两个里面较大的值给目标容器开辟空间</span><br>vTarget.<span class="hljs-built_in">resize</span>( <span class="hljs-built_in">max</span>(v1.<span class="hljs-built_in">size</span>() , v2.<span class="hljs-built_in">size</span>()));<br><br><span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <br>        <span class="hljs-built_in">set_difference</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;<br>itEnd = <span class="hljs-built_in">set_difference</span>(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP核心编程</title>
    <link href="/2023/03/31/CPP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/03/31/CPP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="c核心编程">C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="内存分区模型">1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="程序运行前">1.1 程序运行前</h3><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p><strong>代码区：</strong></p><p>存放 CPU 执行的机器指令</p><p>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p><strong>全局区：</strong></p><p>全局变量和静态变量存放在此.</p><p>全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//全局常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//局部变量</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//打印地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;b &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="hljs-type">int</span>)&amp;g_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="hljs-type">int</span>)&amp;g_b &lt;&lt; endl;<br><br><span class="hljs-comment">//静态变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_b = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_b &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world1&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_b &lt;&lt; endl;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_b = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure><img src="/img/1545017602518.png" alt="1545017602518" /><figcaption aria-hidden="true">1545017602518</figcaption></figure><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量 和 字符串常量</li></ul><h3 id="程序运行后">1.2 程序运行后</h3><p><strong>栈区：</strong></p><p>由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> &amp;a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>堆区：</strong></p><p>由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br>cout &lt;&lt; *p &lt;&lt; endl;<br>  <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="new操作符">1.3 new操作符</h3><p>C++中利用==new==操作符在堆区开辟数据</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符==delete==</p><p>语法：<code>new 数据类型</code></p><p>利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-comment">//利用delete释放堆区数据</span><br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆区开辟数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>arr[i] = i + <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//释放数组 delete 后加 []</span><br><span class="hljs-keyword">delete</span>[] arr;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="引用">2 引用</h2><h3 id="引用的基本使用">2.1 引用的基本使用</h3><p><strong>作用： </strong>给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = a;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>b = <span class="hljs-number">100</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用注意事项">2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//int &amp;c; //错误，引用必须初始化</span><br><span class="hljs-type">int</span> &amp;c = a; <span class="hljs-comment">//一旦初始化后，就不可以更改</span><br>c = b; <span class="hljs-comment">//这是赋值操作，不是更改引用</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用做函数参数">2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//1. 值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-comment">//2. 地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap02</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = *a;<br>*a = *b;<br>*b = temp;<br>&#125;<br><br><span class="hljs-comment">//3. 引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap03</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-built_in">mySwap01</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">mySwap02</span>(&amp;a, &amp;b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">mySwap03</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="引用做函数返回值">2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//返回局部变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//局部变量</span><br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">//返回静态变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//不能返回局部变量的引用</span><br><span class="hljs-type">int</span>&amp; ref = <span class="hljs-built_in">test01</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br><br><span class="hljs-comment">//如果函数做左值，那么必须返回引用</span><br><span class="hljs-type">int</span>&amp; ref2 = <span class="hljs-built_in">test02</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br><span class="hljs-built_in">test02</span>() = <span class="hljs-number">1000</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用的本质">2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//发现是引用，转换为 int* const ref = &amp;a;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; ref)</span></span>&#123;<br>ref = <span class="hljs-number">100</span>; <span class="hljs-comment">// ref是引用，转换为*ref = 100</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <br>    <span class="hljs-comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span><br><span class="hljs-type">int</span>&amp; ref = a; <br>ref = <span class="hljs-number">20</span>; <span class="hljs-comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span><br>  <br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;<br>  <br><span class="hljs-built_in">func</span>(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="常量引用">2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//引用使用的场景，通常用来修饰形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; v)</span> </span>&#123;<br><span class="hljs-comment">//v += 10;</span><br>cout &lt;&lt; v &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span><br><span class="hljs-comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//ref = 100;  //加入const后不可以修改变量</span><br>cout &lt;&lt; ref &lt;&lt; endl;<br><br><span class="hljs-comment">//函数中利用常量引用防止误操作修改实参</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">showValue</span>(a);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数提高">3 函数提高</h2><h3 id="函数默认参数">3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code>返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span><br><span class="hljs-comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>) &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数占位参数">3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong><code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数占位参数 ，占位参数也可以有默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span>)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is func&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//占位参数必须填补</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载">3.3 函数重载</h3><h4 id="函数重载概述">3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong>或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong> 函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数重载需要函数都在同一个作用域下</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a ,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><br><span class="hljs-comment">//int func(double a, int b)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">func</span>();<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span> , <span class="hljs-number">10</span>);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数重载注意事项">3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数重载注意事项</span><br><span class="hljs-comment">//1、引用作为重载条件</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-comment">//2、函数重载碰到函数默认参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a); <span class="hljs-comment">//调用无const</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用有const</span><br><br><br><span class="hljs-comment">//func2(10); //碰到默认参数产生歧义，需要避免</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类和对象"><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...</p><p>车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...</p><p>具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h3 id="封装">4.1 封装</h3><h4 id="封装的意义">4.1.1 封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong><code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//圆周率</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><br><span class="hljs-comment">//1、封装的意义</span><br><span class="hljs-comment">//将属性和行为作为一个整体，用来表现生活中的事物</span><br><br><span class="hljs-comment">//封装一个圆类，求圆的周长</span><br><span class="hljs-comment">//class代表设计一个类，后面跟着的是类名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">//访问权限  公共的权限</span><br><br><span class="hljs-comment">//属性</span><br><span class="hljs-type">int</span> m_r;<span class="hljs-comment">//半径</span><br><br><span class="hljs-comment">//行为</span><br><span class="hljs-comment">//获取到圆的周长</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateZC</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//2 * pi  * r</span><br><span class="hljs-comment">//获取圆的周长</span><br><span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * m_r;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//通过圆类，创建圆的对象</span><br><span class="hljs-comment">// c1就是一个具体的圆</span><br>Circle c1;<br>c1.m_r = <span class="hljs-number">10</span>; <span class="hljs-comment">//给圆对象的半径 进行赋值操作</span><br><br><span class="hljs-comment">//2 * pi * 10 = = 62.8</span><br>cout &lt;&lt; <span class="hljs-string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="hljs-built_in">calculateZC</span>() &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>m_name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setID</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>m_id = id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showStudent</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string m_name;<br><span class="hljs-type">int</span> m_id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Student stu;<br>stu.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;德玛西亚&quot;</span>);<br>stu.<span class="hljs-built_in">setID</span>(<span class="hljs-number">250</span>);<br>stu.<span class="hljs-built_in">showStudent</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol type="1"><li>public 公共权限</li><li>protected 保护权限</li><li>private 私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//三种权限</span><br><span class="hljs-comment">//公共权限  public     类内可以访问  类外可以访问</span><br><span class="hljs-comment">//保护权限  protected  类内可以访问  类外不可以访问</span><br><span class="hljs-comment">//私有权限  private    类内可以访问  类外不可以访问</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-comment">//姓名  公共权限</span><br><span class="hljs-keyword">public</span>:<br>string m_Name;<br><br><span class="hljs-comment">//汽车  保护权限</span><br><span class="hljs-keyword">protected</span>:<br>string m_Car;<br><br><span class="hljs-comment">//银行卡密码  私有权限</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_Password;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_Name = <span class="hljs-string">&quot;张三&quot;</span>;<br>m_Car = <span class="hljs-string">&quot;拖拉机&quot;</span>;<br>m_Password = <span class="hljs-number">123456</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Person p;<br>p.m_Name = <span class="hljs-string">&quot;李四&quot;</span>;<br><span class="hljs-comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span><br><span class="hljs-comment">//p.m_Password = 123; //私有权限类外访问不到</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="struct和class区别">4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于<strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class 默认权限为私有</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span><br>&#123;<br><span class="hljs-type">int</span>  m_A; <span class="hljs-comment">//默认是私有权限</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C2</span><br>&#123;<br><span class="hljs-type">int</span> m_A;  <span class="hljs-comment">//默认是公共权限</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>C1 c1;<br>c1.m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误，访问权限是私有</span><br><br>C2 c2;<br>c2.m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//正确，访问权限是公共</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员属性设置为私有">4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//姓名设置可读可写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>m_Name = name;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Name;<br>&#125;<br><br><br><span class="hljs-comment">//获取年龄 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> m_Age;<br>&#125;<br><span class="hljs-comment">//设置年龄</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">150</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>m_Age = age;<br>&#125;<br><br><span class="hljs-comment">//情人设置为只写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLover</span><span class="hljs-params">(string lover)</span> </span>&#123;<br>m_Lover = lover;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>string m_Name; <span class="hljs-comment">//可读可写  姓名</span><br><br><span class="hljs-type">int</span> m_Age; <span class="hljs-comment">//只读  年龄</span><br><br>string m_Lover; <span class="hljs-comment">//只写  情人</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Person p;<br><span class="hljs-comment">//姓名设置</span><br>p.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//年龄设置</span><br>p.<span class="hljs-built_in">setAge</span>(<span class="hljs-number">50</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//情人设置</span><br>p.<span class="hljs-built_in">setLover</span>(<span class="hljs-string">&quot;苍井&quot;</span>);<br><span class="hljs-comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><figure><img src="/img/1545533548532.png" alt="1545533548532" /><figcaption aria-hidden="true">1545533548532</figcaption></figure><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><figure><img src="/img/1545533829184.png" alt="1545533829184" /><figcaption aria-hidden="true">1545533829184</figcaption></figure><h3 id="对象的初始化和清理">4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。</li></ul><h4 id="构造函数和析构函数">4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>一个对象或者变量没有初始状态，对其使用后果是未知，同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol type="1"><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol type="1"><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号 ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">Person</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数的分类及调用">4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><ol type="1"><li>按参数分为： 有参构造和无参构造</li><li>按类型分为： 普通构造和拷贝构造</li></ol><p>三种调用方式：</p><ol type="1"><li>括号法</li><li>显示法</li><li>隐式转换法</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//1、构造函数分类</span><br><span class="hljs-comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="hljs-comment">// 按照类型分类分为 普通构造和拷贝构造</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//无参（默认）构造函数</span><br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//有参构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>age = a;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>age = p.age;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//2、构造函数的调用</span><br><span class="hljs-comment">//调用无参构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>Person p; <span class="hljs-comment">//调用无参构造函数</span><br>&#125;<br><br><span class="hljs-comment">//调用有参的构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//2.1  括号法，常用</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="hljs-comment">//Person p2();</span><br><br><span class="hljs-comment">//2.2 显式法</span><br>Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>); <br>Person p3 = <span class="hljs-built_in">Person</span>(p2);<br><span class="hljs-comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><br><span class="hljs-comment">//2.3 隐式转换法</span><br>Person p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person p4 = Person(10); </span><br>Person p5 = p4; <span class="hljs-comment">// Person p5 = Person(p4); </span><br><br><span class="hljs-comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="hljs-comment">//Person p5(p4);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-comment">//test02();</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = age;<br>&#125;<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = p.mAge;<br>&#125;<br><span class="hljs-comment">//析构函数在释放内存之前调用</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person <span class="hljs-title">man</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">//p对象已经创建完毕</span><br><span class="hljs-function">Person <span class="hljs-title">newman</span><span class="hljs-params">(man)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span><br>Person newman2 = man; <span class="hljs-comment">//拷贝构造</span><br><br><span class="hljs-comment">//Person newman3;</span><br><span class="hljs-comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span><br>&#125;<br><br><span class="hljs-comment">//2. 值传递的方式给函数参数传值</span><br><span class="hljs-comment">//相当于Person p1 = p;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Person p1)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>Person p; <span class="hljs-comment">//无参构造函数</span><br><span class="hljs-built_in">doWork</span>(p);<br>&#125;<br><br><span class="hljs-comment">//3. 以值方式返回局部对象</span><br><span class="hljs-function">Person <span class="hljs-title">doWork2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person p1;<br>cout &lt;&lt; (<span class="hljs-type">int</span> *)&amp;p1 &lt;&lt; endl;<br><span class="hljs-keyword">return</span> p1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person p = <span class="hljs-built_in">doWork2</span>();<br>cout &lt;&lt; (<span class="hljs-type">int</span> *)&amp;p &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><span class="hljs-comment">//test02();</span><br><span class="hljs-built_in">test03</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数调用规则">4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//无参（默认）构造函数</span><br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//有参构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>age = a;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>age = p.age;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span><br>Person p1; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//用户提供的有参</span><br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>; <span class="hljs-comment">//此时如果用户没有提供拷贝构造，编译器会提供</span><br><br><span class="hljs-comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span><br>Person p4; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//此时如果用户自己没有提供有参，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(p5)</span></span>; <span class="hljs-comment">//用户自己提供拷贝构造</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="深拷贝与浅拷贝">4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//无参（默认）构造函数</span><br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//有参构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age ,<span class="hljs-type">int</span> height) &#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br><br>m_age = age;<br>m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(height);<br><br>&#125;<br><span class="hljs-comment">//拷贝构造函数  </span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br>m_age = p.m_age;<br>m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_height);<br><br>&#125;<br><br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (m_height != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_height;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_age;<br><span class="hljs-type">int</span>* m_height;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>, <span class="hljs-number">180</span>)</span></span>;<br><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="初始化列表">4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">////传统方式初始化</span><br><span class="hljs-comment">//Person(int a, int b, int c) &#123;</span><br><span class="hljs-comment">//m_A = a;</span><br><span class="hljs-comment">//m_B = b;</span><br><span class="hljs-comment">//m_C = c;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//初始化列表方式初始化</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) :<span class="hljs-built_in">m_A</span>(a), <span class="hljs-built_in">m_B</span>(b), <span class="hljs-built_in">m_C</span>(c) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPerson</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>p.<span class="hljs-built_in">PrintPerson</span>();<br><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类对象作为类成员">4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    A a；<br>&#125;<br></code></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Phone</span>(string name)<br>&#123;<br>m_PhoneName = name;<br>cout &lt;&lt; <span class="hljs-string">&quot;Phone构造&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Phone</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Phone析构&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>string m_PhoneName;<br><br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//初始化列表可以告诉编译器调用哪一个构造函数</span><br><span class="hljs-built_in">Person</span>(string name, string pName) :<span class="hljs-built_in">m_Name</span>(name), <span class="hljs-built_in">m_Phone</span>(pName)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person构造&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Person</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person析构&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; m_Name &lt;&lt; <span class="hljs-string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="hljs-string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;<br>&#125;<br><br>string m_Name;<br>Phone m_Phone;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span><br><span class="hljs-comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span><br><span class="hljs-comment">//析构顺序与构造相反</span><br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span> , <span class="hljs-string">&quot;苹果X&quot;</span>)</span></span>;<br>p.<span class="hljs-built_in">playGame</span>();<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态成员">4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br><br><span class="hljs-comment">//静态成员变量特点：</span><br><span class="hljs-comment">//1 在编译阶段分配内存</span><br><span class="hljs-comment">//2 类内声明，类外初始化</span><br><span class="hljs-comment">//3 所有对象共享同一份数据</span><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//静态成员变量也是有访问权限的</span><br>&#125;;<br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> Person::m_B = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//静态成员变量两种访问方式</span><br><br><span class="hljs-comment">//1、通过对象</span><br>Person p1;<br>p1.m_A = <span class="hljs-number">100</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;<br><br>Person p2;<br>p2.m_A = <span class="hljs-number">200</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="hljs-comment">//共享同一份数据</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;<br><br><span class="hljs-comment">//2、通过类名</span><br>cout &lt;&lt; <span class="hljs-string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;<br><br><br><span class="hljs-comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//静态成员函数特点：</span><br><span class="hljs-comment">//1 程序共享一个函数</span><br><span class="hljs-comment">//2 静态成员函数只能访问静态成员变量</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>m_A = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//m_B = 100; //错误，不可以访问非静态成员变量</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br><span class="hljs-type">int</span> m_B; <span class="hljs-comment">// </span><br><span class="hljs-keyword">private</span>:<br><br><span class="hljs-comment">//静态成员函数也是有访问权限的</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func2调用&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">10</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//静态成员变量两种访问方式</span><br><br><span class="hljs-comment">//1、通过对象</span><br>Person p1;<br>p1.<span class="hljs-built_in">func</span>();<br><br><span class="hljs-comment">//2、通过类名</span><br>Person::<span class="hljs-built_in">func</span>();<br><br><br><span class="hljs-comment">//Person::func2(); //私有权限访问不到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c对象模型和this指针">4.3 C++对象模型和this指针</h3><h4 id="成员变量和成员函数分开存储">4.3.1成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>mA = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//非静态成员变量占对象空间</span><br><span class="hljs-type">int</span> mA;<br><span class="hljs-comment">//静态成员变量不占对象空间</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> mB; <br><span class="hljs-comment">//函数也不占对象空间，所有函数共享一个函数实例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//静态成员函数也不占对象空间</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Person) &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="this指针概念">4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-comment">//1、当形参和成员变量同名时，可用this指针来区分</span><br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><br><span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddPerson</span><span class="hljs-params">(Person p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;age += p.age;<br><span class="hljs-comment">//返回对象本身</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;<br><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>p2.<span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1);<br>cout &lt;&lt; <span class="hljs-string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="空指针访问成员函数">4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//空指针访问成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowClassName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>cout &lt;&lt; mAge &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person * p = <span class="hljs-literal">NULL</span>;<br>p-&gt;<span class="hljs-built_in">ShowClassName</span>(); <span class="hljs-comment">//空指针，可以调用成员函数</span><br>p-&gt;<span class="hljs-built_in">ShowPerson</span>();  <span class="hljs-comment">//但是如果成员函数中用到了this指针，就不可以了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="const修饰成员函数">4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>m_A = <span class="hljs-number">0</span>;<br>m_B = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span><br><span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">//const Type* const pointer;</span><br><span class="hljs-comment">//this = NULL; //不能修改指针的指向 Person* const this;</span><br><span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span><br><br><span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br><span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">//mA = 10000;</span><br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span><br>&#125;;<br><br><br><span class="hljs-comment">//const修饰对象  常对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">const</span> Person person; <span class="hljs-comment">//常量对象  </span><br>cout &lt;&lt; person.m_A &lt;&lt; endl;<br><span class="hljs-comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span><br>person.m_B = <span class="hljs-number">100</span>; <span class="hljs-comment">//但是常对象可以修改mutable修饰成员变量</span><br><br><span class="hljs-comment">//常对象访问成员函数</span><br>person.<span class="hljs-built_in">MyFunc</span>(); <span class="hljs-comment">//常对象不能调用const的函数</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="友元">4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为 ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="全局函数做友元">4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Building</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span>:<br>string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><br><span class="hljs-keyword">private</span>:<br>string m_BedRoom; <span class="hljs-comment">//卧室</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Building b;<br><span class="hljs-built_in">goodGay</span>(&amp;b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类做友元">4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">goodGay</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>Building *building;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Building</span>();<br><br><span class="hljs-keyword">public</span>:<br>string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>string m_BedRoom;<span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>goodGay::<span class="hljs-built_in">goodGay</span>()<br>&#123;<br>building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>goodGay gg;<br>gg.<span class="hljs-built_in">visit</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员函数做友元">4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">goodGay</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>; <br><br><span class="hljs-keyword">private</span>:<br>Building *building;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Building</span>();<br><br><span class="hljs-keyword">public</span>:<br>string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>string m_BedRoom;<span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>goodGay::<span class="hljs-built_in">goodGay</span>()<br>&#123;<br>building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br><span class="hljs-comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>goodGay  gg;<br>gg.<span class="hljs-built_in">visit</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运算符重载">4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="加号运算符重载">4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;&#125;;<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_A = a;<br><span class="hljs-keyword">this</span>-&gt;m_B = b;<br>&#125;<br><span class="hljs-comment">//成员函数实现 + 号运算符重载</span><br>Person <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>Person temp;<br>temp.m_A = <span class="hljs-keyword">this</span>-&gt;m_A + p.m_A;<br>temp.m_B = <span class="hljs-keyword">this</span>-&gt;m_B + p.m_B;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//全局函数实现 + 号运算符重载</span><br><span class="hljs-comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="hljs-comment">//Person temp(0, 0);</span><br><span class="hljs-comment">//temp.m_A = p1.m_A + p2.m_A;</span><br><span class="hljs-comment">//temp.m_B = p1.m_B + p2.m_B;</span><br><span class="hljs-comment">//return temp;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//运算符重载 可以发生函数重载 </span><br>Person <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Person&amp; p2, <span class="hljs-type">int</span> val)  <br>&#123;<br>Person temp;<br>temp.m_A = p2.m_A + val;<br>temp.m_B = p2.m_B + val;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//成员函数方式</span><br>Person p3 = p2 + p1;  <span class="hljs-comment">//相当于 p2.operaor+(p1)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;<br><br><br>Person p4 = p3 + <span class="hljs-number">10</span>; <span class="hljs-comment">//相当于 operator+(p3,10)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="左移运算符重载">4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_A = a;<br><span class="hljs-keyword">this</span>-&gt;m_B = b;<br>&#125;<br><br><span class="hljs-comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br><span class="hljs-comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//全局函数实现左移重载</span><br><span class="hljs-comment">//ostream对象只能有一个</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;<br>out &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; p.m_B;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//链式编程</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="递增运算符重载">4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInteger</span> &#123;<br><br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyInteger</span>() &#123;<br>m_Num = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//前置++</span><br>MyInteger&amp; <span class="hljs-keyword">operator</span>++() &#123;<br><span class="hljs-comment">//先++</span><br>m_Num++;<br><span class="hljs-comment">//再返回</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//后置++</span><br>MyInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//先返回</span><br>MyInteger temp = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span><br>m_Num++;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_Num;<br>&#125;;<br><br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;<br>out &lt;&lt; myint.m_Num;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><br><span class="hljs-comment">//前置++ 先++ 再返回</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>MyInteger myInt;<br>cout &lt;&lt; ++myInt &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//后置++ 先返回 再++</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>MyInteger myInt;<br>cout &lt;&lt; myInt++ &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-comment">//test02();</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="赋值运算符重载">4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol type="1"><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-comment">//将年龄数据开辟到堆区</span><br>m_Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(age);<br>&#125;<br><br><span class="hljs-comment">//重载赋值运算符 </span><br>Person&amp; <span class="hljs-keyword">operator</span>=(Person &amp;p)<br>&#123;<br><span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_Age;<br>m_Age = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//编译器提供的代码是浅拷贝</span><br><span class="hljs-comment">//m_Age = p.m_Age;</span><br><br><span class="hljs-comment">//提供深拷贝 解决浅拷贝的问题</span><br>m_Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_Age);<br><br><span class="hljs-comment">//返回自身</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br>~<span class="hljs-built_in">Person</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_Age;<br>m_Age = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//年龄的指针</span><br><span class="hljs-type">int</span> *m_Age;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br><br>p3 = p2 = p1; <span class="hljs-comment">//赋值操作</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-comment">//int a = 10;</span><br><span class="hljs-comment">//int b = 20;</span><br><span class="hljs-comment">//int c = 30;</span><br><br><span class="hljs-comment">//c = b = a;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关系运算符重载">4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Person &amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(Person &amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//int a = 0;</span><br><span class="hljs-comment">//int b = 0;</span><br><br><span class="hljs-function">Person <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><br><span class="hljs-keyword">if</span> (a == b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">if</span> (a != b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数调用运算符重载">4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 () 也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string text)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; text &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//重载的（）操作符 也称为仿函数</span><br>MyPrint myFunc;<br><span class="hljs-built_in">myFunc</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 + v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyAdd add;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br><span class="hljs-comment">//匿名对象调用  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="hljs-built_in">MyAdd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承">4.6 继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><figure><img src="/img/1544861202252.png" alt="1544861202252" /><figcaption aria-hidden="true">1544861202252</figcaption></figure><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="继承的基本语法">4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Java页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Java ja;<br>ja.<span class="hljs-built_in">header</span>();<br>ja.<span class="hljs-built_in">footer</span>();<br>ja.<span class="hljs-built_in">left</span>();<br>ja.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//Python页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Python py;<br>py.<span class="hljs-built_in">header</span>();<br>py.<span class="hljs-built_in">footer</span>();<br>py.<span class="hljs-built_in">left</span>();<br>py.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//C++页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>CPP cp;<br>cp.<span class="hljs-built_in">header</span>();<br>cp.<span class="hljs-built_in">footer</span>();<br>cp.<span class="hljs-built_in">left</span>();<br>cp.<span class="hljs-built_in">content</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//公共页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Java页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Java ja;<br>ja.<span class="hljs-built_in">header</span>();<br>ja.<span class="hljs-built_in">footer</span>();<br>ja.<span class="hljs-built_in">left</span>();<br>ja.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//Python页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Python py;<br>py.<span class="hljs-built_in">header</span>();<br>py.<span class="hljs-built_in">footer</span>();<br>py.<span class="hljs-built_in">left</span>();<br>py.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//C++页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>CPP cp;<br>cp.<span class="hljs-built_in">header</span>();<br>cp.<span class="hljs-built_in">footer</span>();<br>cp.<span class="hljs-built_in">left</span>();<br>cp.<span class="hljs-built_in">content</span>();<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="继承方式">4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><figure><img src="/img/clip_image003.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-comment">//公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_A; <span class="hljs-comment">//可访问 public权限</span><br>m_B; <span class="hljs-comment">//可访问 protected权限</span><br><span class="hljs-comment">//m_C; //不可访问</span><br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son1 s1;<br>s1.m_A; <span class="hljs-comment">//其他类只能访问到公共权限</span><br>&#125;<br><br><span class="hljs-comment">//保护继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_C;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>:<span class="hljs-keyword">protected</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_A; <span class="hljs-comment">//可访问 protected权限</span><br>m_B; <span class="hljs-comment">//可访问 protected权限</span><br><span class="hljs-comment">//m_C; //不可访问</span><br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myClass2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son2 s;<br><span class="hljs-comment">//s.m_A; //不可访问</span><br>&#125;<br><br><span class="hljs-comment">//私有继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base3</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_C;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son3</span>:<span class="hljs-keyword">private</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_A; <span class="hljs-comment">//可访问 private权限</span><br>m_B; <span class="hljs-comment">//可访问 private权限</span><br><span class="hljs-comment">//m_C; //不可访问</span><br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandSon3</span> :<span class="hljs-keyword">public</span> Son3<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span><br><span class="hljs-comment">//m_A;</span><br><span class="hljs-comment">//m_B;</span><br><span class="hljs-comment">//m_C;</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="继承中的对象模型">4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_C; <span class="hljs-comment">//私有成员只是被隐藏了，但是还是会继承下去</span><br>&#125;;<br><br><span class="hljs-comment">//公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Son) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用工具查看：</p><figure><img src="/img/1545881904150.png" alt="1545881904150" /><figcaption aria-hidden="true">1545881904150</figcaption></figure><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名</p><p>效果如下图：</p><figure><img src="/img/1545882158050.png" alt="1545882158050" /><figcaption aria-hidden="true">1545882158050</figcaption></figure><blockquote><p>结论：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="继承中构造和析构顺序">4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Base</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Son</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span><br>Son s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="继承同名成员处理方式">4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()<br>&#123;<br>m_A = <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>m_A = <span class="hljs-number">200</span>;<br>&#125;<br><br><span class="hljs-comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="hljs-comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son s;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br>s.<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol type="1"><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="继承同名静态成员处理方式">4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::m_A = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Son::m_A = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">//同名成员属性</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//通过对象访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br><span class="hljs-comment">//通过类名访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//同名成员函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//通过对象访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>Son s;<br>s.<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>Son::<span class="hljs-built_in">func</span>();<br>Son::Base::<span class="hljs-built_in">func</span>();<br><span class="hljs-comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span><br>Son::Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象和 通过类名）</p></blockquote><h4 id="多继承语法">4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base1</span>()<br>&#123;<br>m_A = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base2</span>()<br>&#123;<br>m_A = <span class="hljs-number">200</span>;  <span class="hljs-comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span><br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base1 <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>m_C = <span class="hljs-number">300</span>;<br>m_D = <span class="hljs-number">400</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_C;<br><span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><br><span class="hljs-comment">//多继承容易产生成员同名的情况</span><br><span class="hljs-comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son s;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="菱形继承">4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>两个派生类继承同一个基类</p><p>又有某个类同时继承者两个派生类</p><p>这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><figure><img src="/img/clip_image002.jpg" alt="IMG_256" /><figcaption aria-hidden="true">IMG_256</figcaption></figure><p><strong>菱形继承问题：</strong></p><ol type="1"><li>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</li><li>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//继承前加virtual关键字后，变为虚继承</span><br><span class="hljs-comment">//此时公共的父类Animal称为虚基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuo</span>   : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepTuo</span> : <span class="hljs-keyword">public</span> Sheep, <span class="hljs-keyword">public</span> Tuo &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SheepTuo st;<br>st.Sheep::m_Age = <span class="hljs-number">100</span>;<br>st.Tuo::m_Age = <span class="hljs-number">200</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="多态">4.7 多态</h3><h4 id="多态的基本概念">4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//Speak函数就是虚函数</span><br><span class="hljs-comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;动物在说话&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> :<span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> :<span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-comment">//我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="hljs-comment">//如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="hljs-comment">//如果函数地址在运行阶段才能确定，就是动态联编</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSpeak</span><span class="hljs-params">(Animal &amp; animal)</span></span><br><span class="hljs-function"></span>&#123;<br>animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//多态满足条件： </span><br><span class="hljs-comment">//1、有继承关系</span><br><span class="hljs-comment">//2、子类重写父类中的虚函数</span><br><span class="hljs-comment">//多态使用：</span><br><span class="hljs-comment">//父类指针或引用指向子类对象</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Cat cat;<br><span class="hljs-built_in">DoSpeak</span>(cat);<br><br><br>Dog dog;<br><span class="hljs-built_in">DoSpeak</span>(dog);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><h4 id="多态案例一-计算器类">4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//普通实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> m_Num1 - m_Num2;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> m_Num1 * m_Num2;<br>&#125;<br><span class="hljs-comment">//如果要提供新的运算，需要修改源码</span><br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_Num1;<br><span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//普通实现测试</span><br>Calculator c;<br>c.m_Num1 = <span class="hljs-number">10</span>;<br>c.m_Num2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;*&quot;</span>) &lt;&lt; endl;<br>&#125;<br><br><br><br><span class="hljs-comment">//多态实现</span><br><span class="hljs-comment">//抽象计算器类</span><br><span class="hljs-comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span><br>&#123;<br><span class="hljs-keyword">public</span> :<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> m_Num1;<br><span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-comment">//加法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//减法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Num1 - m_Num2;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//乘法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Num1 * m_Num2;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建加法计算器</span><br>AbstractCalculator *abc = <span class="hljs-keyword">new</span> AddCalculator;<br>abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;  <span class="hljs-comment">//用完了记得销毁</span><br><br><span class="hljs-comment">//创建减法计算器</span><br>abc = <span class="hljs-keyword">new</span> SubCalculator;<br>abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;  <br><br><span class="hljs-comment">//创建乘法计算器</span><br>abc = <span class="hljs-keyword">new</span> MulCalculator;<br>abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="纯虚函数和抽象类">4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//纯虚函数</span><br><span class="hljs-comment">//类中只要有一个纯虚函数就称为抽象类</span><br><span class="hljs-comment">//抽象类无法实例化对象</span><br><span class="hljs-comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base * base = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//base = new Base; // 错误，抽象类无法实例化对象</span><br>base = <span class="hljs-keyword">new</span> Son;<br>base-&gt;<span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">delete</span> base;<span class="hljs-comment">//记得销毁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态案例二-制作饮品">4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><figure><img src="/img/1545985945198.png" alt="1545985945198" /><figcaption aria-hidden="true">1545985945198</figcaption></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//抽象制作饮品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDrinking</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//烧水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//加入辅料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//规定流程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeDrink</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">Boil</span>();<br><span class="hljs-built_in">Brew</span>();<br><span class="hljs-built_in">PourInCup</span>();<br><span class="hljs-built_in">PutSomething</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//制作咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> : <span class="hljs-keyword">public</span> AbstractDrinking &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//烧水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//加入辅料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//制作茶水</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> : <span class="hljs-keyword">public</span> AbstractDrinking &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//烧水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//加入辅料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//业务函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">(AbstractDrinking* drink)</span> </span>&#123;<br>drink-&gt;<span class="hljs-built_in">MakeDrink</span>();<br><span class="hljs-keyword">delete</span> drink;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">DoWork</span>(<span class="hljs-keyword">new</span> Coffee);<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">DoWork</span>(<span class="hljs-keyword">new</span> Tea);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="虚析构和纯虚析构">4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code>virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Animal</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="hljs-comment">//virtual ~Animal()</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br><br>Animal::~<span class="hljs-built_in">Animal</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Cat</span>(string name)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;<br>m_Name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *m_Name &lt;&lt;  <span class="hljs-string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Cat</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">delete</span> m_Name;<br>m_Name = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br>string *m_Name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>animal-&gt;<span class="hljs-built_in">Speak</span>();<br><br><span class="hljs-comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="hljs-comment">//怎么解决？给基类增加一个虚析构函数</span><br><span class="hljs-comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span><br><span class="hljs-keyword">delete</span> animal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol type="1"><li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li><li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li><li>拥有纯虚析构函数的类也属于抽象类</li></ol><h4 id="多态案例三-电脑组装">4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象CPU类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPU</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//抽象的计算函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//抽象显卡类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoCard</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//抽象的显示函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//抽象内存条类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//抽象的存储函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//电脑类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)<br>&#123;<br>m_cpu = cpu;<br>m_vc = vc;<br>m_mem = mem;<br>&#125;<br><br><span class="hljs-comment">//提供工作的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//让零件工作起来，调用接口</span><br>m_cpu-&gt;<span class="hljs-built_in">calculate</span>();<br><br>m_vc-&gt;<span class="hljs-built_in">display</span>();<br><br>m_mem-&gt;<span class="hljs-built_in">storage</span>();<br>&#125;<br><br><span class="hljs-comment">//提供析构函数 释放3个电脑零件</span><br>~<span class="hljs-built_in">Computer</span>()<br>&#123;<br><br><span class="hljs-comment">//释放CPU零件</span><br><span class="hljs-keyword">if</span> (m_cpu != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_cpu;<br>m_cpu = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//释放显卡零件</span><br><span class="hljs-keyword">if</span> (m_vc != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_vc;<br>m_vc = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//释放内存条零件</span><br><span class="hljs-keyword">if</span> (m_mem != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_mem;<br>m_mem = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><br>CPU * m_cpu; <span class="hljs-comment">//CPU的零件指针</span><br>VideoCard * m_vc; <span class="hljs-comment">//显卡零件指针</span><br>Memory * m_mem; <span class="hljs-comment">//内存条零件指针</span><br>&#125;;<br><br><span class="hljs-comment">//具体厂商</span><br><span class="hljs-comment">//Intel厂商</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCPU</span> :<span class="hljs-keyword">public</span> CPU<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelVideoCard</span> :<span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMemory</span> :<span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//Lenovo厂商</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoCPU</span> :<span class="hljs-keyword">public</span> CPU<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoVideoCard</span> :<span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoMemory</span> :<span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//第一台电脑零件</span><br>CPU * intelCpu = <span class="hljs-keyword">new</span> IntelCPU;<br>VideoCard * intelCard = <span class="hljs-keyword">new</span> IntelVideoCard;<br>Memory * intelMem = <span class="hljs-keyword">new</span> IntelMemory;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//创建第一台电脑</span><br>Computer * computer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(intelCpu, intelCard, intelMem);<br>computer1-&gt;<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">delete</span> computer1;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//第二台电脑组装</span><br>Computer * computer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> LenovoVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;<br>computer2-&gt;<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">delete</span> computer2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//第三台电脑组装</span><br>Computer * computer3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> IntelVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;<br>computer3-&gt;<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">delete</span> computer3;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件操作">5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol type="1"><li><strong>文本文件</strong> -文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol type="1"><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="文本文件">5.1文本文件</h3><h4 id="写文件">5.1.1写文件</h4><p>写文件步骤如下：</p><ol type="1"><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open("文件路径",打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; "写入的数据";</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr class="header"><th>打开方式</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>ios::in</td><td>为读文件而打开文件</td></tr><tr class="even"><td>ios::out</td><td>为写文件而打开文件</td></tr><tr class="odd"><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr class="even"><td>ios::app</td><td>追加方式写文件</td></tr><tr class="odd"><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr class="even"><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件<code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream ofs;<br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);<br><br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;性别：男&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;年龄：18&quot;</span> &lt;&lt; endl;<br><br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="读文件">5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol type="1"><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open("文件路径",打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ifstream ifs;<br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::in);<br><br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//第一种方式</span><br><span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">//while (ifs &gt;&gt; buf)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第二种</span><br><span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">//while (ifs.getline(buf,sizeof(buf)))</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第三种</span><br><span class="hljs-comment">//string buf;</span><br><span class="hljs-comment">//while (getline(ifs, buf))</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF)<br>&#123;<br>cout &lt;&lt; c;<br>&#125;<br><br>ifs.<span class="hljs-built_in">close</span>();<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h3 id="二进制文件">5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="写文件-1">5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//二进制文件  写文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1、包含头文件</span><br><br><span class="hljs-comment">//2、创建输出流对象</span><br><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br><br><span class="hljs-comment">//3、打开文件</span><br><span class="hljs-comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><br>Person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>  , <span class="hljs-number">18</span>&#125;;<br><br><span class="hljs-comment">//4、写文件</span><br>ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br><span class="hljs-comment">//5、关闭文件</span><br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="读文件-1">5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Person p;<br>ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP基本语法</title>
    <link href="/2023/03/31/CPP%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/03/31/CPP%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="c初识">1 C++初识</h2><h3 id="第一个c程序">1.1 第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p><ul><li>创建项目</li><li>创建文件</li><li>编写代码</li><li>运行程序</li></ul><h4 id="创建项目">1.1.1 创建项目</h4><pre><code class="hljs">Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</code></pre><figure><img src="/img/1541383178746.png" alt="1541383178746" /><figcaption aria-hidden="true">1541383178746</figcaption></figure><figure><img src="/img/1541384366413.png" alt="1541384366413" /><figcaption aria-hidden="true">1541384366413</figcaption></figure><h4 id="创建文件">1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p><figure><img src="/img/1541383817248.png" alt="1541383817248" /><figcaption aria-hidden="true">1541383817248</figcaption></figure><p>给C++文件起个名称，然后点击添加即可。</p><figure><img src="/img/1541384140042.png" alt="1541384140042" /><figcaption aria-hidden="true">1541384140042</figcaption></figure><h4 id="编写代码">1.1.3 编写代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Hello world&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行程序">1.1.4 运行程序</h4><figure><img src="/img/1541384818688.png" alt="1541384818688" /><figcaption aria-hidden="true">1541384818688</figcaption></figure><h3 id="注释">1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p><p><strong>两种格式</strong></p><ol type="1"><li><strong>单行注释</strong>：<code>// 描述信息</code><ul><li>通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==</li></ul></li><li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul><li>通常放在一段代码的上方，==对该段代码做整体说明==</li></ul></li></ol><blockquote><p>提示：编译器在编译代码时，会忽略注释的内容</p></blockquote><h3 id="变量">1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p><p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//变量的定义</span><br><span class="hljs-comment">//语法：数据类型  变量名 = 初始值</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p></blockquote><h3 id="常量">1.4 常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p><p>C++定义常量两种方式</p><ol type="1"><li><p><strong>#define</strong> 宏常量：<code>#define 常量名 常量值</code></p><ul><li>==通常在文件上方定义==，表示一个常量</li></ul></li><li><p><strong>const</strong>修饰的变量<code>const 数据类型 常量名 = 常量值</code></p><ul><li>==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改</li></ul></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//1、宏常量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> day 7</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="hljs-string">&quot; 天&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//day = 8;  //报错，宏常量不可以修改</span><br><br><span class="hljs-comment">//2、const修饰变量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> month = <span class="hljs-number">12</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="hljs-string">&quot; 个月份&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//month = 24; //报错，常量是不可以修改的</span><br><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键字">1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p><ul><li><strong>在定义变量或者常量时候，不要用关键字</strong></li></ul><p>C++关键字如下：</p><table><thead><tr class="header"><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr class="odd"><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr class="even"><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr class="odd"><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr class="even"><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr class="odd"><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr class="even"><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr class="odd"><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr class="even"><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr class="odd"><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr class="even"><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr class="odd"><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr class="even"><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p><h3 id="标识符命名规则">1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><blockquote><p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p></blockquote><h2 id="数据类型">2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p><h3 id="整型">2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是==整数类型==的数据</p><p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p><table><thead><tr class="header"><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th>取值范围</th></tr></thead><tbody><tr class="odd"><td>short(短整型)</td><td>2字节</td><td>(-2^15 ~ 2^15-1)</td></tr><tr class="even"><td>int(整型)</td><td>4字节</td><td>(-2^31 ~ 2^31-1)</td></tr><tr class="odd"><td>long(长整形)</td><td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td><td>(-2^31 ~ 2^31-1)</td></tr><tr class="even"><td>long long(长长整形)</td><td>8字节</td><td>(-2^63 ~ 2^63-1)</td></tr></tbody></table><h3 id="sizeof关键字">2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以==统计数据类型所占内存大小==</p><p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>整型结论</strong>：==short &lt; int &lt;= long &lt;= longlong==</p></blockquote><h3 id="实型浮点型">2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于==表示小数==</p><p>浮点型变量分为两种：</p><ol type="1"><li>单精度float</li><li>双精度double</li></ol><p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p><table><thead><tr class="header"><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>有效数字范围</strong></th></tr></thead><tbody><tr class="odd"><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr class="even"><td>double</td><td>8字节</td><td>15～16位有效数字</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">float</span> f1 = <span class="hljs-number">3.14f</span>;<br><span class="hljs-type">double</span> d1 = <span class="hljs-number">3.14</span>;<br><br>cout &lt;&lt; f1 &lt;&lt; endl;<br>cout &lt;&lt; d1&lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(f1) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(d1) &lt;&lt; endl;<br><br><span class="hljs-comment">//科学计数法</span><br><span class="hljs-type">float</span> f2 = <span class="hljs-number">3e2</span>; <span class="hljs-comment">// 3 * 10 ^ 2 </span><br>cout &lt;&lt; <span class="hljs-string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;<br><br><span class="hljs-type">float</span> f3 = <span class="hljs-number">3e-2</span>;  <span class="hljs-comment">// 3 * 0.1 ^ 2</span><br>cout &lt;&lt; <span class="hljs-string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符型">2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p><p><strong>语法：</strong><code>char ch = 'a';</code></p><blockquote><p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p></blockquote><blockquote><p>注意2：单引号内只能有一个字符，不可以是字符串</p></blockquote><ul><li>C和C++中字符型变量只占用==1个字节==。</li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>;<br>cout &lt;&lt; ch &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span><br><span class="hljs-comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span><br><br>cout &lt;&lt; (<span class="hljs-type">int</span>)ch &lt;&lt; endl;  <span class="hljs-comment">//查看字符a对应的ASCII码</span><br>ch = <span class="hljs-number">97</span>; <span class="hljs-comment">//可以直接用ASCII给字符型变量赋值</span><br>cout &lt;&lt; ch &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ASCII码表格：</p><table><thead><tr class="header"><th><strong>ASCII</strong>值</th><th><strong>控制字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th></tr></thead><tbody><tr class="odd"><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr class="even"><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr class="odd"><td>2</td><td>STX</td><td>34</td><td>"</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr class="even"><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr class="odd"><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr class="even"><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr class="odd"><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr class="even"><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr class="odd"><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr class="even"><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr class="odd"><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr class="even"><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr class="odd"><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr class="even"><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr class="odd"><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr class="even"><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr class="odd"><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr class="even"><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr class="odd"><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr class="even"><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr class="odd"><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr class="even"><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr class="odd"><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr class="even"><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr class="odd"><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr class="even"><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr class="odd"><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr class="even"><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr class="odd"><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td>|</td></tr><tr class="even"><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr class="odd"><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>`</td></tr><tr class="even"><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><p>ASCII 码大致由以下<strong>两部分组</strong>成：</p><ul><li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong>分配给了控制字符，用于控制像打印机等一些外围设备。</li><li>ASCII 打印字符：数字 <strong>32-126</strong>分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li></ul><h3 id="转义字符">2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些==不能显示出来的ASCII字符==</p><p>现阶段我们常用的转义字符有：<code>\n  \\  \t</code></p><table><thead><tr class="header"><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII</strong>码值（十进制）</th></tr></thead><tbody><tr class="odd"><td></td><td>警报</td><td>007</td></tr><tr class="even"><td> 退格(BS) ，将当前位置移到前一列</td><td>008</td><td></td></tr><tr class="odd"><td> 换页(FF)，将当前位置移到下页开头</td><td>012</td><td></td></tr><tr class="even"><td>***</td><td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td><td><strong>010</strong></td></tr><tr class="odd"><td> 回车(CR) ，将当前位置移到本行开头</td><td>013</td><td></td></tr><tr class="even"><td>**</td><td><strong>水平制表(HT) （跳到下一个TAB位置）</strong></td><td><strong>009</strong></td></tr><tr class="odd"><td> 垂直制表(VT)</td><td>011</td><td></td></tr><tr class="even"><td><strong>\\</strong></td><td><strong>代表一个反斜线字符""</strong></td><td><strong>092</strong></td></tr><tr class="odd"><td>'</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr class="even"><td>"</td><td>代表一个双引号字符</td><td>034</td></tr><tr class="odd"><td>?</td><td>代表一个问号</td><td>063</td></tr><tr class="even"><td>\0</td><td>数字0</td><td>000</td></tr><tr class="odd"><td></td><td>8进制转义字符，d范围0~7</td><td>3位8进制</td></tr><tr class="even"><td></td><td>16进制转义字符，h范围0<sub>9，a</sub>f，A~F</td><td>3位16进制</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;\\&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;\tHello&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串型">2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p><p><strong>两种风格</strong></p><ol type="1"><li><p><strong>C风格字符串</strong>：<code>char 变量名[] = "字符串值"</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello world&quot;</span>;<br>cout &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>注意：C风格的字符串要用双引号括起来</p></blockquote><ol type="1"><li><p><strong>C++风格字符串</strong>：<code>string  变量名 = "字符串值"</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>string str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>cout &lt;&lt; str &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==</p></blockquote><h3 id="布尔类型-bool">2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值</p><p>bool类型只有两个值：</p><ul><li>true --- 真（本质是1）</li><li>false --- 假（本质是0）</li></ul><p><strong>bool类型占==1个字节==大小</strong></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; flag &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>flag = <span class="hljs-literal">false</span>;<br>cout &lt;&lt; flag &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) &lt;&lt; endl; <span class="hljs-comment">//1</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据的输入">2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p><p><strong>关键字：</strong>cin</p><p><strong>语法：</strong> <code>cin &gt;&gt; 变量</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-comment">//整型输入</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; a;<br>cout &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">//浮点型输入</span><br><span class="hljs-type">double</span> d = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; d;<br>cout &lt;&lt; d &lt;&lt; endl;<br><br><span class="hljs-comment">//字符型输入</span><br><span class="hljs-type">char</span> ch = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; ch;<br>cout &lt;&lt; ch &lt;&lt; endl;<br><br><span class="hljs-comment">//字符串型输入</span><br>string str;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; str;<br>cout &lt;&lt; str &lt;&lt; endl;<br><br><span class="hljs-comment">//布尔类型输入</span><br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; flag;<br>cout &lt;&lt; flag &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运算符">3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p><p>本章我们主要讲解以下几类运算符：</p><table><thead><tr class="header"><th><strong>运算符类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr class="odd"><td>算术运算符</td><td>用于处理四则运算</td></tr><tr class="even"><td>赋值运算符</td><td>用于将表达式的值赋给变量</td></tr><tr class="odd"><td>比较运算符</td><td>用于表达式的比较，并返回一个真值或假值</td></tr><tr class="even"><td>逻辑运算符</td><td>用于根据表达式的值返回真值或假值</td></tr></tbody></table><h3 id="算术运算符">3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算</p><p>算术运算符包括以下符号：</p><table><thead><tr class="header"><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr class="odd"><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr class="even"><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr class="odd"><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr class="even"><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr class="odd"><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr class="even"><td>/</td><td>除</td><td>10 / 5</td><td>2</td></tr><tr class="odd"><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr class="even"><td>++</td><td>前置递增</td><td>a=2; b=++a;</td><td>a=3; b=3;</td></tr><tr class="odd"><td>++</td><td>后置递增</td><td>a=2; b=a++;</td><td>a=3; b=2;</td></tr><tr class="even"><td>--</td><td>前置递减</td><td>a=2; b=--a;</td><td>a=1; b=1;</td></tr><tr class="odd"><td>--</td><td>后置递减</td><td>a=2; b=a--;</td><td>a=1; b=2;</td></tr></tbody></table><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//加减乘除</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b1 = <span class="hljs-number">3</span>;<br><br>cout &lt;&lt; a1 + b1 &lt;&lt; endl;<br>cout &lt;&lt; a1 - b1 &lt;&lt; endl;<br>cout &lt;&lt; a1 * b1 &lt;&lt; endl;<br>cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="hljs-comment">//两个整数相除结果依然是整数</span><br><br><span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; a2 / b2 &lt;&lt; endl; <br><br><span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b3 = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span><br><br><br><span class="hljs-comment">//两个小数可以相除</span><br><span class="hljs-type">double</span> d1 = <span class="hljs-number">0.5</span>;<br><span class="hljs-type">double</span> d2 = <span class="hljs-number">0.25</span>;<br>cout &lt;&lt; d1 / d2 &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：在除法运算中，除数不能为0</p></blockquote><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//取模</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b1 = <span class="hljs-number">3</span>;<br><br>cout &lt;&lt; <span class="hljs-number">10</span> % <span class="hljs-number">3</span> &lt;&lt; endl;<br><br><span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b2 = <span class="hljs-number">20</span>;<br><br>cout &lt;&lt; a2 % b2 &lt;&lt; endl;<br><br><span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b3 = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span><br><br><span class="hljs-comment">//两个小数不可以取模</span><br><span class="hljs-type">double</span> d1 = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">double</span> d2 = <span class="hljs-number">1.1</span>;<br><br><span class="hljs-comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>总结：只有整型变量可以进行取模运算</p></blockquote><p><strong>示例3：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//递增</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//后置递增</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>a++; <span class="hljs-comment">//等价于a = a + 1</span><br>cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 11</span><br><br><span class="hljs-comment">//前置递增</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>++b;<br>cout &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">// 11</span><br><br><span class="hljs-comment">//区别</span><br><span class="hljs-comment">//前置递增先对变量进行++，再计算表达式</span><br><span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b2 = ++a2 * <span class="hljs-number">10</span>;<br>cout &lt;&lt; b2 &lt;&lt; endl;<br><br><span class="hljs-comment">//后置递增先计算表达式，后对变量进行++</span><br><span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b3 = a3++ * <span class="hljs-number">10</span>;<br>cout &lt;&lt; b3 &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p></blockquote><h3 id="赋值运算符">3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p><p>赋值运算符包括以下几个符号：</p><table><thead><tr class="header"><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr class="odd"><td>=</td><td>赋值</td><td>a=2; b=3;</td><td>a=2; b=3;</td></tr><tr class="even"><td>+=</td><td>加等于</td><td>a=0; a+=2;</td><td>a=2;</td></tr><tr class="odd"><td>-=</td><td>减等于</td><td>a=5; a-=3;</td><td>a=2;</td></tr><tr class="even"><td>*=</td><td>乘等于</td><td>a=2; a*=2;</td><td>a=4;</td></tr><tr class="odd"><td>/=</td><td>除等于</td><td>a=4; a/=2;</td><td>a=2;</td></tr><tr class="even"><td>%=</td><td>模等于</td><td>a=3; a%2;</td><td>a=1;</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//赋值运算符</span><br><br><span class="hljs-comment">// =</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// +=</span><br>a = <span class="hljs-number">10</span>;<br>a += <span class="hljs-number">2</span>; <span class="hljs-comment">// a = a + 2;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// -=</span><br>a = <span class="hljs-number">10</span>;<br>a -= <span class="hljs-number">2</span>; <span class="hljs-comment">// a = a - 2</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// *=</span><br>a = <span class="hljs-number">10</span>;<br>a *= <span class="hljs-number">2</span>; <span class="hljs-comment">// a = a * 2</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// /=</span><br>a = <span class="hljs-number">10</span>;<br>a /= <span class="hljs-number">2</span>;  <span class="hljs-comment">// a = a / 2;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// %=</span><br>a = <span class="hljs-number">10</span>;<br>a %= <span class="hljs-number">2</span>;  <span class="hljs-comment">// a = a % 2;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="比较运算符">3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p><p>比较运算符有以下符号：</p><table><thead><tr class="header"><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr class="odd"><td>==</td><td>相等于</td><td>4 == 3</td><td>0</td></tr><tr class="even"><td>!=</td><td>不等于</td><td>4 != 3</td><td>1</td></tr><tr class="odd"><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr class="even"><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr class="odd"><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>0</td></tr><tr class="even"><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 1</td><td>1</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br>cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="hljs-comment">// 0 </span><br><br>cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示，“假”用数字“0”来表示。==</p></blockquote><h3 id="逻辑运算符">3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p><p>逻辑运算符有以下符号：</p><table><thead><tr class="header"><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr class="odd"><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真； 如果a为真，则!a为假。</td></tr><tr class="even"><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr class="odd"><td>||</td><td>或</td><td>a|| b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table><p><strong>示例1：</strong>逻辑非</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//逻辑运算符  --- 非</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; !a &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>cout &lt;&lt; !!a &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 真变假，假变真</p></blockquote><p><strong>示例2：</strong>逻辑与</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//逻辑运算符  --- 与</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="hljs-comment">// 1</span><br><br>a = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="hljs-comment">// 0 </span><br><br>a = <span class="hljs-number">0</span>;<br>b = <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>总结：逻辑==与==运算符总结： ==同真为真，其余为假==</p></blockquote><p><strong>示例3：</strong>逻辑或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//逻辑运算符  --- 或</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="hljs-comment">// 1</span><br><br>a = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="hljs-comment">// 1 </span><br><br>a = <span class="hljs-number">0</span>;<br>b = <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>逻辑==或==运算符总结： ==同假为假，其余为真==</p></blockquote><h2 id="程序流程结构">4 程序流程结构</h2><p>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p><ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码</li></ul><h3 id="选择结构">4.1 选择结构</h3><h4 id="if语句">4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p><p>if语句的三种形式</p><ul><li>单行格式if语句</li><li>多行格式if语句</li><li>多条件的if语句</li></ul><ol type="1"><li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p><figure><img src="/img/clip_image0026.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//选择结构-单行if语句</span><br><span class="hljs-comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span><br><br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; score;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;<br><br><span class="hljs-comment">//if语句</span><br><span class="hljs-comment">//注意事项，在if判断语句后面，不要加分号</span><br><span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>注意：if条件表达式后不要加分号</p></blockquote><ol start="2" type="1"><li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li></ol><figure><img src="/img/clip_image002-1541662519170.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;<br><br>cin &gt;&gt; score;<br><br><span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li></ol><figure><img src="/img/clip_image002-1541662566808.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;<br><br>cin &gt;&gt; score;<br><br><span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">500</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">400</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p><p>案例需求：</p><ul><li>提示用户输入一个高考考试分数，根据分数做如下判断</li><li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li><li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;<br><br>cin &gt;&gt; score;<br><br><span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">700</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">650</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">500</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">400</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习案例：</strong> 三只小猪称体重</p><p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<imgsrc="/img/三只小猪.jpg" alt="三只小猪" /></p><h4 id="三目运算符">4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p><p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p><p><strong>解释：</strong></p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br><br>c = a &gt; b ? a : b;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-comment">//C++中三目运算符返回的是变量,可以继续赋值</span><br><br>(a &gt; b ? a : b) = <span class="hljs-number">100</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p></blockquote><h4 id="switch语句">4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span>(表达式)<br><br>&#123;<br><br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">1</span>：执行语句;<span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>：执行语句;<span class="hljs-keyword">break</span>;<br><br>...<br><br><span class="hljs-keyword">default</span>:执行语句;<span class="hljs-keyword">break</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//请给电影评分 </span><br><span class="hljs-comment">//10 ~ 9   经典   </span><br><span class="hljs-comment">// 8 ~ 7   非常好</span><br><span class="hljs-comment">// 6 ~ 5   一般</span><br><span class="hljs-comment">// 5分以下 烂片</span><br><br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; score;<br><br><span class="hljs-keyword">switch</span> (score)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;经典&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;非常好&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;一般&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;烂片&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意1：switch语句中表达式类型只能是整型或者字符型</p></blockquote><blockquote><p>注意2：case里如果没有break，那么程序会一直向下执行</p></blockquote><blockquote><p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p></blockquote><h3 id="循环结构">4.2 循环结构</h3><h4 id="while循环语句">4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p><p><strong>语法：</strong><code>while(循环条件)&#123; 循环语句 &#125;</code></p><p><strong>解释：</strong>==只要循环条件的结果为真，就执行循环语句==</p><figure><img src="/img/clip_image002-1541668640382.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>num++;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p></blockquote><p><strong>while循环练习案例：</strong>==猜数字==</p><p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p><figure><img src="/img/猜数字.jpg" alt="猜数字" /><figcaption aria-hidden="true">猜数字</figcaption></figure><h4 id="do...while循环语句">4.2.2 do...while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code>do&#123; 循环语句 &#125; while(循环条件);</code></p><p><strong>注意：</strong>与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件</p><figure><img src="/img/clip_image002-1541671163478.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">do</span><br>&#123;<br>cout &lt;&lt; num &lt;&lt; endl;<br>num++;<br><br>&#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>);<br><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件</p></blockquote><p><strong>练习案例：水仙花数</strong></p><p><strong>案例描述：</strong>水仙花数是指一个 3位数，它的每个位上的数字的 3次幂之和等于它本身</p><p>例如：1^3 + 5^3+ 3^3 = 153</p><p>请利用do...while语句，求出所有3位数中的水仙花数</p><h4 id="for循环语句">4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code>for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>详解：</strong></p><figure><img src="/img/1541673704101.png" alt="1541673704101" /><figcaption aria-hidden="true">1541673704101</figcaption></figure><blockquote><p>注意：for循环中的表达式，要用分号进行分隔</p></blockquote><blockquote><p>总结：while , do...while,for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p></blockquote><p><strong>练习案例：敲桌子</strong></p><p>案例描述：从1开始数到数字100，如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p><figure><img src="/img/timg.gif" alt="timg" /><figcaption aria-hidden="true">timg</figcaption></figure><h4 id="嵌套循环">4.2.4 嵌套循环</h4><p><strong>作用：</strong>在循环体中再嵌套一层循环，解决一些实际问题</p><p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p><figure><img src="/img/1541676003486.png" alt="1541676003486" /><figcaption aria-hidden="true">1541676003486</figcaption></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//外层循环执行1次，内层循环执行1轮</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习案例：</strong>乘法口诀表</p><p>案例描述：利用嵌套循环，实现九九乘法表</p><figure><img src="/img/0006018857256120_b.jpg" alt="0006018857256120_b" /><figcaption aria-hidden="true">0006018857256120_b</figcaption></figure><h3 id="跳转语句">4.3 跳转语句</h3><h4 id="break语句">4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出==选择结构==或者==循环结构==</p><p>break使用的时机：</p><ul><li>出现在switch条件语句中，作用是终止case并跳出switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//1、在switch 语句中使用break</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;1、普通&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;2、中等&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;3、困难&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>cin &gt;&gt; num;<br><br><span class="hljs-keyword">switch</span> (num)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//2、在循环语句中用break</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">//跳出循环语句</span><br>&#125;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//在嵌套循环语句中使用break，退出内层循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="continue语句">4.3.2 continue语句</h4><p><strong>作用：</strong>在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：continue并没有使整个循环终止，而break会跳出循环</p></blockquote><h4 id="goto语句">4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p><p><strong>语法：</strong> <code>goto 标记;</code></p><p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">goto</span> FLAG;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;3&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;4&quot;</span> &lt;&lt; endl;<br><br>FLAG:<br><br>cout &lt;&lt; <span class="hljs-string">&quot;5&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p></blockquote><h2 id="数组">5 数组</h2><h3 id="概述">5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p><p><strong>特点1：</strong>数组中的每个==数据元素都是相同的数据类型==</p><p><strong>特点2：</strong>数组是由==连续的内存==位置组成的</p><figure><img src="/img/1541748375356.png" alt="1541748375356" /><figcaption aria-hidden="true">1541748375356</figcaption></figure><h3 id="一维数组">5.2 一维数组</h3><h4 id="一维数组定义方式">5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p><ol type="1"><li><code>数据类型  数组名[ 数组长度 ];</code></li><li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li><li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li></ol><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//定义方式1</span><br><span class="hljs-comment">//数据类型 数组名[元素个数];</span><br><span class="hljs-type">int</span> score[<span class="hljs-number">10</span>];<br><br><span class="hljs-comment">//利用下标赋值</span><br>score[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br>score[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>;<br>score[<span class="hljs-number">2</span>] = <span class="hljs-number">85</span>;<br><br><span class="hljs-comment">//利用下标输出</span><br>cout &lt;&lt; score[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; score[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>cout &lt;&lt; score[<span class="hljs-number">2</span>] &lt;&lt; endl;<br><br><br><span class="hljs-comment">//第二种定义方式</span><br><span class="hljs-comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span><br><span class="hljs-comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span><br><span class="hljs-type">int</span> score2[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">100</span>, <span class="hljs-number">90</span>,<span class="hljs-number">80</span>,<span class="hljs-number">70</span>,<span class="hljs-number">60</span>,<span class="hljs-number">50</span>,<span class="hljs-number">40</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span> &#125;;<br><br><span class="hljs-comment">//逐个输出</span><br><span class="hljs-comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span><br><br><span class="hljs-comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; score2[i] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//定义方式3</span><br><span class="hljs-comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span><br><span class="hljs-type">int</span> score3[] = &#123; <span class="hljs-number">100</span>,<span class="hljs-number">90</span>,<span class="hljs-number">80</span>,<span class="hljs-number">70</span>,<span class="hljs-number">60</span>,<span class="hljs-number">50</span>,<span class="hljs-number">40</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; score3[i] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p></blockquote><blockquote><p>总结2：数组中下标是从0开始索引</p></blockquote><h4 id="一维数组数组名">5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p><ol type="1"><li>可以统计整个数组在内存中的长度</li><li>可以获取数组在内存中的首地址</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//数组名用途</span><br><span class="hljs-comment">//1、可以获取整个数组占用内存空间大小</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) &lt;&lt; endl;<br><br><span class="hljs-comment">//2、可以通过数组名获取到数组首地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)arr &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;arr[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;arr[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br><span class="hljs-comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span><br><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：数组名是常量，不可以赋值</p></blockquote><blockquote><p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p></blockquote><blockquote><p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p></blockquote><p><strong>练习案例1</strong>：五只小猪称体重</p><p><strong>案例描述：</strong></p><p>在一个数组中记录了五只小猪的体重，如：int arr[5] ={300,350,200,400,250};</p><p>找出并打印最重的小猪体重。</p><p><strong>练习案例2：</strong>数组元素逆置</p><p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p><p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p><h4 id="冒泡排序">5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p><ol type="1"><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li><li>重复以上的步骤，每次比较次数-1，直到不需要比较</li></ol><figure><img src="/img/1541905327273.png" alt="1541905327273" /><figcaption aria-hidden="true">1541905327273</figcaption></figure><p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">9</span>] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span> - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span> - <span class="hljs-number">1</span> - i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br>  <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维数组">5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p><figure><img src="/img/1541905559138.png" alt="1541905559138" /><figcaption aria-hidden="true">1541905559138</figcaption></figure><h4 id="二维数组定义方式">5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p><ol type="1"><li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li><li><code>数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li></ol><blockquote><p>建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//方式1  </span><br><span class="hljs-comment">//数组类型 数组名 [行数][列数]</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>&#123;<br>cout &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//方式2 </span><br><span class="hljs-comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">//方式3</span><br><span class="hljs-comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span><br><span class="hljs-type">int</span> arr3[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;; <br><br><span class="hljs-comment">//方式4 </span><br><span class="hljs-comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span><br><span class="hljs-type">int</span> arr4[][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p></blockquote><h4 id="二维数组数组名">5.3.2 二维数组数组名</h4><ul><li>查看二维数组所占内存空间</li><li>获取二维数组首地址</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//二维数组数组名</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>&#125;;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &lt;&lt; endl;<br><br><span class="hljs-comment">//地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：二维数组名就是这个数组的首地址</p></blockquote><blockquote><p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p></blockquote><h4 id="二维数组应用案例"><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p><p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p><table><thead><tr class="header"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr class="odd"><td>张三</td><td>100</td><td>100</td><td>100</td></tr><tr class="even"><td>李四</td><td>90</td><td>50</td><td>100</td></tr><tr class="odd"><td>王五</td><td>60</td><td>70</td><td>80</td></tr></tbody></table><p><strong>参考答案：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> scores[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>&#125;,<br>&#123;<span class="hljs-number">90</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>&#125;,<br>&#123;<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>&#125;,<br>&#125;;<br><br>string names[<span class="hljs-number">3</span>] = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>&#123;<br>sum += scores[i][j];<br>&#125;<br>cout &lt;&lt; names[i] &lt;&lt; <span class="hljs-string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数">6 函数</h2><h3 id="概述-1">6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h3 id="函数的定义">6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p><p>1、返回值类型</p><p>2、函数名</p><p>3、参数表列</p><p>4、函数体语句</p><p>5、return 表达式</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">返回值类型 函数名 （参数列表）<br>&#123;<br><br>       函数体语句<br><br>       <span class="hljs-keyword">return</span>表达式<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul><p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数定义</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> sum = num1 + num2;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数的调用">6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p><p><strong>语法：</strong><code>函数名（参数）</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数定义</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> <span class="hljs-comment">//定义中的num1,num2称为形式参数，简称形参</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> sum = num1 + num2;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//调用add函数</span><br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">add</span>(a, b);<span class="hljs-comment">//调用时的a，b称为实际参数，简称实参</span><br>cout &lt;&lt; <span class="hljs-string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;<br><br>a = <span class="hljs-number">100</span>;<br>b = <span class="hljs-number">100</span>;<br><br>sum = <span class="hljs-built_in">add</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p></blockquote><h3 id="值传递">6.4 值传递</h3><ul><li>所谓值传递，就是函数调用时实参将数值传入给形参</li><li>值传递时，==如果形参发生，并不会影响实参==</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;交换前：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;<br><br><span class="hljs-type">int</span> temp = num1;<br>num1 = num2;<br>num2 = temp;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;<br><br><span class="hljs-comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-built_in">swap</span>(a, b);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 值传递时，形参是修饰不了实参的</p></blockquote><h3 id="函数的常见样式"><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p><ol type="1"><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数常见样式</span><br><span class="hljs-comment">//1、 无参无返</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;this is test01&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//test01(); 函数调用</span><br>&#125;<br><br><span class="hljs-comment">//2、 有参无返</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test02&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//3、无参有返</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test03 &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-comment">//4、有参有返</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test04 &quot;</span> &lt;&lt; endl;<br><span class="hljs-type">int</span> sum = a + b;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数的声明">6.6 函数的声明</h3><p><strong>作用：</strong>告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><ul><li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//声明可以多次，定义只能一次</span><br><span class="hljs-comment">//声明</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">//定义</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">max</span>(a, b) &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数的分文件编写">6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><ol type="1"><li>创建后缀名为.h的头文件</li><li>创建后缀名为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//swap.h文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//实现两个数字交换的函数声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//swap.cpp文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;swap.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//main函数文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;swap.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;<br><span class="hljs-built_in">swap</span>(a, b);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="指针">7 指针</h2><h3 id="指针的基本概念">7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h3 id="指针变量的定义和使用">7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//1、指针的定义</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//定义整型变量a</span><br><br><span class="hljs-comment">//指针定义语法： 数据类型 * 变量名 ;</span><br><span class="hljs-type">int</span> * p;<br><br><span class="hljs-comment">//指针变量赋值</span><br>p = &amp;a; <span class="hljs-comment">//指针指向变量a的地址</span><br>cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">//打印数据a的地址</span><br>cout &lt;&lt; p &lt;&lt; endl;  <span class="hljs-comment">//打印指针变量p</span><br><br><span class="hljs-comment">//2、指针的使用</span><br><span class="hljs-comment">//通过*操作指针变量指向的内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>指针变量和普通变量的区别</p><ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过" *"操作符，操作指针变量指向的内存空间，这个过程称为解引用</li></ul><blockquote><p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p></blockquote><blockquote><p>总结2：利用指针可以记录地址</p></blockquote><blockquote><p>总结3：对指针变量解引用，可以操作指针指向的内存</p></blockquote><h3 id="指针所占内存空间">7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> * p;<br>p = &amp;a; <span class="hljs-comment">//指针指向数据a的地址</span><br><br>cout &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">//* 解引用</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span> *) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span> *) &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：所有指针类型在32位操作系统下是4个字节</p></blockquote><h3 id="空指针和野指针">7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><p><strong>示例1：空指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//指针变量p指向内存地址编号为0的空间</span><br><span class="hljs-type">int</span> * p = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//访问空指针报错 </span><br><span class="hljs-comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span><br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><p><strong>示例2：野指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//指针变量p指向内存地址编号为0x1100的空间</span><br><span class="hljs-type">int</span> * p = (<span class="hljs-type">int</span> *)<span class="hljs-number">0x1100</span>;<br><br><span class="hljs-comment">//访问野指针报错 </span><br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p></blockquote><h3 id="const修饰指针">7.5 const修饰指针</h3><p>const修饰指针有三种情况</p><ol type="1"><li>const修饰指针 --- 常量指针</li><li>const修饰常量 --- 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p1 = &amp;a; <br>p1 = &amp;b; <span class="hljs-comment">//正确</span><br><span class="hljs-comment">//*p1 = 100;  报错</span><br><br><br><span class="hljs-comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span><br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p2 = &amp;a;<br><span class="hljs-comment">//p2 = &amp;b; //错误</span><br>*p2 = <span class="hljs-number">100</span>; <span class="hljs-comment">//正确</span><br><br>    <span class="hljs-comment">//const既修饰指针又修饰常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p3 = &amp;a;<br><span class="hljs-comment">//p3 = &amp;b; //错误</span><br><span class="hljs-comment">//*p3 = 100; //错误</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>技巧：看const右侧紧跟着的是指针还是常量,是指针就是常量指针，是常量就是指针常量</p></blockquote><h3 id="指针和数组">7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><br><span class="hljs-type">int</span> * p = arr;  <span class="hljs-comment">//指向数组的指针</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-comment">//利用指针遍历数组</span><br>cout &lt;&lt; *p &lt;&lt; endl;<br>p++;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指针和函数">7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap1</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b; <br>b = temp;<br>&#125;<br><span class="hljs-comment">//地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap2</span><span class="hljs-params">(<span class="hljs-type">int</span> * p1, <span class="hljs-type">int</span> *p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = *p1;<br>*p1 = *p2;<br>*p2 = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">swap1</span>(a, b); <span class="hljs-comment">// 值传递不会改变实参</span><br><br><span class="hljs-built_in">swap2</span>(&amp;a, &amp;b); <span class="hljs-comment">//地址传递会改变实参</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p></blockquote><h3 id="指针数组函数">7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//冒泡排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> * arr, <span class="hljs-type">int</span> len)</span>  <span class="hljs-comment">//int * arr 也可以写为int arr[]</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//打印数组函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><br><span class="hljs-built_in">bubbleSort</span>(arr, len);<br><br><span class="hljs-built_in">printArray</span>(arr, len);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p></blockquote><h2 id="结构体">8 结构体</h2><h3 id="结构体基本概念">8.1 结构体基本概念</h3><p>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p><h3 id="结构体定义和使用">8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = { 成员1值 ， 成员2值...}</li><li>定义结构体时顺便创建变量</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br>string name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//分数</span><br>&#125;stu3; <span class="hljs-comment">//结构体变量创建方式3 </span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//结构体变量创建方式1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stu1; <span class="hljs-comment">//struct 关键字可以省略</span><br><br>stu1.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>stu1.age = <span class="hljs-number">18</span>;<br>stu1.score = <span class="hljs-number">100</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;<br><br><span class="hljs-comment">//结构体变量创建方式2</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stu2 = &#123; <span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-number">60</span> &#125;;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;<br><br><br>stu3.name = <span class="hljs-string">&quot;王五&quot;</span>;<br>stu3.age = <span class="hljs-number">18</span>;<br>stu3.score = <span class="hljs-number">80</span>;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：定义结构体时的关键字是struct，不可省略</p></blockquote><blockquote><p>总结2：创建结构体变量时，关键字struct可以省略</p></blockquote><blockquote><p>总结3：结构体变量利用操作符 ''.'' 访问成员</p></blockquote><h3 id="结构体数组">8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p><p><strong>语法：</strong><code>struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br>string name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//分数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//结构体数组</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> arr[<span class="hljs-number">3</span>]=<br>&#123;<br>&#123;<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">80</span> &#125;,<br>&#123;<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-number">60</span> &#125;,<br>&#123;<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">70</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体指针">8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt;</code>可以通过结构体指针访问结构体属性</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br>string name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//分数</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stu = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">100</span>, &#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> * p = &amp;stu;<br><br>p-&gt;score = <span class="hljs-number">80</span>; <span class="hljs-comment">//指针通过 -&gt; 操作符可以访问成员</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p></blockquote><h3 id="结构体嵌套结构体">8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p><p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//学生结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br>string name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//分数</span><br>&#125;;<br><br><span class="hljs-comment">//教师结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">teacher</span><br>&#123;<br>    <span class="hljs-comment">//成员列表</span><br><span class="hljs-type">int</span> id; <span class="hljs-comment">//职工编号</span><br>string name;  <span class="hljs-comment">//教师姓名</span><br><span class="hljs-type">int</span> age;   <span class="hljs-comment">//教师年龄</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stu; <span class="hljs-comment">//子结构体 学生</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">teacher</span> t1;<br>t1.id = <span class="hljs-number">10000</span>;<br>t1.name = <span class="hljs-string">&quot;老王&quot;</span>;<br>t1.age = <span class="hljs-number">40</span>;<br><br>t1.stu.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>t1.stu.age = <span class="hljs-number">18</span>;<br>t1.stu.score = <span class="hljs-number">100</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="hljs-string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="hljs-string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p><h3 id="结构体做函数参数">8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//学生结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br>string name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//分数</span><br>&#125;;<br><br><span class="hljs-comment">//值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStudent</span><span class="hljs-params">(student stu )</span></span><br><span class="hljs-function"></span>&#123;<br>stu.age = <span class="hljs-number">28</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStudent2</span><span class="hljs-params">(student *stu)</span></span><br><span class="hljs-function"></span>&#123;<br>stu-&gt;age = <span class="hljs-number">28</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>student stu = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">100</span>&#125;;<br><span class="hljs-comment">//值传递</span><br><span class="hljs-built_in">printStudent</span>(stu);<br>cout &lt;&lt; <span class="hljs-string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;<br><br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//地址传递</span><br><span class="hljs-built_in">printStudent2</span>(&amp;stu);<br>cout &lt;&lt; <span class="hljs-string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p></blockquote><h3 id="结构体中-const使用场景">8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//学生结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br>string name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//分数</span><br>&#125;;<br><br><span class="hljs-comment">//const使用场景</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> student *stu)</span> <span class="hljs-comment">//加const防止函数体中的误操作</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>student stu = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">100</span> &#125;;<br><br><span class="hljs-built_in">printStudent</span>(&amp;stu);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体案例">8.8 结构体案例</h3><h4 id="案例1">8.8.1 案例1</h4><p><strong>案例描述：</strong></p><p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p><p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p><p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p><p>最终打印出老师数据以及老师所带的学生数据。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br>string name;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span><br>&#123;<br>string name;<br>Student sArray[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocateSpace</span><span class="hljs-params">(Teacher tArray[] , <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>string tName = <span class="hljs-string">&quot;教师&quot;</span>;<br>string sName = <span class="hljs-string">&quot;学生&quot;</span>;<br>string nameSeed = <span class="hljs-string">&quot;ABCDE&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>tArray[i].name = tName + nameSeed[i];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br>&#123;<br>tArray[i].sArray[j].name = sName + nameSeed[j];<br>tArray[i].sArray[j].score = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">61</span> + <span class="hljs-number">40</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printTeachers</span><span class="hljs-params">(Teacher tArray[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>cout &lt;&lt; tArray[i].name &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机数种子 头文件 #include &lt;ctime&gt;</span><br><br>Teacher tArray[<span class="hljs-number">3</span>]; <span class="hljs-comment">//老师数组</span><br><br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(tArray) / <span class="hljs-built_in">sizeof</span>(Teacher);<br><br><span class="hljs-built_in">allocateSpace</span>(tArray, len); <span class="hljs-comment">//创建数据</span><br><br><span class="hljs-built_in">printTeachers</span>(tArray, len); <span class="hljs-comment">//打印数据</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例2">8.8.2 案例2</h4><p><strong>案例描述：</strong></p><p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p><p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p><p>五名英雄信息如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<span class="hljs-string">&quot;刘备&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;关羽&quot;</span>,<span class="hljs-number">22</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;张飞&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;赵云&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;貂蝉&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&quot;女&quot;</span>&#125;,<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//英雄结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hero</span><br>&#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>string sex;<br>&#125;;<br><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(hero arr[] , <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[j].age &gt; arr[j + <span class="hljs-number">1</span>].age)<br>&#123;<br>hero temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//打印数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printHeros</span><span class="hljs-params">(hero arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="hljs-string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hero</span> arr[<span class="hljs-number">5</span>] =<br>&#123;<br>&#123;<span class="hljs-string">&quot;刘备&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;关羽&quot;</span>,<span class="hljs-number">22</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;张飞&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;赵云&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;貂蝉&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&quot;女&quot;</span>&#125;,<br>&#125;;<br><br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(hero); <span class="hljs-comment">//获取数组元素个数</span><br><br><span class="hljs-built_in">bubbleSort</span>(arr, len); <span class="hljs-comment">//排序</span><br><br><span class="hljs-built_in">printHeros</span>(arr, len); <span class="hljs-comment">//打印</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LDA</title>
    <link href="/2023/03/07/LDA/"/>
    <url>/2023/03/07/LDA/</url>
    
    <content type="html"><![CDATA[<h2 id="lda-原理">LDA 原理</h2><p>给定数据<span class="math inline">\(\mathbf{X}\in \mathbb{R}^{N\timesp}\)</span>，以及<span class="math inline">\(\mathbf{y}\in\{0,1\}\)</span>，构成输入与输出训练数据对<spanclass="math inline">\(D=\{(\mathbf{x}_1,\mathbf{y}_1),...,(\mathbf{x}_N,\mathbf{y}_N)\}\)</span>。训练集<spanclass="math inline">\(D\)</span>表示整个训练数据集有<spanclass="math inline">\(N\)</span>条数据，每一条数据的维度为<spanclass="math inline">\(p\)</span>维，所有数据只有两个类别分别对应于输出<spanclass="math inline">\(\mathbf{y}\)</span>取值为0或者1。</p><p>首先假设两类数据中第一类数据<spanclass="math inline">\(\mathbf{x}_{c1}\)</span>有<spanclass="math inline">\(|\mathbf{x}_{c1}|=N_1\)</span>个，第二类数据有<spanclass="math inline">\(|\mathbf{x}_{c2}|=N_2\)</span>个，且<spanclass="math inline">\(N_1+N_2=N\)</span>。两类数据的均值和方差可以表示为：</p><p><span class="math display">\[\bar{\mathbf{x_1}}=\frac{1}{N_1}\sum_{i=1}^{N_1}\mathbf{x}_i\]</span></p><p><span class="math display">\[\bar{\mathbf{x_2}}=\frac{1}{N_2}\sum_{i=1}^{N_2}\mathbf{x}_i\]</span></p><p><span class="math display">\[\mathbf{S}_{x1}=\frac{1}{N_1}\sum_{i=1}^{N_1}(\mathbf{x}_i-\bar{\mathbf{x_1}})(\mathbf{x}_i-\bar{\mathbf{x_1}})^T\]</span></p><p><span class="math display">\[\mathbf{S}_{x2}=\frac{1}{N_2}\sum_{i=1}^{N_2}(\mathbf{x}_i-\bar{\mathbf{x_2}})(\mathbf{x}_i-\bar{\mathbf{x_2}})^T\]</span></p><p>对输入的<span class="math inline">\(p\)</span>维特征进行降维有<spanclass="math inline">\(\mathbf{z}_i=\mathbf{W}^T\mathbf{x}_i\)</span>，其中<spanclass="math inline">\(\mathbf{z}\)</span>表示降维之后的数据，那么降维之后的数据的均值和方差分别为：</p><p><span class="math display">\[\bar{\mathbf{z_1}}=\frac{1}{N_1}\sum_{i=1}^{N_1}\mathbf{W}^T\mathbf{x}_i\]</span></p><p><span class="math display">\[\mathbf{S}_1=\frac{1}{N_1}\sum_{i=1}^{N_1}(\mathbf{W}^T\mathbf{x}_i-\bar{\mathbf{z_1}})(\mathbf{W}^T\mathbf{x}_i-\bar{\mathbf{z_1}})^T\]</span></p><p><span class="math display">\[\bar{\mathbf{z_2}}=\frac{1}{N_2}\sum_{i=1}^{N_2}\mathbf{W}^T\mathbf{x}_i\]</span></p><p><span class="math display">\[\mathbf{S}_2=\frac{1}{N_2}\sum_{i=1}^{N_2}(\mathbf{W}^T\mathbf{x}_i-\bar{\mathbf{z_2}})(\mathbf{W}^T\mathbf{x}_i-\bar{\mathbf{z_2}})^T\]</span></p><p><img src="/img/LDA.jpg" alt="二维LDA示意图" />LDA的示意图如上图所示，它的最终目的是使得同一类型的数据之间尽可能地聚集在一起，使得位于不同类别的两类数据尽可能分开。首先是让位于同一类别的数据尽可能地聚集在一起，实际上就是让两类数据的方差尽可能小<spanclass="math inline">\(\min\mathbf{S}_1+\mathbf{S}_2\)</span>。其次是让位于不同类别的数据之间尽可能离得远，这一点可以通过让两类数据的中心也就是均值之间的距离尽可能远<spanclass="math inline">\(\max||\bar{\mathbf{z}_1}-\bar{\mathbf{z}_2}||_F^2\)</span>最终LDA的目标函数可以表示为：</p><p><span class="math display">\[L = \frac{||\bar{\mathbf{z}_1}-\bar{\mathbf{z}_2}||_F^2}{\mathbf{S}_1+\mathbf{S}_2}\]</span></p><p>首先对分子进行化简有：</p><p><span class="math display">\[\begin{aligned}||\bar{\mathbf{z}_1}-\bar{\mathbf{z}_2}||_F^2&amp;=||\frac{1}{N_1}\sum_{x=1}^{N_1}\mathbf{W}^T\mathbf{x}_i-\frac{1}{N_2}\sum_{x=1}^{N_2}\mathbf{W}^T\mathbf{x}_i||_F^2\\&amp;=||\mathbf{W}^T(\frac{1}{N_1}\sum_{t=1}^{N_1}\mathbf{x}_i-\frac{1}{N_2}\sum_{t=1}^{N_2}\mathbf{x}_i)||_F^2\\&amp;=||\mathbf{W}^T(\bar{\mathbf{x_1}}-\bar{\mathbf{x_2}})||_F^2\\&amp;=\mathbf{W}^T(\bar{\mathbf{x_1}}-\bar{\mathbf{x_2}})(\bar{\mathbf{x_1}}-\bar{\mathbf{x_2}})^T\mathbf{W}\end{aligned}\]</span></p><p>对分母进行化简有：</p><p><span class="math display">\[\begin{aligned}\mathbf{S_1+S_2}&amp;=\frac{1}{N_1}\sum_{i=1}^{N_1}(\mathbf{W}^T\mathbf{x}_i-\bar{\mathbf{z_1}})(\mathbf{W}^T\mathbf{x}_i-\bar{\mathbf{z_1}})^T+\frac{1}{N_2}\sum_{i=1}^{N_2}(\mathbf{W}^T\mathbf{x}_i-\bar{\mathbf{z_2}})(\mathbf{W}^T\mathbf{x}_i-\bar{\mathbf{z_2}})^T\\&amp;=\frac{1}{N_1}\sum_{i=1}^{N_1}(\mathbf{W}^T\mathbf{x}_i-\frac{1}{N_1}\sum_{i=1}^{N_1}\mathbf{W}^T\mathbf{x}_i)(\mathbf{W}^T\mathbf{x}_i-\frac{1}{N_1}\sum_{i=1}^{N_1}\mathbf{W}^T\mathbf{x}_i)^T\\&amp;+\frac{1}{N_2}\sum_{i=1}^{N_2}(\mathbf{W}^T\mathbf{x}_i-\frac{1}{N_2}\sum_{i=1}^{N_2}\mathbf{W}^T\mathbf{x}_i)(\mathbf{W}^T\mathbf{x}_i-\frac{1}{N_2}\sum_{i=1}^{N_2}\mathbf{W}^T\mathbf{x}_i)^T\\&amp;=\mathbf{W}^T\frac{1}{N_1}\sum_{i=1}^{N_1}(\mathbf{x}_i-\frac{1}{N_1}\sum_{i=1}^{N_1}\mathbf{x}_i)(\mathbf{x}_i-\frac{1}{N_1}\sum_{i=1}^{N_1}\mathbf{x}_i)^T\mathbf{W}\\&amp;=\mathbf{W}^T\frac{1}{N_2}\sum_{i=1}^{N_2}(\mathbf{x}_i-\frac{1}{N_2}\sum_{i=1}^{N_2}\mathbf{x}_i)(\mathbf{x}_i-\frac{1}{N_2}\sum_{i=1}^{N_2}\mathbf{x}_i)^T\mathbf{W}\\&amp;=\mathbf{W}^T\frac{1}{N_1}\sum_{i=1}^{N_1}(\mathbf{x}_i-\bar{\mathbf{x}_1})(\mathbf{x}_i-\bar{\mathbf{x}_1})^T\mathbf{W}+\mathbf{W}^T\frac{1}{N_2}\sum_{i=1}^{N_2}(\mathbf{x}_i-\bar{\mathbf{x}_2})(\mathbf{x}_i-\bar{\mathbf{x}_2})^T\mathbf{W}\\&amp;=\mathbf{W}^T(\mathbf{S}_{x1}-\mathbf{S}_{x2})\mathbf{W}\end{aligned}\]</span></p><p>最终LDA的目标函数可以表示为：</p><p><span class="math display">\[L =\frac{\mathbf{W}^T(\bar{\mathbf{x_1}}-\bar{\mathbf{x_2}})(\bar{\mathbf{x_1}}-\bar{\mathbf{x_2}})^T\mathbf{W}}{\mathbf{W}^T(\mathbf{S}_{x1}-\mathbf{S}_{x2})\mathbf{W}}\]</span></p><p>令<span class="math inline">\(\mathbf{S}_{w}=(\bar{\mathbf{x_1}}-\bar{\mathbf{x_2}})(\bar{\mathbf{x_1}}-\bar{\mathbf{x_2}})^T\)</span>，<spanclass="math inline">\(\mathbf{S}_{b}=\mathbf{S}_{x1}-\mathbf{S}_{x2}\)</span>有：</p><p><span class="math display">\[L =\frac{\mathbf{W}^T\mathbf{S}_w\mathbf{W}}{\mathbf{W}^T\mathbf{S}_b\mathbf{W}}\]</span></p><p>求解目标函数中的<spanclass="math inline">\(\mathbf{W}\)</span>可以得到最终的解。</p><h2 id="算法实现">算法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.cm <span class="hljs-keyword">as</span> cmx<br><span class="hljs-keyword">import</span> matplotlib.colors <span class="hljs-keyword">as</span> colors<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LDA</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 初始化权重矩阵</span><br>        self.w = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-comment"># 计算协方差矩阵</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_cov</span>(<span class="hljs-params">self, X, Y=<span class="hljs-literal">None</span></span>):<br>        m = X.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 数据标准化</span><br>        X = (X - np.mean(X, axis=<span class="hljs-number">0</span>))/np.std(X, axis=<span class="hljs-number">0</span>)<br>        Y = X <span class="hljs-keyword">if</span> Y == <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> (Y - np.mean(Y, axis=<span class="hljs-number">0</span>))/np.std(Y, axis=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / m * np.matmul(X.T, Y)<br>  <br>    <span class="hljs-comment"># 对数据进行投影</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">project</span>(<span class="hljs-params">self, X, y</span>):<br>        self.fit(X, y)<br>        X_projection = X.dot(self.w)<br>        <span class="hljs-keyword">return</span> X_projection<br>  <br>    <span class="hljs-comment"># LDA拟合过程</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fit</span>(<span class="hljs-params">self, X, y</span>):<br>        <span class="hljs-comment"># 按类分组</span><br>        X0 = X[y == <span class="hljs-number">0</span>]<br>        X1 = X[y == <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 分别计算两类数据自变量的协方差矩阵</span><br>        sigma0 = self.calc_cov(X0)<br>        sigma1 = self.calc_cov(X1)<br>        <span class="hljs-comment"># 计算类内散度矩阵</span><br>        Sw = sigma0 + sigma1<br><br>        <span class="hljs-comment"># 分别计算两类数据自变量的均值和差</span><br>        u0, u1 = np.mean(X0, axis=<span class="hljs-number">0</span>), np.mean(X1, axis=<span class="hljs-number">0</span>)<br>        mean_diff = np.atleast_1d(u0 - u1)<br><br>        <span class="hljs-comment"># 对类内散度矩阵进行奇异值分解</span><br>        U, S, V = np.linalg.svd(Sw)<br>        <span class="hljs-comment"># 计算类内散度矩阵的逆</span><br>        Sw_ = np.dot(np.dot(V.T, np.linalg.pinv(np.diag(S))), U.T)<br>        <span class="hljs-comment"># 计算w</span><br>        self.w = Sw_.dot(mean_diff)<br><br>  <br>    <span class="hljs-comment"># LDA分类预测</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, X</span>):<br>        y_pred = []<br>        <span class="hljs-keyword">for</span> sample <span class="hljs-keyword">in</span> X:<br>            h = sample.dot(self.w)<br>            y = <span class="hljs-number">1</span> * (h &lt; <span class="hljs-number">0</span>)<br>            y_pred.append(y)<br>        <span class="hljs-keyword">return</span> y_pred<br><br><br>data = datasets.load_iris()<br>X = data.data<br>y = data.target<br><br>X = X[y != <span class="hljs-number">2</span>]<br>y = y[y != <span class="hljs-number">2</span>]<br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">41</span>)<br><span class="hljs-built_in">print</span>(X_train.shape, X_test.shape, y_train.shape, y_test.shape)<br><br>lda = LDA()<br>lda.fit(X_train, y_train)<br>y_pred = lda.predict(X_test)<br><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br>accuracy = accuracy_score(y_test, y_pred)<br><span class="hljs-built_in">print</span>(accuracy)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_covariance_matrix</span>(<span class="hljs-params">X, Y=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> Y <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        Y = X<br>    n_samples = np.shape(X)[<span class="hljs-number">0</span>]<br>    covariance_matrix = (<span class="hljs-number">1</span> / (n_samples-<span class="hljs-number">1</span>)) * (X - X.mean(axis=<span class="hljs-number">0</span>)).T.dot(Y - Y.mean(axis=<span class="hljs-number">0</span>))<br><br>    <span class="hljs-keyword">return</span> np.array(covariance_matrix, dtype=<span class="hljs-built_in">float</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plot</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>): <br>        self.cmap = plt.get_cmap(<span class="hljs-string">&#x27;viridis&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_transform</span>(<span class="hljs-params">self, X, dim</span>):<br>        covariance = calculate_covariance_matrix(X)<br>        eigenvalues, eigenvectors = np.linalg.eig(covariance)<br>        <span class="hljs-comment"># Sort eigenvalues and eigenvector by largest eigenvalues</span><br>        idx = eigenvalues.argsort()[::-<span class="hljs-number">1</span>]<br>        eigenvalues = eigenvalues[idx][:dim]<br>        eigenvectors = np.atleast_1d(eigenvectors[:, idx])[:, :dim]<br>        <span class="hljs-comment"># Project the data onto principal components</span><br>        X_transformed = X.dot(eigenvectors)<br><br>        <span class="hljs-keyword">return</span> X_transformed<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_regression</span>(<span class="hljs-params">self, lines, title, axis_labels=<span class="hljs-literal">None</span>, mse=<span class="hljs-literal">None</span>, scatter=<span class="hljs-literal">None</span>, legend=&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;lines&quot;</span>, <span class="hljs-string">&quot;loc&quot;</span>: <span class="hljs-string">&quot;lower right&quot;</span>&#125;</span>):<br>    <br>        <span class="hljs-keyword">if</span> scatter:<br>            scatter_plots = scatter_labels = []<br>            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> scatter:<br>                scatter_plots += [plt.scatter(s[<span class="hljs-string">&quot;x&quot;</span>], s[<span class="hljs-string">&quot;y&quot;</span>], color=s[<span class="hljs-string">&quot;color&quot;</span>], s=s[<span class="hljs-string">&quot;size&quot;</span>])]<br>                scatter_labels += [s[<span class="hljs-string">&quot;label&quot;</span>]]<br>            scatter_plots = <span class="hljs-built_in">tuple</span>(scatter_plots)<br>            scatter_labels = <span class="hljs-built_in">tuple</span>(scatter_labels)<br><br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> lines:<br>            li = plt.plot(l[<span class="hljs-string">&quot;x&quot;</span>], l[<span class="hljs-string">&quot;y&quot;</span>], color=s[<span class="hljs-string">&quot;color&quot;</span>], linewidth=l[<span class="hljs-string">&quot;width&quot;</span>], label=l[<span class="hljs-string">&quot;label&quot;</span>])<br><br>        <span class="hljs-keyword">if</span> mse:<br>            plt.suptitle(title)<br>            plt.title(<span class="hljs-string">&quot;MSE: %.2f&quot;</span> % mse, fontsize=<span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">else</span>:<br>            plt.title(title)<br><br>        <span class="hljs-keyword">if</span> axis_labels:<br>            plt.xlabel(axis_labels[<span class="hljs-string">&quot;x&quot;</span>])<br>            plt.ylabel(axis_labels[<span class="hljs-string">&quot;y&quot;</span>])<br><br>        <span class="hljs-keyword">if</span> legend[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;lines&quot;</span>:<br>            plt.legend(loc=<span class="hljs-string">&quot;lower_left&quot;</span>)<br>        <span class="hljs-keyword">elif</span> legend[<span class="hljs-string">&quot;type&quot;</span>] == <span class="hljs-string">&quot;scatter&quot;</span> <span class="hljs-keyword">and</span> scatter:<br>            plt.legend(scatter_plots, scatter_labels, loc=legend[<span class="hljs-string">&quot;loc&quot;</span>])<br><br>        plt.show()<br><br>    <span class="hljs-comment"># Plot the dataset X and the corresponding labels y in 2D using PCA.</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_in_2d</span>(<span class="hljs-params">self, X, y=<span class="hljs-literal">None</span>, title=<span class="hljs-literal">None</span>, accuracy=<span class="hljs-literal">None</span>, legend_labels=<span class="hljs-literal">None</span></span>):<br>        X_transformed = self._transform(X, dim=<span class="hljs-number">2</span>)<br>        x1 = X_transformed[:, <span class="hljs-number">0</span>]<br>        x2 = X_transformed[:, <span class="hljs-number">1</span>]<br>        class_distr = []<br><br>        y = np.array(y).astype(<span class="hljs-built_in">int</span>)<br><br>        colors = [self.cmap(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(np.unique(y)))]<br><br>        <span class="hljs-comment"># Plot the different class distributions</span><br>        <span class="hljs-keyword">for</span> i, l <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(np.unique(y)):<br>            _x1 = x1[y == l]<br>            _x2 = x2[y == l]<br>            _y = y[y == l]<br>            class_distr.append(plt.scatter(_x1, _x2, color=colors[i]))<br><br>        <span class="hljs-comment"># Plot legend</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> legend_labels <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <br>            plt.legend(class_distr, legend_labels, loc=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># Plot title</span><br>        <span class="hljs-keyword">if</span> title:<br>            <span class="hljs-keyword">if</span> accuracy:<br>                perc = <span class="hljs-number">100</span> * accuracy<br>                plt.suptitle(title)<br>                plt.title(<span class="hljs-string">&quot;Accuracy: %.1f%%&quot;</span> % perc, fontsize=<span class="hljs-number">10</span>)<br>            <span class="hljs-keyword">else</span>:<br>                plt.title(title)<br><br>        <span class="hljs-comment"># Axis labels</span><br>        plt.xlabel(<span class="hljs-string">&#x27;class 1&#x27;</span>)<br>        plt.ylabel(<span class="hljs-string">&#x27;class 2&#x27;</span>)<br><br>        plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT</title>
    <link href="/2023/03/06/ChatGPT/"/>
    <url>/2023/03/06/ChatGPT/</url>
    
    <content type="html"><![CDATA[<p>ChatGPT是由InstructGPT演变而来的， <imgsrc="/img/ChatGPT_Diagram.png" alt="ChatGPT训练流程图" /></p><h2 id="简介">简介</h2><p>它的训练可以分为四个阶段：</p><ol type="1"><li>基于Mask的自监督训练</li><li>人工标注的监督QA训练</li><li>利用人工对答案优先级的标注数据进行监督训练</li><li>利用学习到的人类喜好通过强化学习训练判别模型</li></ol><h2 id="自监督训练">自监督训练</h2><figure><img src="/img/Hello.png" alt="基于采样的自监督训练" /><figcaption aria-hidden="true">基于采样的自监督训练</figcaption></figure><p>利用自监督训练进行文本生成，在训练中向模型中输入前面的单词，让模型自动预测后面的单词。预测得到的是可能单词的一个概率分布，通过beamsearch可以采样得到下一个词。然后再将最新生成的词也输入模型中再得到接下来的输出。由于输出结果是随机采样得到的，因此每次输出的结果是随机的。</p><p>实际上仅仅通过自监督训练已经可以完成ChatGPT中的问答任务了，例如：世界上最高的山在哪里？，将问题输入到模型中让模型进行文字生成，然后将生成文字作为问题的答案。但是这种模型仍然有很大的缺陷：</p><ol type="1"><li>由于每次的输出是随机采样得到的，因此每次得到的结果都是不固定的。</li><li>由于训练文本的复杂性往往无法得到可靠的结果</li></ol><p>为了解决以上的问题，ChatGPT使用了人工标注的QA数据进行了监督训练</p><h2 id="监督qa训练">监督QA训练</h2><p>为了提升网络对问答的准确性，首先收集一部分{“问题”，“答案”}数据，将问题答案数据对输入到模型中进行监督训练以提升模型对问答的可靠性。</p><p>值得注意的是，如果有标注数据的规模足够大，那么就可以模型的性能会最够好，但是人工标注的QA数据非常难以收集，而且昂贵。因此ChatGPT的训练中只使用了少量的标注数据，然后同构后续的步骤进一步提升模型的性能。</p><h2 id="监督学习人类的喜好">监督学习人类的喜好</h2><p>和人工标注的QA文本对相比，如果由人工标注ChatGPT生成答案的优先性更为方便快捷。实际上对ChatGPT来说，它能够生成正确的答案，它只是不知道哪一个答案更好而已。OpenAI雇佣了大量的人工对ChatGPT产生的答案进行评分和排序，然后利用收集到的数据训练一个评价网络<img src="/img/ChatGPT3.jpg" alt="利用人工对ChatGPT答案进行评估排序" />在评价网络中的训练中，将问题和ChatGPT生成的答案同时输入网络中，网络会输出一个分数<img src="/img/ChatGPT4.jpg" alt="使用标注数据训练评估网络" />分数越高的答案就意味着答案更符合人类的喜好。评估模型训练的损失函数可以表示为：</p><p><span class="math display">\[\operatorname{loss}(\theta)=-\frac{1}{\left(\begin{array}{c}K \\2\end{array}\right)} E_{\left(x, y_{w}, y_{l}\right) \sim D}\left[\log\left(\sigma\left(r_{\theta}\left(x, y_{w}\right)-r_{\theta}\left(x,y_{l}\right)\right)\right)\right]\]</span></p><p>式中<spanclass="math inline">\(r_{\theta}\)</span>表示训练的评价网络，而<spanclass="math inline">\(x\)</span>表示输入ChatGPT中的问题，<spanclass="math inline">\(y_w\)</span>和<spanclass="math inline">\(y_l\)</span>表示ChatGPT输出的两个不同的答案，其中<spanclass="math inline">\(y_w\)</span>为更好的那个答案，因此损失函数实际上就是让网络更能够区分两个不同质量的答案。损失函数前面的组合数实际上表示对同一个问题ChatGPT输出的答案数量，对输出的答案进行优先级排序就能够得到多个组合，可以大幅度提高数据的利用率。</p><h2 id="强化学习">强化学习</h2><p>强化学习的目标函数为</p><p><span class="math display">\[\begin{aligned}\operatorname{objective}(\phi)= &amp; E_{(x, y) \simD_{\pi_{\phi}^{\mathrm{RL}}}}\left[r_{\theta}(x, y)-\beta \log\left(\pi_{\phi}^{\mathrm{RL}}(y \mid x) / \pi^{\mathrm{SFT}}(y \midx)\right)\right]+ \\&amp; \gamma E_{x \sim D_{\text {prerrain }}}\left[\log\left(\pi_{\phi}^{\mathrm{RL}}(x)\right)\right]\end{aligned}\]</span></p><p>强化学习的目标函数包括三项，首先第一项表示<spanclass="math inline">\(r_{\theta}(x,y)\)</span>评价模型，强化学习目标是调整ChatGPT参数，使得评价模型对ChatGPT输出的答案评分最高。</p><p>目标函数的第二项实际上是一个KL散度，<spanclass="math inline">\(\pi^\mathrm{SFT}\)</span>表示通过人工标注QA数据训练的ChatGPT模型，而<spanclass="math inline">\(\pi_{\phi}^{\mathrm{RL}}\)</span>表示强化学习要学习的网络。这一项的意义实际上表示通过强化学习的网路要和通过标注QA学习得到的网络要尽可能接近，不希望网络有太大的改变。这一项是强化学习PPO-ptx模型的主要创新点。</p><p>目标函数的第三项表示ChatGPT预训练中的损失函数，网络训练中不希望通过微调提升了问答任务的表现但是使得预训练中的生成任务性能下降，因此把预训练中损失函数拿过来防止网络在其他任务上的性能下降。</p><h2 id="总结">总结</h2><ol type="1"><li>ChatGPT简单来说就是将GPT3再在标注数据上进行微调。</li><li>ChatGPT对很多问题都能得到很好的结果，但是，它本质上仍然是基于数据的模型，因此如果问ChatGPT一些没有用的问题，ChatGPT就可能出现问题。</li></ol><h2 id="reference">Reference</h2><ol type="1"><li><ahref="https://openai.com/blog/instruction-following/">InstructGPT</a></li><li><a href="https://openai.com/blog/chatgpt">Introducing ChatGPT(openai.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Openai_api</title>
    <link href="/2023/03/05/Openai-api/"/>
    <url>/2023/03/05/Openai-api/</url>
    
    <content type="html"><![CDATA[<h1 id="使用openai以及ynmt创建论文">使用OpenAI以及YNMT创建论文</h1><pre><code class=" mermaid">graph TB    id1(开始)--&gt;id2[访问YNMT/ChatGPT翻译模型]    subgraph          id2==鉴权==&gt;id3(向数据中心发送API与token)        id3--&gt;id4[鉴权通过]        id3--&gt;id5((结束))        end    subgraph 翻译    id4--&gt;id6(按段落读取文章)    id6--&gt;id7(送入翻译模型)    id7--&gt;id8(获取返回值)    id8--&gt;id9((创建TeX文档))        end</code></pre><h2 id="代码实现">代码实现</h2><p>main.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fnmatch <span class="hljs-keyword">import</span> translate<br><span class="hljs-keyword">from</span> pylatex <span class="hljs-keyword">import</span> Document, Section, Subsection, Command<br><span class="hljs-keyword">from</span> pylatex.base_classes <span class="hljs-keyword">import</span> Environment<br><span class="hljs-keyword">from</span> docx <span class="hljs-keyword">import</span> Document <span class="hljs-keyword">as</span> docx_Document<br><span class="hljs-keyword">from</span> pylatex.utils <span class="hljs-keyword">import</span> NoEscape<br><span class="hljs-keyword">from</span> pylatex.basic <span class="hljs-keyword">import</span> NewLine<br><span class="hljs-keyword">from</span> translate <span class="hljs-keyword">import</span> Zh2En<br><span class="hljs-keyword">from</span> pylatex.utils <span class="hljs-keyword">import</span> italic, NoEscape<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fill_document</span>(<span class="hljs-params">doc</span>):<br>    <span class="hljs-keyword">with</span> doc.create(Section(<span class="hljs-string">&#x27;A section&#x27;</span>)):<br>        doc.append(<span class="hljs-string">&#x27;Some regular text and some &#x27;</span>)<br>        doc.append(italic(<span class="hljs-string">&#x27;italic text. &#x27;</span>))<br>        <span class="hljs-keyword">with</span> doc.create(Subsection(<span class="hljs-string">&#x27;A subsection&#x27;</span>)):<br>            doc.append(<span class="hljs-string">&#x27;Also some crazy characters: $&amp;#&#123;&#125;&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABSTRACT</span>(<span class="hljs-title class_ inherited__">Environment</span>):<br>    escape = <span class="hljs-literal">False</span><br>    content_separator = <span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    doc = Document(default_filepath=<span class="hljs-string">&#x27;paper&#x27;</span>,documentclass=<span class="hljs-string">&#x27;IEEEtran&#x27;</span>,document_options=<span class="hljs-string">&#x27;journal&#x27;</span>,lmodern=<span class="hljs-literal">False</span>,textcomp=<span class="hljs-literal">False</span>)<br>    doc.preamble.append(Command(<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;Translate to English using the YNMT natural language translation model&#x27;</span>))<br>    doc.preamble.append(Command(<span class="hljs-string">&#x27;author&#x27;</span>, <span class="hljs-string">&#x27;***, ***&#x27;</span>))<br>    doc.append(NoEscape(<span class="hljs-string">r&#x27;\maketitle&#x27;</span>))<br>    <span class="hljs-keyword">with</span> doc.create(ABSTRACT()):<br>        abstract = docx_Document(<span class="hljs-string">r&quot;./abstract.docx&quot;</span>)<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> abstract.paragraphs:<br>            abstrach_zh = p.text<br>            abstrach_en = Zh2En(abstrach_zh)<br>            doc.append(abstrach_en)<br>    <span class="hljs-keyword">with</span> doc.create(Section(<span class="hljs-string">&#x27;Introduction&#x27;</span>)):<br>        introduction = docx_Document(<span class="hljs-string">r&quot;./introduction.docx&quot;</span>)<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> introduction.paragraphs:<br>            introduction_zh = p.text<br>            introduction_en = Zh2En(introduction_zh)<br>            doc.append(introduction_en)<br>            doc.append(NoEscape(<span class="hljs-string">r&#x27;\par&#x27;</span>))<br>    doc.generate_pdf(clean_tex=<span class="hljs-literal">False</span>)<br>    doc.generate_tex()<br></code></pre></td></tr></table></figure><p>调用YNMT函数获取翻译内容 translate.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> imp <span class="hljs-keyword">import</span> reload<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> toml<br><br>reload(sys)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;authentication.toml&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    token = toml.load(f)<br>    YOUDAO_URL = token[<span class="hljs-string">&#x27;YOUDAO_URL&#x27;</span>]<br>    APP_KEY = token[<span class="hljs-string">&#x27;YOUDAO_APP_KEY&#x27;</span>]<br>    APP_SECRET = token[<span class="hljs-string">&#x27;YOUDAO_APP_SECRET&#x27;</span>]<br><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">signStr</span>):<br>    hash_algorithm = hashlib.sha256()<br>    hash_algorithm.update(signStr.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-keyword">return</span> hash_algorithm.hexdigest()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">truncate</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-keyword">if</span> q <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    size = <span class="hljs-built_in">len</span>(q)<br>    <span class="hljs-keyword">return</span> q <span class="hljs-keyword">if</span> size &lt;= <span class="hljs-number">20</span> <span class="hljs-keyword">else</span> q[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>] + <span class="hljs-built_in">str</span>(size) + q[size - <span class="hljs-number">10</span>:size]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_request</span>(<span class="hljs-params">data</span>):<br>    headers = &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>&#125;<br>    <span class="hljs-keyword">return</span> requests.post(YOUDAO_URL, data=data, headers=headers)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Zh2En</span>(<span class="hljs-params">text</span>):<br>    q = text<br><br>    data = &#123;&#125;<br>    data[<span class="hljs-string">&#x27;from&#x27;</span>] = <span class="hljs-string">&#x27;zh-CHS&#x27;</span><br>    data[<span class="hljs-string">&#x27;to&#x27;</span>] = <span class="hljs-string">&#x27;en&#x27;</span><br>    data[<span class="hljs-string">&#x27;signType&#x27;</span>] = <span class="hljs-string">&#x27;v3&#x27;</span><br>    curtime = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(time.time()))<br>    data[<span class="hljs-string">&#x27;curtime&#x27;</span>] = curtime<br>    salt = <span class="hljs-built_in">str</span>(uuid.uuid1())<br>    signStr = APP_KEY + truncate(q) + salt + curtime + APP_SECRET<br>    sign = encrypt(signStr)<br>    data[<span class="hljs-string">&#x27;appKey&#x27;</span>] = APP_KEY<br>    data[<span class="hljs-string">&#x27;q&#x27;</span>] = q<br>    data[<span class="hljs-string">&#x27;salt&#x27;</span>] = salt<br>    data[<span class="hljs-string">&#x27;sign&#x27;</span>] = sign<br>    data[<span class="hljs-string">&#x27;vocabId&#x27;</span>] = <span class="hljs-string">&quot;2CBA59B4E493479FBBC1509DAD1C8F2D&quot;</span><br><br>    response = do_request(data)<br>    contentType = response.headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>]<br><br>      <br>    load_data = json.loads(response.content)<br>      <br>    out_text = load_data[<span class="hljs-string">&#x27;translation&#x27;</span>]<br>    out = out_text[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChatGPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Word2Vec</title>
    <link href="/2023/03/05/Word2Vec/"/>
    <url>/2023/03/05/Word2Vec/</url>
    
    <content type="html"><![CDATA[<h1 id="word2vec">Word2Vec</h1><p>由于深度神经网络无法向人类一样理解单词或者句子，因此需要将单词或者句子表达成网络可以理解的形式。</p><p>假设有一个词表<spanclass="math inline">\(\mathbf{V}=\{w_1,...,w_{|v|}\}\)</span>，对每一个单词<spanclass="math inline">\(w_i\)</span>来说，有两种表达方式，首先是独热码，其次是分布式表示。</p><h2 id="one-hot-representation">one-hot representation</h2><p>将每一个单词表示为一个向量，向量的长度是词表中单词的总数，每一个向量只有一个1剩下的值都是0。</p><h3 id="优点">优点</h3><ol type="1"><li>解释性强：每个单词有唯一对应的独热码，独热码的向量长度等于词表中单词的总数。</li><li>无信息丢失：词向量的维度等于单词的数量</li></ol><h3 id="缺点">缺点</h3><ol type="1"><li>高维数据导致运算复杂：由于每一个词向量的维度等于词表中单词的总数，因此每一个词向量的维度会高达几千到几万维，因此导致运算复杂度的大幅度上升。</li><li>效率低下：由于每一个词向量中只有一个1剩下都是0，因此从信息论的角度上说，利用率非常低</li><li>无法表示任意两个单词之间的相似性：由于使用了独热编码，任意两个单词之间都是正交的。</li></ol><h2 id="distributed-representation">distributed representation</h2><h2 id="优点-1">优点</h2><ol type="1"><li>和独热码相比维度较低。</li><li>向量中每一个元素取值范围为实数</li><li>可以表达两个单词之间的相似性信息</li></ol><h3 id="word2vec-1">word2vec</h3><p>假设：</p><ol type="1"><li>假设窗口大小为<span class="math inline">\(2c\)</span></li><li>假设任意两个词向量分布之间相互独立</li></ol><p>对于词表<span class="math inline">\(\bf{V}=\{w_1,...,W_T\}\)</span>来说，可以得到联合概率分布：</p><p><span class="math display">\[P(w_{1:T})=P(w_t)*P(\text{context}(w_t)|w_t)\]</span></p><p>给定<span class="math inline">\(w_t\)</span>可以得到条件似然：</p><p><span class="math display">\[P(w_{1:T})=P(w_t)P(w_{t-c : t-1},w_{t+1:t+c}|w_t)=\Pi_{t=1}^TP(w_{t-c:t-1},w_{t+1:t+c}|w_t)\]</span></p><p>平均条件似然可以表示为：</p><p><span class="math display">\[L = \frac{1}{T}\sum\limits_{t=1}^{T}\logP(w_{t-c:t-1},w_{t+1:t+c}|w_t)=\frac{1}{T}\sum\limits_{t=1}^{T}\sum\limits_{i\in[-c,c]}\log P(w_{t+1}|w_t)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinearRegression</title>
    <link href="/2023/03/05/LinearRegression/"/>
    <url>/2023/03/05/LinearRegression/</url>
    
    <content type="html"><![CDATA[<h1 id="linearregression">LinearRegression</h1><h2 id="简介">简介</h2><p>线性回归（linear regression）是线性模型的一种典型方法。</p><h2 id="基本原理">基本原理</h2><p>给定一组输入<span class="math inline">\(x\)</span>和输出<spanclass="math inline">\(y\)</span>构成的数据集<spanclass="math inline">\(D = \{(x_1,y_1),...,(x_m,y_m)\}\)</span>，其中<span class="math inline">\(y_{i}\in\mathbb{R}\)</span>。线性回归模型假设数据线性分布，因此想要学习一个线性模型使得预测值和真实值之间的误差最小。假设线性回归中输出和输入有如下的关系<span class="math display">\[y = wx_i+b\]</span> 利用均方误差最小化有： <span class="math display">\[\begin{aligned}(w^*,b^*)=\arg\min\sum_{i=1}^{m}(y-y_i)^2=\arg\min\sum_{i=1}^{m}(wx_i+b-y_i)^2\end{aligned}\tag{1}\label{eq1}\]</span> 从表达式<spanclass="math inline">\(\eqref{eq1}\)</span>中可以求得参数<spanclass="math inline">\(w^*\)</span>和<spanclass="math inline">\(b^*\)</span>的解析解。 <spanclass="math display">\[\begin{aligned}\frac{\partial L(w, b)}{\partial w} &amp; =\frac{\partial}{\partialw}\left[\sum_{i=1}^{m}\left(w x_{i}+b-y_{i}\right)^{2}\right]=\sum_{i=1}^{m} \frac{\partial}{\partial w}\left[\left(y_{i}-wx_{i}-b\right)^{2}\right] \\&amp; =\sum_{i=1}^{m}\left[2 \cdot\left(y_{i}-w x_{i}-b\right)\cdot\left(-x_{i}\right)\right] =\sum_{i=1}^{m}\left[2 \cdot\left(wx_{i}^{2}-y_{i} x_{i}+b x_{i}\right)\right] \\&amp; =2 \cdot\left(w \sum_{i=1}^{m} x_{i}^{2}-\sum_{i=1}^{m} y_{i}x_{i}+b \sum_{i=1}^{m} x_{i}\right)\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}\frac{\partial L(w, b)}{\partial b} &amp; =\frac{\partial}{\partialb}\left[\sum_{i=1}^{m}\left(w x_{i}+b-y_{i}\right)^{2}\right]=\sum_{i=1}^{m} \frac{\partial}{\partial b}\left[\left(y_{i}-wx_{i}-b\right)^{2}\right] \\&amp; =\sum_{i=1}^{m}\left[2 \cdot\left(y_{i}-w x_{i}-b\right)\cdot(-1)\right] =\sum_{i=1}^{m}\left[2 \cdot\left(-y_{i}+wx_{i}+b\right)\right] \\&amp; =2 \cdot\left(-\sum_{i=1}^{m} y_{i}+\sum_{i=1}^{m} wx_{i}+\sum_{i=1}^{m} b\right) =2 \cdot\left(mb-\sum_{i=1}^{m}\left(y_{i}-w x_{i}\right)\right)\end{aligned}\]</span> 最终得到权重<spanclass="math inline">\(w^*\)</span>和偏置<spanclass="math inline">\(b^*\)</span>的表达式 <span class="math display">\[\begin{aligned}w^{*}&amp;=\frac{\sum_{i=1}^{m}y_{i}\left(x_{i}-\bar{x}\right)}{\sum_{i=1}^{m}x_{i}^{2}-\frac{1}{m}\left(\sum_{i=1}^{m} x_{i}\right)^{2}} \\b^{*}&amp;=\frac{1}{m} \sum_{i=1}^{m}\left(y_{i}-w x_{i}\right)\end{aligned}\]</span> 形式<spanclass="math inline">\(\eqref{eq1}\)</span>是向量形式的线性回归，在实际中通常利用矩阵化将线性回归表达为矩阵形式，首先将输入<spanclass="math inline">\(x\)</span>拼接成矩阵形式： <spanclass="math display">\[\boldsymbol{X}=\left(\begin{array}{ccccc}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1 d} &amp; 1 \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2 d} &amp; 1 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\x_{m 1} &amp; x_{m 2} &amp; \cdots &amp; x_{m d} &amp; 1\end{array}\right)=\left(\begin{array}{cc}x_{1}^{\mathrm{T}} &amp; 1 \\\vdots &amp; \vdots \\x_{m}^{\mathrm{T}} &amp; 1\end{array}\right)\]</span> 将输出向量<spanclass="math inline">\(y\)</span>相应拼接为<spanclass="math inline">\(\mathbf{y}=(y_1;y_2;...;y_m)\)</span>，最终可以得到优化目标函数的矩阵化表达形式：<span class="math display">\[w^*=\arg\min(\mathbf{y}-\mathbf{X}\hat{w}^T)(\mathbf{y}-\mathbf{X}\hat{w})\]</span> 对权重矩阵和偏置矩阵求偏导数可得： <spanclass="math display">\[\begin{aligned}\frac{\partial L}{\partialw}&amp;=-\mathbf{X}^T\mathbf{y}-\mathbf{X}^T\mathbf{y}+(\mathbf{X^TX}+\mathbf{X^TX})\hat{w}\\\frac{\partial L}{\partialb}&amp;=2\mathbf{X}^T(\mathbf{X}\hat{w}-\mathbf{y})\end{aligned}\]</span> 根据梯度可以直接求得解析解： <span class="math display">\[\hat{w}=(\mathbf{X^{T}X})^{-1} \mathbf{X}^{T}\mathbf{y}\]</span></p><h2 id="代码实现">代码实现</h2><h3 id="基于numpy的算法实现">基于numpy的算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入numpy模块 </span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-comment">### 定义模型主体部分 </span><br><span class="hljs-comment">### 包括线性回归模型公式、均方损失函数和参数求偏导三部分</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_loss</span>(<span class="hljs-params">X, y, w, b</span>): <br><span class="hljs-string">&#x27;&#x27;&#x27; 输入： </span><br><span class="hljs-string">X：输入变量矩阵 </span><br><span class="hljs-string">y：输出标签向量 </span><br><span class="hljs-string">w：变量参数权重矩阵 </span><br><span class="hljs-string">b：偏置 </span><br><span class="hljs-string">输出： </span><br><span class="hljs-string">y_hat：线性回归模型预测值 </span><br><span class="hljs-string">loss：均方损失 </span><br><span class="hljs-string">dw：权重系数一阶偏导 </span><br><span class="hljs-string">db：偏置一阶偏导 </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span> <br><span class="hljs-comment"># 训练样本量 </span><br>num_train = X.shape[<span class="hljs-number">0</span>] <br><span class="hljs-comment"># 训练特征数 </span><br>num_feature = X.shape[<span class="hljs-number">1</span>] <br><span class="hljs-comment"># 线性回归预测值 </span><br>y_hat = np.dot(X, w) + b <br><span class="hljs-comment"># 计算预测值与实际标签之间的均方损失 </span><br>loss = np.<span class="hljs-built_in">sum</span>((y_hat-y)**<span class="hljs-number">2</span>) / num_train <br><span class="hljs-comment"># 基于均方损失对权重系数的一阶梯度 </span><br>dw = np.dot(X.T, (y_hat-y)) / num_train <br><span class="hljs-comment"># 基于均方损失对偏置的一阶梯度 </span><br>db = np.<span class="hljs-built_in">sum</span>((y_hat-y)) / num_train <br><span class="hljs-keyword">return</span> y_hat, loss, dw, db<br><span class="hljs-comment">### 初始化模型参数 </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_params</span>(<span class="hljs-params">dims</span>): <br><span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">输入： </span><br><span class="hljs-string">dims：训练数据的变量维度 </span><br><span class="hljs-string">输出： </span><br><span class="hljs-string">w：初始化权重系数 </span><br><span class="hljs-string">b：初始化偏置参数 </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span> <br><span class="hljs-comment"># 初始化权重系数为零向量 </span><br>w = np.zeros((dims, <span class="hljs-number">1</span>)) <br><span class="hljs-comment"># 初始化偏置参数为零 </span><br>b = <span class="hljs-number">0</span> <br><span class="hljs-keyword">return</span> w, b<br><span class="hljs-comment">### 定义线性回归模型的训练过程 </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_train</span>(<span class="hljs-params">X, y, learning_rate=<span class="hljs-number">0.01</span>, epochs=<span class="hljs-number">10000</span></span>): <br><span class="hljs-string">&#x27;&#x27;&#x27; 输入： </span><br><span class="hljs-string">X：输入变量矩阵 </span><br><span class="hljs-string">y：输出标签向量 </span><br><span class="hljs-string">learning_rate：学习率 </span><br><span class="hljs-string">epochs：训练迭代次数 </span><br><span class="hljs-string">输出： </span><br><span class="hljs-string">loss_his：每次迭代的均方损失 </span><br><span class="hljs-string">params：优化后的参数字典 </span><br><span class="hljs-string">grads：优化后的参数梯度字典 </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span> <br><span class="hljs-comment"># 记录训练损失的空列表 </span><br>loss_his = [] <br><span class="hljs-comment"># 初始化模型参数 </span><br>w, b = initialize_params(X.shape[<span class="hljs-number">1</span>]) <br><span class="hljs-comment"># 迭代训练 </span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, epochs): <br><span class="hljs-comment"># 计算当前迭代的预测值、均方损失和梯度 </span><br>y_hat, loss, dw, db = linear_loss(X, y, w, b) <br><span class="hljs-comment"># 基于梯度下降法的参数更新 </span><br>w += -learning_rate * dw <br>b += -learning_rate * db <br><span class="hljs-comment"># 记录当前迭代的损失 </span><br>loss_his.append(loss) <br><span class="hljs-comment"># 每10000次迭代打印当前损失信息 </span><br><span class="hljs-keyword">if</span> i % <span class="hljs-number">10000</span> == <span class="hljs-number">0</span>: <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch %d loss %f&#x27;</span> % (i, loss)) <br><span class="hljs-comment"># 将当前迭代步优化后的参数保存到字典中 </span><br>params = &#123; <br><span class="hljs-string">&#x27;w&#x27;</span>: w, <br><span class="hljs-string">&#x27;b&#x27;</span>: b <br>&#125; <br><span class="hljs-comment"># 将当前迭代步的梯度保存到字典中 </span><br>grads = &#123; <br><span class="hljs-string">&#x27;dw&#x27;</span>: dw, <br><span class="hljs-string">&#x27;db&#x27;</span>: db <br>&#125; <br><span class="hljs-keyword">return</span> loss_his, params, grads<br><br><span class="hljs-comment"># 导入load_diabetes模块 </span><br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_diabetes <br><span class="hljs-comment"># 导入打乱数据函数 </span><br><span class="hljs-keyword">from</span> sklearn.utils <span class="hljs-keyword">import</span> shuffle <br><span class="hljs-comment"># 获取diabetes数据集 </span><br>diabetes = load_diabetes() <br><span class="hljs-comment"># 获取输入和标签 </span><br>data, target = diabetes.data, diabetes.target <br><span class="hljs-comment"># 打乱数据集 </span><br>X, y = shuffle(data, target, random_state=<span class="hljs-number">13</span>) <br><span class="hljs-comment"># 按照8∶2划分训练集和测试集 </span><br>offset = <span class="hljs-built_in">int</span>(X.shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.8</span>) <br><span class="hljs-comment"># 训练集 </span><br>X_train, y_train = X[:offset], y[:offset] <br><span class="hljs-comment"># 测试集 </span><br>X_test, y_test = X[offset:], y[offset:] <br><span class="hljs-comment"># 将训练集改为列向量的形式 </span><br>y_train = y_train.reshape((-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) <br><span class="hljs-comment"># 将测试集改为列向量的形式 </span><br>y_test = y_test.reshape((-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) <br><span class="hljs-comment"># 打印训练集和测试集的维度 </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;X_train&#x27;s shape: &quot;</span>, X_train.shape) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;X_test&#x27;s shape: &quot;</span>, X_test.shape) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y_train&#x27;s shape: &quot;</span>, y_train.shape) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y_test&#x27;s shape: &quot;</span>, y_test.shape)<br><span class="hljs-comment"># 线性回归模型训练 </span><br>loss_his, params, grads = linear_train(X_train, y_train, <span class="hljs-number">0.01</span>, <span class="hljs-number">200000</span>) <br><span class="hljs-comment"># 打印训练后得到的模型参数 </span><br><span class="hljs-built_in">print</span>(params)<br><span class="hljs-comment">### 定义线性回归模型的预测函数 </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">X, params</span>): <br><span class="hljs-string">&#x27;&#x27;&#x27; 输入： </span><br><span class="hljs-string">X：测试集 </span><br><span class="hljs-string">params：模型训练参数 </span><br><span class="hljs-string">输出： </span><br><span class="hljs-string">y_pred：模型预测结果 </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span> <br><span class="hljs-comment"># 获取模型参数 </span><br>w = params[<span class="hljs-string">&#x27;w&#x27;</span>] <br>b = params[<span class="hljs-string">&#x27;b&#x27;</span>] <br><span class="hljs-comment"># 预测 </span><br>y_pred = np.dot(X, w) + b <br><span class="hljs-keyword">return</span> y_pred <br><span class="hljs-comment"># 基于测试集的预测 </span><br>y_pred = predict(X_test, params)<br><br><span class="hljs-comment">### 定义R2系数函数 </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">r2_score</span>(<span class="hljs-params">y_test, y_pred</span>): <br><span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">输入： </span><br><span class="hljs-string">y_test：测试集标签值 </span><br><span class="hljs-string">y_pred：测试集预测值 </span><br><span class="hljs-string">输出： </span><br><span class="hljs-string">r2：R2系数 </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span> <br><span class="hljs-comment"># 测试集标签均值 </span><br>y_avg = np.mean(y_test) <br><span class="hljs-comment"># 总离差平方和 </span><br>ss_tot = np.<span class="hljs-built_in">sum</span>((y_test - y_avg)**<span class="hljs-number">2</span>) <br><span class="hljs-comment"># 残差平方和 </span><br>ss_res = np.<span class="hljs-built_in">sum</span>((y_test - y_pred)**<span class="hljs-number">2</span>) <br><span class="hljs-comment"># R2计算 </span><br>r2 = <span class="hljs-number">1</span>- (ss_res/ss_tot) <br><span class="hljs-keyword">return</span> r2 <br><span class="hljs-comment"># 计算测试集的R2系数 </span><br><span class="hljs-built_in">print</span>(r2_score(y_test, y_pred))<br></code></pre></td></tr></table></figure><h3 id="基于sklearn的线性回归模型">基于sklearn的线性回归模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入线性回归模块 </span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> linear_model <br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error, r2_score <br><span class="hljs-comment"># 定义模型实例 </span><br>regr = linear_model.LinearRegression() <br><span class="hljs-comment"># 模型拟合训练数据 </span><br>regr.fit(X_train, y_train) <br><span class="hljs-comment"># 模型预测值 </span><br>y_pred = regr.predict(X_test) <br><span class="hljs-comment"># 输出模型均方误差 </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Mean squared error: %.2f&quot;</span>% mean_squared_error(y_test, y_pred)) <br><span class="hljs-comment"># 计算R2系数 </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;R Square score: %.2f&#x27;</span> % r2_score(y_test, y_pred))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广义西尔维斯特方程的求解</title>
    <link href="/2023/01/29/%E5%B9%BF%E4%B9%89%E8%A5%BF%E5%B0%94%E7%BB%B4%E6%96%AF%E7%89%B9%E6%96%B9%E7%A8%8B%E7%9A%84%E6%B1%82%E8%A7%A3/"/>
    <url>/2023/01/29/%E5%B9%BF%E4%B9%89%E8%A5%BF%E5%B0%94%E7%BB%B4%E6%96%AF%E7%89%B9%E6%96%B9%E7%A8%8B%E7%9A%84%E6%B1%82%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="广义西尔维斯特方程的求解">广义西尔维斯特方程的求解</h1><h2 id="常见的西尔维斯特方程">常见的西尔维斯特方程</h2><p>西尔维斯特方程</p><p><span class="math display">\[\mathbf{AX}+\mathbf{XD} = \mathbf{E}\]</span></p><hr /><p>广义西尔维斯特方程</p><p><span class="math display">\[\mathbf{AXB}+\mathbf{CXD} = \mathbf{E}\]</span></p><p>式中<span class="math inline">\(\mathbf{X}\in \mathbb{R}^{n\timesr}\)</span>, <span class="math inline">\(\mathbf{A}\in\mathbb{R}^{m\times n}\)</span>, <spanclass="math inline">\(\mathbf{B}\in \mathbb{R}^{r\times p}\)</span>,<span class="math inline">\(\mathbf{C}\in \mathbb{R}^{m\timesn}\)</span>, <span class="math inline">\(\mathbf{D}\in\mathbb{R}^{r\times p}\)</span>, <spanclass="math inline">\(\mathbf{E}\in \mathbb{R}^{m\timesp}\)</span>。</p><hr /><p>Stein矩阵方程</p><p><span class="math display">\[\mathbf{AXB}+\mathbf{X} = \mathbf{E}\]</span></p><hr /><p>Lyapunov 矩阵方程</p><p><span class="math display">\[\mathbf{AX}+\mathbf{XA^T}=\mathbf{E}\]</span></p><hr /><h2 id="求解广义西尔维斯特方程">求解广义西尔维斯特方程</h2><ol type="1"><li>使用闭式解</li><li>使用牛顿法或者共轭梯度法</li></ol><h2id="使用admm求解广义西尔维斯特方程">使用ADMM求解广义西尔维斯特方程</h2><p><span class="math display">\[\begin{cases}\mathbf{AXB}+\mathbf{CXD}=\mathbf{E}\\\mathbf{AXB}+\mathbf{CXD}=\mathbf{E}\end{cases}\]</span></p><p>移项构造同解方程组</p><p><span class="math display">\[\begin{cases}\mathbf{AXB}=\mathbf{E}-\mathbf{CXD}\\\mathbf{CXD}=\mathbf{E}-\mathbf{AXB}\end{cases}\]</span></p><p>令</p><p><span class="math display">\[\begin{cases}\mathbf{E}_1=\mathbf{E}-\mathbf{CXD}\\\mathbf{E}_2=\mathbf{E}-\mathbf{AXB}\end{cases}\]</span></p><p>可以得到</p><p><span class="math display">\[\begin{cases}\mathbf{AXB}=\mathbf{E}_1\\\mathbf{CXD}=\mathbf{E}_2\end{cases}\]</span></p><p>上两个方程组是同解方程组因此两个<spanclass="math inline">\(\mathbf{X}\)</span>拥有相同的解，因此可以写为</p><p><span class="math display">\[\begin{cases}\mathbf{AX_1B}=\mathbf{E}_1\\\mathbf{CX_2D}=\mathbf{E}_2\end{cases}\]</span></p><p>先求解<spanclass="math inline">\(\mathbf{AX_1B}=\mathbf{E}_1\)</span></p><p><span class="math display">\[\begin{aligned}\min_{\mathbf{X}_1, \mathbf{Z}_1} &amp; \quad \frac{1}{2} \left\|\mathbf{Z_1B-E_1} \right\|_F^2 \\\\\text{s.t.} &amp; \quad \mathbf{Z}_1 = \mathbf{AX}_1\end{aligned}\]</span></p><p>利用ADMM可以得到</p><p><span class="math display">\[\begin{aligned}\mathbf{Z}_1 &amp;=\left((\mathbf{E-CX_2D})\mathbf{B}^T+\eta\mathbf{AX_1-Q_1}\right)\left(\mathbf{BB}^T+\eta\mathbf{I}\right)^{-1}\\\\\mathbf{X}_1 &amp;=\left(\eta\mathbf{A^TA}\right)^{-1}\left(\mathbf{A^TQ_1}+\eta\mathbf{A^TZ_1}\right)\\\\\mathbf{Q_1} &amp;= \mathbf{Q_1} +\eta\left(\mathbf{Z}_1-\mathbf{AX_1}\right)\end{aligned}\]</span></p><hr /><p>同样的对<spanclass="math inline">\(\mathbf{CX_2D}=\mathbf{E}_2\)</span>使用ADMM求解有</p><p><span class="math display">\[\begin{aligned}\min_{\mathbf{X}_2, \mathbf{Z}_2} &amp; \quad \frac{1}{2} \left\|\mathbf{Z_2D-E_2} \right\|_F^2 \\\\\text{s.t.} &amp; \quad \mathbf{Z}_2 = \mathbf{CX}_2\end{aligned}\]</span></p><p>利用ADMM可以得到</p><p><span class="math display">\[\begin{align}\mathbf{Z}_2 &amp;=\left((\mathbf{E-AX_1B})\mathbf{D}^T+\eta\mathbf{CX_2-Q_2}\right)\left(\mathbf{DD}^T+\eta\mathbf{I}\right)^{-1}\\\\\mathbf{X}_2 &amp;=\left(\eta\mathbf{C^TC}\right)^{-1}\left(\mathbf{C^TQ_2}+\eta\mathbf{C^TZ_2}\right)\\\\\mathbf{Q_2} &amp;= \mathbf{Q_2} +\eta\left(\mathbf{Z}_2-\mathbf{CX_2}\right)\end{align}\]</span></p><p>对公式(2)和公式(4)依次迭代可以得到最终的<spanclass="math inline">\(\mathbf{X}_1\)</span>和<spanclass="math inline">\(\mathbf{X}_2\)</span> 最后：</p><p><span class="math display">\[\mathbf{X} = \eta\mathbf{X}_1+(1-\eta)\mathbf{X}_2\]</span></p><p>其中<span class="math inline">\(\eta&gt;0\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>Optimization</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ADMM</tag>
      
      <tag>Sylvester equation</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
